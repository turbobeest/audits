# ============================================================
# AUDIT: Fuzzing
# ============================================================
# Evaluates fuzz testing practices for discovering vulnerabilities
# through automated generation of unexpected inputs.
# ============================================================

audit:
  id: "testing-quality-assurance.security-testing.fuzzing"
  name: "Fuzzing"
  version: "1.0.0"
  last_updated: "2026-01-19"
  status: "active"

  category: "testing-quality-assurance"
  category_number: 10
  subcategory: "security-testing"

  tier: "expert"
  estimated_duration: "4 hours"

  completeness: "complete"
  requires_runtime: true
  destructive: false

execution:
  automatable: "yes"
  severity: "high"
  scope: "security"

  default_profiles:
    - "full"
    - "security"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Examines fuzz testing (fuzzing) practices including fuzzer selection,
    target coverage, crash analysis, and integration with development
    workflows. Reviews both coverage-guided and grammar-based fuzzing
    approaches for finding memory corruption, parsing errors, and
    unexpected behavior.

  why_it_matters: |
    Fuzzing discovers vulnerabilities that static analysis and traditional
    testing miss. It finds edge cases, parser bugs, and memory safety issues
    by generating millions of unexpected inputs. Many critical CVEs are
    discovered through fuzzing, making it essential for security-critical code.

  when_to_run:
    - "Continuous fuzzing for critical components"
    - "Before releases of security-sensitive code"
    - "After parser or protocol implementation changes"
    - "For input validation code"

prerequisites:
  required_artifacts:
    - type: "fuzzing-harness"
      description: "Fuzz testing harnesses and configurations"
    - type: "build-system"
      description: "Build system with fuzzing support"

  access_requirements:
    - "Fuzzing infrastructure access"
    - "Crash report storage"
    - "Code coverage reports"

discovery:
  file_patterns:
    - glob: "**/fuzz/**"
      purpose: "Fuzzing directories"
    - glob: "**/*fuzz*.{c,cpp,rs,go}"
      purpose: "Fuzz target files"
    - glob: "**/corpus/**"
      purpose: "Fuzz corpus directories"
    - glob: "**/.clusterfuzzlite/**"
      purpose: "ClusterFuzzLite configuration"

  code_patterns:
    - pattern: "LLVMFuzzerTestOneInput|fuzz_target|FuzzTest"
      type: "keyword"
      scope: "source"
      purpose: "Fuzz target entry points"
    - pattern: "AFL|libFuzzer|honggfuzz|go-fuzz"
      type: "keyword"
      scope: "config"
      purpose: "Fuzzer tool references"
    - pattern: "corpus|seed|input"
      type: "keyword"
      scope: "config"
      purpose: "Fuzz corpus configuration"

knowledge_sources:
  specifications:
    - id: "owasp-asvs"
      name: "OWASP ASVS"
      url: "https://owasp.org/www-project-application-security-verification-standard/"
      offline_cache: true
      priority: "recommended"

  guides:
    - id: "google-fuzzing"
      name: "Google OSS-Fuzz"
      url: "https://google.github.io/oss-fuzz/"
      offline_cache: true
    - id: "libfuzzer"
      name: "libFuzzer Documentation"
      url: "https://llvm.org/docs/LibFuzzer.html"
      offline_cache: true

  learning_resources:
    - id: "fuzzing-book"
      title: "The Fuzzing Book"
      type: "book"
      reference: "https://www.fuzzingbook.org/"

tooling:
  static_analysis:
    - tool: "libFuzzer"
      purpose: "Coverage-guided fuzzing for C/C++"
      offline_capable: true
    - tool: "AFL++"
      purpose: "Advanced fuzzing framework"
      offline_capable: true
    - tool: "go-fuzz"
      purpose: "Go language fuzzing"
      offline_capable: true
    - tool: "cargo-fuzz"
      purpose: "Rust fuzzing"
      offline_capable: true
    - tool: "Atheris"
      purpose: "Python fuzzing with libFuzzer"
      offline_capable: true

  infrastructure_tools:
    - tool: "OSS-Fuzz"
      purpose: "Continuous fuzzing infrastructure"
      command: "python infra/helper.py run_fuzzer PROJECT FUZZER"
    - tool: "ClusterFuzzLite"
      purpose: "CI/CD integrated fuzzing"
      command: "bash .clusterfuzzlite/build.sh"

signals:
  critical:
    - id: "FUZZ-CRIT-001"
      signal: "No fuzzing for security-critical parsers"
      evidence_pattern: "Parser code without fuzz targets"
      explanation: |
        Parsers handling untrusted input are prime targets for exploitation.
        Without fuzzing, parser bugs like buffer overflows, integer overflows,
        and format string vulnerabilities remain undiscovered.
      remediation: "Implement fuzz testing for all parsers handling untrusted input"

    - id: "FUZZ-CRIT-002"
      signal: "Fuzz crashes not triaged or fixed"
      evidence_pattern: "Crash reports without corresponding fixes"
      explanation: |
        Discovered crashes represent exploitable vulnerabilities. Unfixed
        crashes leave the system vulnerable to attacks using the same inputs
        the fuzzer discovered.
      remediation: "Triage and fix all unique crashes discovered by fuzzing"

  high:
    - id: "FUZZ-HIGH-001"
      signal: "Fuzzing not integrated into CI/CD"
      evidence_pattern: "Fuzz targets exist but not run continuously"
      explanation: |
        Manual-only fuzzing provides limited coverage. Continuous fuzzing
        discovers more bugs by accumulating execution time. CI/CD integration
        catches regressions immediately.
      remediation: "Integrate fuzzing into CI/CD for continuous execution"

    - id: "FUZZ-HIGH-002"
      signal: "No coverage-guided fuzzing"
      evidence_pattern: "Random fuzzing without coverage feedback"
      explanation: |
        Coverage-guided fuzzing is exponentially more effective than random
        fuzzing. Without coverage feedback, fuzzers repeat the same code
        paths instead of exploring new ones.
      remediation: "Use coverage-guided fuzzers like libFuzzer or AFL++"

  medium:
    - id: "FUZZ-MED-001"
      signal: "Fuzz corpus not maintained"
      evidence_pattern: "No seed corpus or corpus minimization"
      remediation: "Maintain and minimize fuzz corpus for effective coverage"

    - id: "FUZZ-MED-002"
      signal: "Sanitizers not enabled during fuzzing"
      evidence_pattern: "Fuzzing without ASan/MSan/UBSan"
      remediation: "Enable sanitizers (ASan, MSan, UBSan) during fuzz testing"

  low:
    - id: "FUZZ-LOW-001"
      signal: "Fuzz coverage metrics not tracked"
      remediation: "Track and report fuzzing coverage metrics"

  positive:
    - id: "FUZZ-POS-001"
      signal: "Comprehensive coverage-guided fuzzing with CI/CD integration"
    - id: "FUZZ-POS-002"
      signal: "Active crash triage and remediation process"

procedure:
  context:
    cognitive_mode: "critical"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Identify fuzzing infrastructure"
      description: |
        Search for fuzz targets, fuzzing configurations, and crash
        storage locations.
      duration_estimate: "30 min"
      commands:
        - purpose: "Find fuzz target files"
          command: "find . -type f \\( -name '*fuzz*' -o -path '*/fuzz/*' \\) -not -path '*/node_modules/*' 2>/dev/null"
        - purpose: "Check for fuzzer configurations"
          command: "grep -r 'LLVMFuzzer\\|AFL\\|go-fuzz\\|cargo.*fuzz' . 2>/dev/null | head -20"
      expected_findings:
        - "Fuzz target files"
        - "Fuzzer configurations"

    - id: "2"
      name: "Review fuzz target coverage"
      description: |
        Examine which components have fuzz targets, particularly
        parsers and input handlers.
      duration_estimate: "40 min"
      commands:
        - purpose: "Find parser files"
          command: "find . -type f \\( -name '*parse*' -o -name '*decode*' \\) -not -path '*/node_modules/*' 2>/dev/null"
        - purpose: "Check for corresponding fuzz targets"
          command: "ls -la fuzz/ 2>/dev/null || find . -type d -name 'fuzz' 2>/dev/null"
      expected_findings:
        - "Parser implementations"
        - "Corresponding fuzz targets"

    - id: "3"
      name: "Verify CI/CD integration"
      description: |
        Check that fuzzing is integrated into the CI/CD pipeline
        for continuous execution.
      duration_estimate: "25 min"
      commands:
        - purpose: "Check CI/CD for fuzzing"
          command: "grep -r 'fuzz\\|clusterfuzz\\|oss-fuzz' .github/workflows/ 2>/dev/null"
        - purpose: "Check for ClusterFuzzLite"
          command: "ls -la .clusterfuzzlite/ 2>/dev/null"
      expected_findings:
        - "Fuzzing stages in CI/CD"
        - "Continuous fuzzing configuration"

    - id: "4"
      name: "Review sanitizer configuration"
      description: |
        Verify that sanitizers are enabled during fuzzing to
        catch memory safety issues.
      duration_estimate: "25 min"
      commands:
        - purpose: "Check for sanitizer flags"
          command: "grep -r 'sanitize=\\|ASAN\\|MSAN\\|UBSAN' . --include='Makefile' --include='CMakeLists.txt' --include='*.sh' 2>/dev/null"
      expected_findings:
        - "Sanitizer configurations"
        - "Build flags for fuzzing"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"
    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Fuzzing Coverage Assessment"
        - "CI/CD Integration Analysis"
        - "Recommendations"

  confidence_guidance:
    high: "Fuzz targets verified, CI/CD integration confirmed, coverage reviewed"
    medium: "Fuzz targets exist but integration unclear"
    low: "Limited visibility into fuzzing practices"

offline:
  capability: "full"
  cache_manifest:
    knowledge:
      - source_id: "google-fuzzing"
        priority: "recommended"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires detailed fuzzing infrastructure analysis"
    full:
      included: true
      priority: 2
    security:
      included: true
      priority: 1

closeout_checklist:
  - id: "fuzzing-001"
    item: "Fuzz targets exist for critical parsers"
    level: "CRITICAL"
    verification: "find . -type f -name '*fuzz*' -not -path '*/node_modules/*' 2>/dev/null | head -1 | grep -q . && echo PASS || echo FAIL"
    expected: "PASS"

  - id: "fuzzing-002"
    item: "Fuzzing integrated into CI/CD"
    level: "BLOCKING"
    verification: "grep -r 'fuzz' .github/workflows/ 2>/dev/null | grep -q . && echo PASS || echo FAIL"
    expected: "PASS"

  - id: "fuzzing-003"
    item: "Sanitizers enabled during fuzzing"
    level: "WARNING"
    verification: "grep -r 'sanitize=' . --include='Makefile' --include='*.sh' 2>/dev/null | grep -q . && echo PASS || echo FAIL"
    expected: "PASS"

governance:
  applicable_to:
    archetypes: ["library", "api-service", "systems-software"]

  compliance_frameworks:
    - framework: "Internal"
      controls: ["SEC-003"]

relationships:
  commonly_combined:
    - "testing-quality-assurance.security-testing.static-security-analysis"
    - "testing-quality-assurance.security-testing.vulnerability-scanning"
    - "testing-quality-assurance.test-automation.ci-integration"
