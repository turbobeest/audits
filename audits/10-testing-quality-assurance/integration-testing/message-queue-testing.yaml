# ============================================================
# AUDIT: Message Queue Testing
# ============================================================
# Evaluates testing practices for message queue integrations
# including publish/subscribe, error handling, and delivery.
# ============================================================

audit:
  id: "testing-quality-assurance.integration-testing.message-queue-testing"
  name: "Message Queue Testing"
  version: "1.0.0"
  last_updated: "2026-01-19"
  status: "active"

  category: "testing-quality-assurance"
  category_number: 10
  subcategory: "integration-testing"

  tier: "expert"
  estimated_duration: "2 hours"

  completeness: "complete"
  requires_runtime: true
  destructive: false

execution:
  automatable: "partial"
  severity: "high"
  scope: "testing"

  default_profiles:
    - "full"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Assesses testing practices for message queue integrations including
    message publishing, subscription handling, message serialization,
    dead letter queues, retry logic, message ordering, and idempotency.
    Covers systems like RabbitMQ, Kafka, SQS, and similar.

  why_it_matters: |
    Message queue issues cause data loss, duplicate processing, and
    system desynchronization. These problems are often invisible until
    they cause significant damage. Testing message handling ensures
    reliable asynchronous communication between services.

  when_to_run:
    - "When implementing event-driven architectures"
    - "Before deploying queue consumers"
    - "After message format changes"
    - "Reliability reviews"

prerequisites:
  required_artifacts:
    - type: "message_handlers"
      description: "Message publishers and consumers"
    - type: "queue_config"
      description: "Message queue configuration"

  access_requirements:
    - "Source code repository access"
    - "Test message queue access"
    - "Queue configuration access"

discovery:
  file_patterns:
    - glob: "**/queues/**"
      purpose: "Queue-related code"
    - glob: "**/consumers/**"
      purpose: "Message consumers"
    - glob: "**/publishers/**"
      purpose: "Message publishers"
    - glob: "**/*queue*.test.{js,ts}"
      purpose: "Queue tests"

  code_patterns:
    - pattern: "amqplib|rabbitmq|kafka|sqs|pubsub"
      type: "keyword"
      scope: "source"
      purpose: "Identify message queue libraries"
    - pattern: "publish|subscribe|consume|producer|consumer"
      type: "keyword"
      scope: "source"
      purpose: "Identify pub/sub patterns"
    - pattern: "deadLetter|dlq|retry|nack"
      type: "keyword"
      scope: "source"
      purpose: "Identify error handling patterns"

knowledge_sources:
  guides:
    - id: "message-queue-testing"
      name: "Testing Message-Driven Applications"
      url: "https://www.rabbitmq.com/tutorials/tutorial-one-javascript.html"
      offline_cache: true

  learning_resources:
    - id: "enterprise-integration"
      title: "Enterprise Integration Patterns"
      type: "book"
      reference: "ISBN 978-0321200686"

tooling:
  infrastructure_tools:
    - tool: "testcontainers"
      purpose: "Spin up real message queues for testing"
      command: "docker run -d rabbitmq:management"
    - tool: "localstack"
      purpose: "AWS SQS/SNS emulation"
      command: "localstack start"

  scripts:
    - id: "queue-test-analyzer"
      language: "bash"
      purpose: "Analyze message queue testing"
      source: "inline"
      code: |
        #!/bin/bash
        echo "=== Message Queue Testing Analysis ==="
        echo "Queue-related test files:"
        find . \( -name '*queue*' -o -name '*consumer*' -o -name '*publisher*' \) -name '*.test.*' 2>/dev/null | grep -v node_modules | head -15
        echo ""
        echo "Message queue libraries in tests:"
        grep -r 'amqplib\|rabbitmq\|kafka\|sqs\|pubsub' --include='*.test.*' . 2>/dev/null | grep -v node_modules | head -10
        echo ""
        echo "Dead letter/retry testing:"
        grep -r 'deadLetter\|dlq\|retry\|nack' --include='*.test.*' . 2>/dev/null | grep -v node_modules | head -10

signals:
  critical:
    - id: "QUEUE-CRIT-001"
      signal: "No message queue integration tests exist"
      evidence_pattern: "Queue consumers/publishers without tests"
      explanation: |
        Untested message handling leads to silent data loss, duplicate
        processing, and desynchronized systems that are hard to debug.
      remediation: "Add integration tests for all message handlers"

    - id: "QUEUE-CRIT-002"
      signal: "Message failure scenarios not tested"
      evidence_pattern: "No tests for nack, retry, or dead letter handling"
      explanation: |
        Failure handling is critical for reliable messaging. Untested
        failure paths cause message loss or infinite retry loops.
      remediation: "Add tests for all failure and retry scenarios"

  high:
    - id: "QUEUE-HIGH-001"
      signal: "Message serialization not tested"
      evidence_pattern: "No tests for message format validation"
      explanation: |
        Serialization bugs cause message rejection or corruption.
        Both producers and consumers should validate message format.
      remediation: "Add serialization/deserialization tests"

    - id: "QUEUE-HIGH-002"
      signal: "Idempotency not tested"
      evidence_pattern: "No tests for duplicate message handling"
      explanation: |
        Message queues can deliver duplicates. Without idempotency tests,
        duplicate processing goes undetected until production.
      remediation: "Add tests verifying idempotent message handling"

  medium:
    - id: "QUEUE-MED-001"
      signal: "Message ordering not tested"
      evidence_pattern: "No tests for out-of-order message handling"
      remediation: "Add tests for message ordering requirements"

    - id: "QUEUE-MED-002"
      signal: "Queue connection handling not tested"
      evidence_pattern: "No tests for reconnection behavior"
      remediation: "Add tests for connection failure and recovery"

  low:
    - id: "QUEUE-LOW-001"
      signal: "Message processing timing not tested"
      evidence_pattern: "No timeout or latency tests"

  positive:
    - id: "QUEUE-POS-001"
      signal: "Comprehensive message flow testing"
      evidence_pattern: "End-to-end message flow tests exist"
    - id: "QUEUE-POS-002"
      signal: "Dead letter queue testing implemented"
      evidence_pattern: "DLQ behavior verified in tests"

procedure:
  context:
    cognitive_mode: "critical"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Identify queue components"
      description: |
        Locate all message queue-related code including publishers,
        consumers, and handlers.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find queue-related files"
          command: "find . \\( -name '*queue*' -o -name '*consumer*' -o -name '*publisher*' -o -name '*handler*' \\) -type f 2>/dev/null | grep -v node_modules | grep -v test | head -20"
        - purpose: "Find queue libraries"
          command: "grep -r -l 'amqplib\\|kafka\\|sqs\\|pubsub\\|rabbitmq' --include='*.ts' --include='*.js' . 2>/dev/null | grep -v node_modules | head -15"
      expected_findings:
        - "Queue component inventory"
        - "Messaging patterns used"

    - id: "2"
      name: "Analyze queue tests"
      description: |
        Review tests for message queue components and assess
        coverage of key scenarios.
      duration_estimate: "25 min"
      commands:
        - purpose: "Find queue tests"
          command: "find . \\( -name '*queue*' -o -name '*consumer*' -o -name '*publisher*' \\) -name '*.test.*' 2>/dev/null | grep -v node_modules | head -15"
        - purpose: "Check test patterns"
          command: "grep -r 'publish\\|consume\\|subscribe\\|send' --include='*.test.*' . 2>/dev/null | grep -v node_modules | head -20"
      expected_findings:
        - "Test coverage"
        - "Test scenarios covered"

    - id: "3"
      name: "Review failure handling tests"
      description: |
        Check whether failure scenarios are tested including
        retries, dead letter queues, and error handling.
      duration_estimate: "25 min"
      commands:
        - purpose: "Find failure handling tests"
          command: "grep -r 'retry\\|dead.*letter\\|dlq\\|nack\\|reject' --include='*.test.*' . 2>/dev/null | head -15"
        - purpose: "Find error scenario tests"
          command: "grep -r 'throw\\|error\\|fail' --include='*queue*.test.*' --include='*consumer*.test.*' . 2>/dev/null | head -10"
      expected_findings:
        - "Failure handling coverage"
        - "Retry logic testing"

    - id: "4"
      name: "Check idempotency testing"
      description: |
        Verify that duplicate message handling is tested to
        ensure idempotent processing.
      duration_estimate: "15 min"
      commands:
        - purpose: "Find idempotency tests"
          command: "grep -r 'idempoten\\|duplicate\\|already.*processed' --include='*.test.*' . 2>/dev/null | head -10"
      expected_findings:
        - "Idempotency test presence"
        - "Duplicate handling verification"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "queue_test_report"
      format: "table"
      sections:
        - "Queue Component Inventory"
        - "Test Coverage"
        - "Failure Handling"
        - "Idempotency Testing"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Message Queue Testing Assessment"
        - "Risk Analysis"
        - "Recommendations"

  confidence_guidance:
    high: "Tests executed against real queue"
    medium: "Test files reviewed"
    low: "Based on file patterns only"

offline:
  capability: "partial"

  cache_manifest:
    knowledge:
      - source_id: "message-queue-testing"
        priority: "required"

profiles:
  membership:
    quick:
      included: false
      reason: "Queue testing requires runtime environment"
    full:
      included: true
      priority: 2

closeout_checklist:
  - id: "queue-001"
    item: "Queue components identified"
    level: "CRITICAL"
    verification: "find . -name '*queue*' -o -name '*consumer*' | grep -v test | wc -l"
    expected: "PASS (inventory documented)"

  - id: "queue-002"
    item: "Queue tests assessed"
    level: "BLOCKING"
    verification: "find . -name '*queue*.test.*' -o -name '*consumer*.test.*' | wc -l"
    expected: "PASS (count documented)"

  - id: "queue-003"
    item: "Failure handling tested"
    level: "BLOCKING"
    verification: "manual"
    verification_notes: "Document retry and DLQ test coverage"
    expected: "Confirmed by reviewer"

governance:
  applicable_to:
    archetypes: ["microservices", "event-driven"]

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Reliability"]

relationships:
  commonly_combined:
    - "testing-quality-assurance.integration-testing.integration-test-isolation"
    - "reliability-resilience.fault-tolerance.retry-strategies"
    - "reliability-resilience.fault-tolerance.dead-letter-handling"
