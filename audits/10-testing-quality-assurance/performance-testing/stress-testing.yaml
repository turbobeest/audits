# ============================================================
# AUDIT: Stress Testing
# ============================================================
# Evaluates system behavior under extreme load conditions to
# identify breaking points and failure modes.
# ============================================================

audit:
  id: "testing-quality-assurance.performance-testing.stress-testing"
  name: "Stress Testing"
  version: "1.0.0"
  last_updated: "2026-01-19"
  status: "active"

  category: "testing-quality-assurance"
  category_number: 10
  subcategory: "performance-testing"

  tier: "expert"
  estimated_duration: "4 hours"

  completeness: "complete"
  requires_runtime: true
  destructive: true

execution:
  automatable: "partial"
  severity: "high"
  scope: "testing"

  default_profiles:
    - "full"
    - "production"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Examines stress testing practices to verify systems are tested beyond
    normal operating capacity. Reviews stress test configurations, breaking
    point identification, recovery behavior analysis, and failure mode
    documentation. Evaluates whether the system gracefully degrades under
    extreme conditions.

  why_it_matters: |
    Without stress testing, teams don't know where systems break. This leads
    to catastrophic failures during unexpected traffic spikes, cascade failures
    across services, and extended outages. Understanding breaking points enables
    proper capacity planning, alerting thresholds, and graceful degradation
    strategies.

  when_to_run:
    - "After major architecture changes"
    - "Before critical product launches"
    - "Capacity planning cycles"
    - "After scaling infrastructure"

prerequisites:
  required_artifacts:
    - type: "stress-test-configuration"
      description: "Stress testing configurations and scenarios"
    - type: "capacity-requirements"
      description: "Expected peak load and growth projections"

  access_requirements:
    - "Isolated test environment (stress testing can be destructive)"
    - "Monitoring and alerting systems"
    - "Infrastructure scaling controls"

discovery:
  file_patterns:
    - glob: "**/stress-test*/**"
      purpose: "Stress testing directories"
    - glob: "**/chaos/**"
      purpose: "Chaos engineering configurations"
    - glob: "**/load-test*/**/*stress*"
      purpose: "Stress scenarios in load tests"

  code_patterns:
    - pattern: "breaking.*point|max.*load|limit"
      type: "regex"
      scope: "config"
      purpose: "Breaking point configurations"
    - pattern: "stress|spike|surge"
      type: "keyword"
      scope: "config"
      purpose: "Stress test indicators"
    - pattern: "recovery|graceful.*degrad"
      type: "regex"
      scope: "config"
      purpose: "Recovery behavior tests"

knowledge_sources:
  guides:
    - id: "chaos-eng-book"
      name: "Chaos Engineering: System Resiliency in Practice"
      url: "https://www.oreilly.com/library/view/chaos-engineering/9781492043850/"
      offline_cache: true

  learning_resources:
    - id: "netflix-chaos"
      title: "Netflix Chaos Engineering"
      type: "article"
      reference: "https://netflix.github.io/chaosmonkey/"

tooling:
  static_analysis:
    - tool: "k6"
      purpose: "Stress testing with ramping scenarios"
      offline_capable: true
    - tool: "Gatling"
      purpose: "High-volume stress scenarios"
      offline_capable: true
    - tool: "Vegeta"
      purpose: "HTTP load testing at constant rate"
      offline_capable: true

  infrastructure_tools:
    - tool: "Chaos Monkey"
      purpose: "Instance failure injection"
      command: "chaos-monkey run --probability 0.1"
    - tool: "Gremlin"
      purpose: "Comprehensive chaos engineering"
      command: "gremlin attack create"

  monitoring_queries:
    - system: "Prometheus"
      query: "rate(http_requests_total{status=~'5..'}[1m]) / rate(http_requests_total[1m]) * 100"
      purpose: "Error rate during stress"
    - system: "Prometheus"
      query: "max_over_time(process_resident_memory_bytes[1h])"
      purpose: "Peak memory during stress"

signals:
  critical:
    - id: "STRESS-CRIT-001"
      signal: "No stress testing performed"
      evidence_pattern: "Absence of stress test configurations or scenarios"
      explanation: |
        Without stress testing, the breaking point is unknown. Systems may fail
        catastrophically without warning during traffic spikes, with no understanding
        of failure modes or recovery characteristics.
      remediation: "Implement stress testing to identify breaking points and failure modes"

    - id: "STRESS-CRIT-002"
      signal: "System lacks graceful degradation under stress"
      evidence_pattern: "Complete system failure without degradation handling"
      explanation: |
        Systems that fail completely under stress cause total service outages.
        Graceful degradation allows partial functionality to continue, preserving
        critical operations during overload conditions.
      remediation: "Implement circuit breakers, load shedding, and graceful degradation patterns"

  high:
    - id: "STRESS-HIGH-001"
      signal: "Breaking points not documented"
      evidence_pattern: "No documentation of system limits and breaking points"
      explanation: |
        Unknown breaking points prevent proactive capacity planning and proper
        alerting threshold configuration. Teams cannot plan for scale without
        knowing current limits.
      remediation: "Document breaking points and update capacity planning accordingly"

    - id: "STRESS-HIGH-002"
      signal: "Recovery time not measured"
      evidence_pattern: "No metrics on system recovery after stress"
      explanation: |
        Understanding recovery time is essential for incident response planning.
        Systems that take hours to recover from stress require different handling
        than those that recover in seconds.
      remediation: "Measure and document recovery time objectives (RTO) after stress events"

  medium:
    - id: "STRESS-MED-001"
      signal: "Stress tests not run in production-like environment"
      evidence_pattern: "Stress testing in undersized environments"
      remediation: "Run stress tests in environments matching production topology"

    - id: "STRESS-MED-002"
      signal: "Dependent services not included in stress testing"
      evidence_pattern: "Isolated stress tests without service dependencies"
      remediation: "Include dependent services or realistic stubs in stress testing"

  low:
    - id: "STRESS-LOW-001"
      signal: "Stress test results not archived"
      remediation: "Archive stress test results for trend analysis and comparison"

  positive:
    - id: "STRESS-POS-001"
      signal: "Comprehensive stress testing with documented breaking points"
    - id: "STRESS-POS-002"
      signal: "Graceful degradation verified under extreme load"

procedure:
  context:
    cognitive_mode: "critical"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Identify stress testing artifacts"
      description: |
        Search for stress testing configurations, chaos engineering tools,
        and documentation of breaking points.
      duration_estimate: "30 min"
      commands:
        - purpose: "Find stress test configurations"
          command: "find . -type f -name '*stress*' -o -type d -name '*stress*' 2>/dev/null"
        - purpose: "Check for chaos engineering tools"
          command: "grep -r 'chaos\\|gremlin\\|litmus' . --include='*.yaml' --include='*.yml' 2>/dev/null"
      expected_findings:
        - "Stress test scenario files"
        - "Chaos engineering configurations"

    - id: "2"
      name: "Review stress test scenarios"
      description: |
        Examine stress test configurations for appropriate load levels,
        spike patterns, and sustained overload scenarios.
      duration_estimate: "45 min"
      commands:
        - purpose: "Check for spike/surge configurations"
          command: "grep -r 'spike\\|surge\\|ramp.*up' --include='*.js' --include='*.py' 2>/dev/null"
        - purpose: "Find maximum load configurations"
          command: "grep -r 'max\\|limit\\|breaking' --include='*.js' --include='*.yaml' 2>/dev/null"
      expected_findings:
        - "Spike load scenarios"
        - "Maximum load configurations"

    - id: "3"
      name: "Verify graceful degradation"
      description: |
        Check for circuit breakers, rate limiting, and graceful degradation
        implementations that activate under stress.
      duration_estimate: "40 min"
      commands:
        - purpose: "Find circuit breaker implementations"
          command: "grep -r 'circuit.*breaker\\|CircuitBreaker\\|hystrix' . --include='*.java' --include='*.js' --include='*.py' 2>/dev/null"
        - purpose: "Check for rate limiting"
          command: "grep -r 'rate.*limit\\|throttle\\|backpressure' . --include='*.java' --include='*.js' --include='*.py' 2>/dev/null"
      expected_findings:
        - "Circuit breaker implementations"
        - "Rate limiting configurations"

    - id: "4"
      name: "Review breaking point documentation"
      description: |
        Verify that breaking points are documented with specific metrics,
        thresholds, and capacity limits.
      duration_estimate: "30 min"
      commands:
        - purpose: "Find capacity documentation"
          command: "find . -type f -name '*capacity*' -o -name '*limits*' 2>/dev/null"
      expected_findings:
        - "Documented capacity limits"
        - "Breaking point analysis"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"
    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Breaking Point Analysis"
        - "Graceful Degradation Assessment"
        - "Recovery Time Evaluation"
        - "Recommendations"

  confidence_guidance:
    high: "Stress tests executed, breaking points verified, recovery observed"
    medium: "Configuration reviewed, execution not observed"
    low: "Limited visibility into stress testing practices"

offline:
  capability: "partial"
  cache_manifest:
    knowledge:
      - source_id: "chaos-eng-book"
        priority: "recommended"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires detailed analysis and potentially destructive testing"
    full:
      included: true
      priority: 2
    production:
      included: true
      priority: 1

closeout_checklist:
  - id: "stress-testing-001"
    item: "Stress testing configurations exist"
    level: "CRITICAL"
    verification: "find . -type f -name '*stress*' 2>/dev/null | head -1 | grep -q . && echo PASS || echo FAIL"
    expected: "PASS"

  - id: "stress-testing-002"
    item: "Graceful degradation mechanisms implemented"
    level: "BLOCKING"
    verification: "grep -r 'circuit.*breaker\\|rate.*limit\\|throttle' --include='*.java' --include='*.js' --include='*.py' 2>/dev/null | grep -q . && echo PASS || echo FAIL"
    expected: "PASS"

  - id: "stress-testing-003"
    item: "Breaking points documented"
    level: "WARNING"
    verification: "manual"
    verification_notes: "Reviewer confirms breaking points are documented in capacity planning docs"
    expected: "Confirmed by reviewer"

governance:
  applicable_to:
    archetypes: ["web-application", "api-service", "microservices"]

  compliance_frameworks:
    - framework: "SOC2"
      controls: ["CC7.1"]

relationships:
  commonly_combined:
    - "testing-quality-assurance.performance-testing.load-testing"
    - "testing-quality-assurance.performance-testing.scalability-testing"
    - "testing-quality-assurance.performance-testing.performance-baseline"
