# ============================================================
# AUDIT: Scalability Testing
# ============================================================
# Evaluates testing practices for system scaling behavior under
# increasing load and resource constraints.
# ============================================================

audit:
  id: "testing-quality-assurance.performance-testing.scalability-testing"
  name: "Scalability Testing"
  version: "1.0.0"
  last_updated: "2026-01-19"
  status: "active"

  category: "testing-quality-assurance"
  category_number: 10
  subcategory: "performance-testing"

  tier: "expert"
  estimated_duration: "5 hours"

  completeness: "complete"
  requires_runtime: true
  destructive: false

execution:
  automatable: "partial"
  severity: "critical"
  scope: "testing"

  default_profiles:
    - "full"
    - "production"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Assesses scalability testing practices to verify system behavior as
    resources scale horizontally or vertically. Reviews testing for linear
    scaling, bottleneck identification, resource utilization efficiency,
    and scaling limits. Evaluates whether scalability tests cover
    realistic growth scenarios.

  why_it_matters: |
    Untested scalability leads to expensive surprises during growth. Systems
    that don't scale linearly waste resources, hit unexpected limits, or
    fail entirely when load increases. Scalability testing enables informed
    capacity planning, cost optimization, and architecture decisions.

  when_to_run:
    - "Before significant expected growth"
    - "Architecture planning phases"
    - "After infrastructure changes"
    - "Annual capacity planning"

prerequisites:
  required_artifacts:
    - type: "scalability-requirements"
      description: "Expected growth projections and scaling requirements"
    - type: "infrastructure-config"
      description: "Infrastructure scaling configurations"

  access_requirements:
    - "Scalable test environment"
    - "Infrastructure provisioning access"
    - "Resource monitoring dashboards"

discovery:
  file_patterns:
    - glob: "**/scalability/**"
      purpose: "Scalability test directories"
    - glob: "**/scale-test*/**"
      purpose: "Scale testing configurations"
    - glob: "**/capacity/**"
      purpose: "Capacity testing files"

  code_patterns:
    - pattern: "scale|scaling|horizontal|vertical"
      type: "keyword"
      scope: "config"
      purpose: "Scaling configuration"
    - pattern: "replicas|instances|shards|partitions"
      type: "keyword"
      scope: "config"
      purpose: "Scale unit definitions"
    - pattern: "autoscal|HPA|VPA"
      type: "keyword"
      scope: "config"
      purpose: "Auto-scaling configuration"

  metrics_queries:
    - system: "Prometheus"
      query: "rate(http_requests_total[5m]) / count(up{job='app'})"
      purpose: "Requests per instance for scaling efficiency"
      threshold: "Should remain stable as instances increase"
    - system: "Prometheus"
      query: "avg(container_cpu_usage_seconds_total)"
      purpose: "CPU utilization per pod"
      threshold: "Should decrease with horizontal scaling"

knowledge_sources:
  guides:
    - id: "k8s-scaling"
      name: "Kubernetes Horizontal Pod Autoscaling"
      url: "https://kubernetes.io/docs/tasks/run-application/horizontal-pod-autoscale/"
      offline_cache: true
    - id: "aws-scaling"
      name: "AWS Auto Scaling Best Practices"
      url: "https://docs.aws.amazon.com/autoscaling/ec2/userguide/auto-scaling-best-practices.html"
      offline_cache: true

  learning_resources:
    - id: "scalability-rules"
      title: "Scalability Rules: Principles for Scaling Web Sites"
      type: "book"
      reference: "Martin L. Abbott, Michael T. Fisher"

tooling:
  infrastructure_tools:
    - tool: "kubectl"
      purpose: "Kubernetes scaling operations"
      command: "kubectl scale deployment app --replicas=10"
    - tool: "terraform"
      purpose: "Infrastructure scaling"
      command: "terraform apply -var instance_count=10"

  monitoring_queries:
    - system: "Prometheus"
      query: "kube_deployment_spec_replicas"
      purpose: "Current replica count"
    - system: "Prometheus"
      query: "sum(rate(http_requests_total[5m])) / sum(kube_deployment_spec_replicas)"
      purpose: "Throughput per replica"

signals:
  critical:
    - id: "SCALE-CRIT-001"
      signal: "No scalability testing performed"
      evidence_pattern: "Absence of scalability tests or scaling scenarios"
      explanation: |
        Without scalability testing, systems may fail unpredictably under growth.
        Scaling behaviors, bottlenecks, and limits remain unknown until they
        cause production incidents.
      remediation: "Implement scalability testing with horizontal and vertical scaling scenarios"

    - id: "SCALE-CRIT-002"
      signal: "System exhibits non-linear scaling degradation"
      evidence_pattern: "Performance degrades faster than load increases"
      explanation: |
        Non-linear degradation indicates architectural bottlenecks like shared
        locks, database contention, or synchronization overhead. These become
        critical blockers to growth.
      remediation: "Identify and resolve scaling bottlenecks through profiling and architecture review"

  high:
    - id: "SCALE-HIGH-001"
      signal: "Scaling limits not documented"
      evidence_pattern: "No documentation of maximum instance counts or resource limits"
      explanation: |
        Unknown limits prevent capacity planning. Teams may over-provision
        (wasting money) or under-provision (risking outages) without
        documented scaling constraints.
      remediation: "Document scaling limits based on testing results"

    - id: "SCALE-HIGH-002"
      signal: "Auto-scaling not tested under load"
      evidence_pattern: "Auto-scaling configured but never verified with load tests"
      explanation: |
        Untested auto-scaling may fail when needed most. Scale-up delays,
        incorrect thresholds, or scaling oscillation can cause outages
        despite having auto-scaling configured.
      remediation: "Test auto-scaling behavior with realistic load patterns"

  medium:
    - id: "SCALE-MED-001"
      signal: "Scaling tests don't include dependent services"
      evidence_pattern: "Isolated scaling tests without service dependencies"
      remediation: "Include dependent services in scaling tests to identify downstream bottlenecks"

    - id: "SCALE-MED-002"
      signal: "No cost analysis included in scalability testing"
      evidence_pattern: "Scaling tests without resource cost evaluation"
      remediation: "Include cost metrics in scaling analysis for informed capacity decisions"

  low:
    - id: "SCALE-LOW-001"
      signal: "Scalability test results not archived"
      remediation: "Archive scaling test results for trend analysis and capacity planning"

  positive:
    - id: "SCALE-POS-001"
      signal: "Comprehensive scalability testing with documented limits"
    - id: "SCALE-POS-002"
      signal: "Linear or better scaling verified under realistic load"

procedure:
  context:
    cognitive_mode: "critical"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Identify scalability testing infrastructure"
      description: |
        Search for scalability tests, scaling configurations, and
        capacity documentation.
      duration_estimate: "30 min"
      commands:
        - purpose: "Find scalability test files"
          command: "find . -type f -name '*scale*' -o -type f -name '*capacity*' 2>/dev/null"
        - purpose: "Check for auto-scaling configurations"
          command: "grep -r 'autoscal\\|HPA\\|targetCPUUtilization' --include='*.yaml' 2>/dev/null"
      expected_findings:
        - "Scalability test definitions"
        - "Auto-scaling configurations"

    - id: "2"
      name: "Review scaling scenarios"
      description: |
        Examine scaling test configurations for horizontal and vertical
        scaling scenarios with realistic growth patterns.
      duration_estimate: "45 min"
      commands:
        - purpose: "Check for replica configurations"
          command: "grep -r 'replicas\\|instances\\|nodes' --include='*.yaml' --include='*.json' 2>/dev/null | head -20"
        - purpose: "Find scaling step definitions"
          command: "grep -r 'scale.*step\\|increment\\|ramp' --include='*.js' --include='*.py' 2>/dev/null"
      expected_findings:
        - "Scaling increment definitions"
        - "Target replica counts"

    - id: "3"
      name: "Verify linear scaling behavior"
      description: |
        Check for evidence that scaling efficiency is measured and
        that performance scales proportionally with resources.
      duration_estimate: "40 min"
      commands:
        - purpose: "Check for per-instance metrics"
          command: "grep -r 'per.*instance\\|per.*replica\\|per.*pod' --include='*.yaml' --include='*.json' 2>/dev/null"
      expected_findings:
        - "Per-instance performance metrics"
        - "Scaling efficiency measurements"

    - id: "4"
      name: "Review scaling limits documentation"
      description: |
        Verify that scaling limits are documented with maximum
        instance counts, resource constraints, and bottleneck analysis.
      duration_estimate: "30 min"
      commands:
        - purpose: "Find capacity documentation"
          command: "find . -type f \\( -name '*capacity*' -o -name '*limits*' \\) 2>/dev/null"
      expected_findings:
        - "Documented scaling limits"
        - "Capacity planning documentation"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"
    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Scaling Behavior Analysis"
        - "Bottleneck Assessment"
        - "Capacity Recommendations"

  confidence_guidance:
    high: "Scaling tests executed, linear behavior verified, limits documented"
    medium: "Configuration reviewed but execution not observed"
    low: "Limited visibility into scalability testing"

offline:
  capability: "partial"
  cache_manifest:
    knowledge:
      - source_id: "k8s-scaling"
        priority: "recommended"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires extensive scaling analysis"
    full:
      included: true
      priority: 2
    production:
      included: true
      priority: 1

closeout_checklist:
  - id: "scalability-testing-001"
    item: "Scalability testing infrastructure exists"
    level: "CRITICAL"
    verification: "find . -type f -name '*scale*' 2>/dev/null | head -1 | grep -q . && echo PASS || echo FAIL"
    expected: "PASS"

  - id: "scalability-testing-002"
    item: "Auto-scaling configuration verified"
    level: "BLOCKING"
    verification: "grep -r 'autoscal\\|HPA' --include='*.yaml' 2>/dev/null | grep -q . && echo PASS || echo FAIL"
    expected: "PASS"

  - id: "scalability-testing-003"
    item: "Scaling limits documented"
    level: "WARNING"
    verification: "manual"
    verification_notes: "Reviewer confirms scaling limits are documented in capacity docs"
    expected: "Confirmed by reviewer"

governance:
  applicable_to:
    archetypes: ["web-application", "api-service", "microservices"]

  compliance_frameworks:
    - framework: "SOC2"
      controls: ["CC7.1", "CC7.2"]

relationships:
  commonly_combined:
    - "testing-quality-assurance.performance-testing.load-testing"
    - "testing-quality-assurance.performance-testing.stress-testing"
    - "testing-quality-assurance.performance-testing.performance-baseline"
