# ============================================================
# AUDIT: Unit Test Coverage
# ============================================================
# Evaluates the extent and quality of unit test coverage
# across the codebase.
# ============================================================

audit:
  id: "testing-quality-assurance.unit-testing.unit-test-coverage"
  name: "Unit Test Coverage"
  version: "1.0.0"
  last_updated: "2026-01-19"
  status: "active"

  category: "testing-quality-assurance"
  category_number: 10
  subcategory: "unit-testing"

  tier: "expert"
  estimated_duration: "2 hours"

  completeness: "complete"
  requires_runtime: false
  destructive: false

execution:
  automatable: "yes"
  severity: "high"
  scope: "testing"

  default_profiles:
    - "full"
    - "quality"
    - "quick"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Measures and evaluates unit test coverage including line coverage,
    branch coverage, function coverage, and statement coverage. Analyzes
    coverage distribution across modules and identifies areas with
    insufficient test coverage.

  why_it_matters: |
    Unit tests are the foundation of the testing pyramid. Insufficient
    unit test coverage means bugs are caught later (at integration or E2E
    level) where they're more expensive to debug and fix. Good unit test
    coverage provides fast feedback and enables confident refactoring.

  when_to_run:
    - "CI/CD pipeline quality gates"
    - "Code review verification"
    - "Before major refactoring"
    - "Sprint retrospectives"

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Source code with unit tests"
    - type: "coverage_tools"
      description: "Coverage tooling configured (jest, nyc, coverage.py, etc.)"

  access_requirements:
    - "Source code repository access"
    - "Ability to run test suite"

discovery:
  file_patterns:
    - glob: "**/*.test.{js,ts,jsx,tsx}"
      purpose: "JavaScript/TypeScript unit tests"
    - glob: "**/*.spec.{js,ts,jsx,tsx}"
      purpose: "Spec-style unit tests"
    - glob: "**/test_*.py"
      purpose: "Python unit tests"
    - glob: "**/*_test.go"
      purpose: "Go unit tests"
    - glob: "**/*Test.java"
      purpose: "Java unit tests"
    - glob: "**/coverage/**"
      purpose: "Coverage report directories"

  code_patterns:
    - pattern: "describe\\s*\\(|it\\s*\\(|test\\s*\\("
      type: "regex"
      scope: "source"
      purpose: "Identify Jest/Mocha test blocks"
    - pattern: "def test_|class Test"
      type: "regex"
      scope: "source"
      purpose: "Identify pytest tests"
    - pattern: "@Test|@ParameterizedTest"
      type: "regex"
      scope: "source"
      purpose: "Identify JUnit tests"

knowledge_sources:
  specifications:
    - id: "xunit-patterns"
      name: "xUnit Test Patterns"
      url: "http://xunitpatterns.com/"
      offline_cache: true
      priority: "recommended"

  guides:
    - id: "coverage-guide"
      name: "Code Coverage Best Practices"
      url: "https://testing.googleblog.com/2020/08/code-coverage-best-practices.html"
      offline_cache: true
    - id: "tdd-by-example"
      name: "Kent Beck - Test Driven Development"
      url: "https://www.oreilly.com/library/view/test-driven-development/0321146530/"
      offline_cache: true

  learning_resources:
    - id: "unit-testing"
      title: "Unit Testing Principles, Practices, and Patterns"
      type: "book"
      reference: "ISBN 978-1617296277"

tooling:
  static_analysis:
    - tool: "jest"
      purpose: "JavaScript testing with coverage"
      offline_capable: true
    - tool: "nyc/istanbul"
      purpose: "JavaScript coverage instrumentation"
      offline_capable: true
    - tool: "coverage.py"
      purpose: "Python coverage analysis"
      offline_capable: true
    - tool: "jacoco"
      purpose: "Java coverage analysis"
      offline_capable: true

  scripts:
    - id: "coverage-analyzer"
      language: "bash"
      purpose: "Analyze unit test coverage"
      source: "inline"
      code: |
        #!/bin/bash
        echo "=== Unit Test Coverage Analysis ==="
        if [ -f "coverage/lcov.info" ]; then
          echo "LCOV coverage found"
          head -50 coverage/lcov.info
        elif [ -f "coverage/coverage-summary.json" ]; then
          echo "JSON coverage found"
          cat coverage/coverage-summary.json
        else
          echo "No coverage reports found. Run tests with coverage first."
        fi

signals:
  critical:
    - id: "UNIT-COV-CRIT-001"
      signal: "Unit test coverage below 30%"
      evidence_pattern: "Overall coverage < 30%"
      explanation: |
        Very low coverage indicates most code is untested, creating
        high risk of undetected bugs and unsafe refactoring.
      remediation: "Establish coverage improvement plan focusing on critical paths first"

    - id: "UNIT-COV-CRIT-002"
      signal: "Critical modules have no unit tests"
      evidence_pattern: "Core business logic with 0% coverage"
      explanation: |
        Critical business logic without tests is extremely risky.
        Any change to this code could introduce regressions undetected.
      remediation: "Add unit tests for all critical business logic immediately"

  high:
    - id: "UNIT-COV-HIGH-001"
      signal: "Branch coverage significantly lower than line coverage"
      evidence_pattern: "Branch coverage < line coverage by >20%"
      explanation: |
        Low branch coverage means conditional logic isn't fully tested,
        leaving edge cases and error conditions unverified.
      remediation: "Add tests for conditional branches and edge cases"

    - id: "UNIT-COV-HIGH-002"
      signal: "Coverage declining over recent commits"
      evidence_pattern: "Coverage trend negative over 10+ commits"
      explanation: |
        Declining coverage indicates new code is being added without
        corresponding tests, degrading overall test suite value.
      remediation: "Enforce coverage thresholds in CI to prevent regression"

  medium:
    - id: "UNIT-COV-MED-001"
      signal: "Coverage varies significantly across modules"
      evidence_pattern: "Some modules >80%, others <40%"
      remediation: "Establish minimum per-module coverage requirements"

    - id: "UNIT-COV-MED-002"
      signal: "Utility functions lack coverage"
      evidence_pattern: "Utils/helpers directories with low coverage"
      remediation: "Add tests for utility functions used across the codebase"

  low:
    - id: "UNIT-COV-LOW-001"
      signal: "Generated code included in coverage metrics"
      evidence_pattern: "Auto-generated files counted in coverage"

  positive:
    - id: "UNIT-COV-POS-001"
      signal: "Coverage above 80% with branch coverage included"
      evidence_pattern: "Line coverage >80%, branch coverage >70%"
    - id: "UNIT-COV-POS-002"
      signal: "Coverage trending upward"
      evidence_pattern: "Coverage improved over recent commits"

procedure:
  context:
    cognitive_mode: "evaluative"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Run coverage analysis"
      description: |
        Execute the test suite with coverage enabled to generate
        coverage reports.
      duration_estimate: "30 min"
      commands:
        - purpose: "Run tests with coverage (npm)"
          command: "npm test -- --coverage 2>/dev/null || npx jest --coverage 2>/dev/null"
        - purpose: "Check for existing coverage reports"
          command: "find . -path '*coverage*' \\( -name 'lcov.info' -o -name 'coverage-summary.json' \\) 2>/dev/null | head -10"
      expected_findings:
        - "Coverage report generated"
        - "Overall coverage percentages"

    - id: "2"
      name: "Analyze overall coverage"
      description: |
        Review overall coverage metrics including line, branch,
        function, and statement coverage.
      duration_estimate: "15 min"
      commands:
        - purpose: "Parse coverage summary"
          command: "cat coverage/coverage-summary.json 2>/dev/null || echo 'No summary found'"
      expected_findings:
        - "Line coverage percentage"
        - "Branch coverage percentage"
        - "Function coverage percentage"

    - id: "3"
      name: "Identify coverage gaps"
      description: |
        Find modules and files with lowest coverage to prioritize
        testing improvements.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find files with low coverage"
          command: "grep -r 'statements.*[0-4][0-9]\\.' coverage/lcov-report/*.html 2>/dev/null | head -20"
      expected_findings:
        - "List of low-coverage files"
        - "Coverage distribution across modules"

    - id: "4"
      name: "Assess coverage quality"
      description: |
        Evaluate whether coverage metrics reflect meaningful testing
        or just code execution.
      duration_estimate: "20 min"
      questions:
        - "Are assertions present in tests or just execution?"
        - "Do tests cover error paths?"
        - "Are edge cases tested?"
      expected_findings:
        - "Coverage quality assessment"
        - "Meaningful vs superficial coverage"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "coverage_report"
      format: "table"
      sections:
        - "Overall Coverage Metrics"
        - "Per-Module Coverage"
        - "Coverage Gaps"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Coverage Analysis"
        - "Improvement Recommendations"

  confidence_guidance:
    high: "Coverage measured from actual test execution"
    medium: "Coverage from existing reports, not freshly run"
    low: "Estimated from file patterns only"

offline:
  capability: "partial"

  cache_manifest:
    knowledge:
      - source_id: "coverage-guide"
        priority: "required"

profiles:
  membership:
    quick:
      included: true
      reason: "Quick coverage check provides immediate value"
    full:
      included: true
      priority: 1

closeout_checklist:
  - id: "unit-cov-001"
    item: "Coverage metrics collected"
    level: "CRITICAL"
    verification: "ls coverage/ 2>/dev/null | wc -l"
    expected: "PASS (coverage files exist)"

  - id: "unit-cov-002"
    item: "Coverage thresholds evaluated"
    level: "BLOCKING"
    verification: "manual"
    verification_notes: "Document current coverage levels vs thresholds"
    expected: "Confirmed by reviewer"

  - id: "unit-cov-003"
    item: "Low coverage areas identified"
    level: "WARNING"
    verification: "manual"
    verification_notes: "List files/modules below minimum coverage"
    expected: "Confirmed by reviewer"

governance:
  applicable_to:
    archetypes: ["all"]

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Maintainability", "Testability"]

relationships:
  commonly_combined:
    - "testing-quality-assurance.test-strategy.test-coverage-strategy"
    - "testing-quality-assurance.unit-testing.assertion-quality"
    - "testing-quality-assurance.unit-testing.edge-case-testing"
