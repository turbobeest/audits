audit:
  id: blockchain-distributed-ledger.smart-contract-security.reentrancy-vulnerability
  name: Reentrancy Vulnerability Audit
  version: 1.0.0
  last_updated: '2026-01-22'
  status: active
  category: blockchain-distributed-ledger
  category_number: 41
  subcategory: smart-contract-security
  tier: expert
  estimated_duration: 2-3 hours  # median: 2h
  completeness: complete
  requires_runtime: false
  destructive: false
execution:
  automatable: partial
  severity: critical
  scope: software
  default_profiles:
  - full
  - blockchain
  - security
  blocks_phase: true
  parallelizable: true
description:
  what: |
    This audit evaluates smart contracts for reentrancy vulnerabilities
    that allow attackers to recursively call functions before state
    updates complete. It examines:
    - External call patterns before state changes
    - Checks-Effects-Interactions pattern compliance
    - Reentrancy guard implementation
    - Cross-function reentrancy vectors
    - Read-only reentrancy in view functions
    - Callback function vulnerabilities
  why_it_matters: |
    Reentrancy is one of the most devastating smart contract attacks:
    - The DAO hack lost $60M from reentrancy exploitation
    - External calls can transfer execution to malicious contracts
    - State changes after external calls enable recursive exploitation
    - Cross-function reentrancy bypasses simple guards
    - Reentrancy can drain entire contract balances

    Reentrancy prevention is essential for any contract handling value.
  when_to_run:
  - Smart contract development
  - Pre-deployment audit
  - Code review
  - After external call additions
prerequisites:
  required_artifacts:
  - type: source_code
    description: Smart contract source code
  - type: documentation
    description: Contract interface documentation
  access_requirements:
  - Access to contract source
  - Understanding of contract logic flow
discovery:
  code_patterns:
  - pattern: \.call\{.*value
    type: regex
    scope: source
    purpose: Detect ETH transfers via call
  - pattern: transfer\(|send\(
    type: regex
    scope: source
    purpose: Detect token/ETH transfers
  - pattern: (external|public).*payable
    type: regex
    scope: source
    purpose: Detect payable functions
  file_patterns:
  - glob: '**/*.sol'
    purpose: Solidity contracts
  - glob: '**/contracts/**/*.sol'
    purpose: Contract directory
knowledge_sources:
  specifications:
  - id: swc-107
    name: 'SWC-107: Reentrancy'
    url: https://swcregistry.io/docs/SWC-107
    offline_cache: true
    priority: required
  guides:
  - id: consensys-reentrancy
    name: ConsenSys Reentrancy Best Practices
    url: https://consensys.github.io/smart-contract-best-practices/attacks/reentrancy/
    offline_cache: true
signals:
  critical:
  - id: REENT-CRIT-001
    signal: State changes after external calls
    evidence_indicators:
    - Balance update after ETH transfer
    - State modification after external call
    - Checks-Effects-Interactions violated
    explanation: |
      Modifying state after external calls enables reentrancy attacks.
      The attacker's fallback function can re-enter before state
      reflects the first call, enabling recursive exploitation.
    remediation: |
      - Move all state changes before external calls
      - Follow Checks-Effects-Interactions pattern
      - Implement reentrancy guard modifier
      - Use pull payment pattern
    cwe: CWE-841
  - id: REENT-CRIT-002
    signal: No reentrancy guard on value transfer functions
    evidence_indicators:
    - Payable function without nonReentrant
    - Withdrawal function unprotected
    - Multiple external calls without guard
    explanation: |
      Functions transferring value without reentrancy guards are
      vulnerable to recursive calls. Guards prevent reentry during
      function execution.
    remediation: |
      - Add ReentrancyGuard from OpenZeppelin
      - Apply nonReentrant modifier to vulnerable functions
      - Audit all functions with external calls
      - Test with reentrancy attack contracts
  high:
  - id: REENT-HIGH-001
    signal: Cross-function reentrancy possible
    evidence_indicators:
    - Multiple functions share state
    - Single-function guard insufficient
    - State inconsistent during external call
    explanation: |
      Cross-function reentrancy occurs when attacker reenters via
      a different function that shares state. Simple guards only
      protect individual functions.
    remediation: |
      - Use contract-level reentrancy lock
      - Ensure consistent state before any external call
      - Review all functions sharing state
      - Consider mutex for critical state
  - id: REENT-HIGH-002
    signal: Read-only reentrancy in view functions
    evidence_indicators:
    - View functions read inconsistent state
    - External protocols call view during reentrancy
    - Price/balance queries return stale values
    explanation: |
      View functions may return inconsistent values during reentrancy
      if read before state updates. External protocols relying on
      these views can be exploited.
    remediation: |
      - Update state before external calls even for views
      - Mark functions as vulnerable to read-only reentrancy
      - Warn integrators about state consistency
      - Use reentrancy guards for critical views
  medium:
  - id: REENT-MED-001
    signal: Callback functions not hardened
    evidence_indicators:
    - onERC721Received without protection
    - Callback allows arbitrary execution
    - Receiver hooks exploitable
    explanation: |
      Token callbacks (ERC721, ERC1155) can be exploited for
      reentrancy if the callback allows arbitrary code execution
      during token operations.
    remediation: |
      - Apply reentrancy guards to callbacks
      - Complete state changes before token transfers
      - Validate callback behavior
      - Test with malicious receivers
  low:
  - id: REENT-LOW-001
    signal: Reentrancy tests not comprehensive
    evidence_indicators:
    - Basic reentrancy tests only
    - Cross-function attack not tested
    - Edge cases not covered
    explanation: |
      Incomplete reentrancy testing may miss attack vectors.
      Comprehensive testing should cover all entry points.
    remediation: |
      - Add cross-function reentrancy tests
      - Test with malicious contracts
      - Cover all external call paths
      - Use fuzzing for edge cases
  positive:
  - id: REENT-POS-001
    signal: Robust reentrancy protection
    evidence_indicators:
    - ReentrancyGuard consistently applied
    - Checks-Effects-Interactions followed
    - Comprehensive testing
procedure:
  context:
    cognitive_mode: analytical
    ensemble_role: security-auditor
  steps:
  - id: '1'
    name: Reentrancy Pattern Analysis
    description: |
      Identify all external calls and verify state handling.
    duration_estimate: 45 min
    commands:
    - purpose: Find external calls
      command: |
        grep -rniE "\\.call\\{|transfer\\(|send\\(" \
          --include="*.sol" . 2>/dev/null | head -30
    - purpose: Find reentrancy guards
      command: |
        grep -rniE "(nonReentrant|ReentrancyGuard)" \
          --include="*.sol" . 2>/dev/null | head -20
    expected_findings:
    - External call locations
    - Guard implementation
    - State change ordering
output:
  deliverables:
  - type: finding_list
    format: structured
  - type: summary
    format: prose
    sections:
    - Reentrancy Analysis
    - Attack Vectors
    - Recommendations
profiles:
  membership:
    quick:
      included: false
    full:
      included: true
      priority: 1
    blockchain:
      included: true
      priority: 1
closeout_checklist:
- id: reent-001
  item: All external calls audited for reentrancy
  level: CRITICAL
  verification: manual
  verification_notes: Verify each external call has proper protection
  expected: Confirmed by reviewer
- id: reent-002
  item: Checks-Effects-Interactions followed
  level: BLOCKING
  verification: manual
  verification_notes: Verify state changes before external calls
  expected: Confirmed by reviewer
- id: reent-003
  item: Reentrancy guards implemented
  level: WARNING
  verification: |
    grep -rniE "nonReentrant|ReentrancyGuard" \
      --include="*.sol" . 2>/dev/null | \
      wc -l | xargs -I{} test {} -gt 0 && echo "PASS" || echo "FAIL"
  expected: PASS
governance:
  applicable_to:
    archetypes:
    - blockchain
    - defi
    - nft-platform
    - financial
relationships:
  commonly_combined:
  - blockchain.smart-contract-security.access-control
  - blockchain.smart-contract-security.flash-loan-attack
  - blockchain.smart-contract-quality.error-handling

# Glossary of domain-specific terms:
glossary:
  "timelock": "Governance mechanism requiring delay between proposal and execution"
  "reentrancy": "Vulnerability where external call allows re-entering function before completion"
  "oracle": "External data feed providing off-chain information to smart contracts"
