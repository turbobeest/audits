# ============================================================
# AUDIT: Plugin Architecture Assessment
# ============================================================
# Evaluates the design and implementation of plugin systems
# for loading and managing optional, modular functionality.
# ============================================================

audit:
  id: "architecture-design.extensibility-evolution.plugin-architecture"
  name: "Plugin Architecture Assessment"
  version: "1.0.0"
  last_updated: "2026-01-18"
  status: "active"

  category: "architecture-design"
  category_number: 7
  subcategory: "extensibility-evolution"

  tier: "expert"
  estimated_duration: "2-4 hours"  # median: 3h

  completeness: "complete"
  requires_runtime: false
  destructive: false

execution:
  automatable: "partial"
  severity: "high"
  scope: "codebase"

  default_profiles:
    - "full"
    - "architecture"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    This audit evaluates plugin architecture design - systems that allow
    loading optional, modular functionality at runtime. It assesses
    plugin discovery, isolation, versioning, dependency management,
    and security boundaries.

  why_it_matters: |
    Well-designed plugin architecture enables:
    - Third-party extensions without core code changes
    - Optional features that don't bloat core
    - Independent plugin development and deployment
    - Customer customization without forks
    Poor plugin design creates security risks and fragile systems.

  when_to_run:
    - "When building extensible platforms"
    - "During plugin system design"
    - "When experiencing plugin-related issues"
    - "Before opening system to third-party plugins"

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Core system and plugin source code"
    - type: "plugin_documentation"
      description: "Plugin development documentation"

  access_requirements:
    - "Read access to source code"
    - "Understanding of plugin requirements"

discovery:
  code_patterns:
    - pattern: "PluginManager|PluginLoader|PluginRegistry"
      type: "regex"
      scope: "source"
      purpose: "Find plugin management code"

    - pattern: "loadPlugin|installPlugin|activatePlugin"
      type: "regex"
      scope: "source"
      purpose: "Find plugin lifecycle code"

    - pattern: "ClassLoader|URLClassLoader|ModuleLayer"
      type: "regex"
      scope: "source"
      purpose: "Find class loading for plugins"

  file_patterns:
    - glob: "**/plugins/**"
      purpose: "Plugin directories"
    - glob: "**/*plugin*.{json,yaml,xml}"
      purpose: "Plugin manifests"

knowledge_sources:
  specifications:
    - id: "osgi"
      name: "OSGi Specification"
      url: "https://www.osgi.org/developer/specifications/"
      offline_cache: true
      priority: "recommended"

  guides:
    - id: "plugin-systems"
      name: "Designing Plugin Systems"
      url: "https://eli.thegreenplace.net/2012/08/07/fundamental-concepts-of-plugin-infrastructures"
      offline_cache: true

    - id: "refactoring-fowler"
      name: "Refactoring Catalog"
      url: "https://refactoring.com/catalog/"
      offline_cache: true

    - id: "clean-architecture"
      name: "Clean Architecture"
      url: "https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"
      offline_cache: true

  learning_resources:
    - id: "microkernel"
      title: "Microkernel Architecture Pattern"
      type: "book"
      reference: "Software Architecture Patterns - Richards"

tooling:
  static_analysis:
    - tool: "OWASP Dependency Check"
      purpose: "Check plugin dependencies for vulnerabilities"
      offline_capable: true

  scripts:
    - id: "plugin-analyzer"
      language: "bash"
      purpose: "Analyze plugin architecture"
      source: "inline"
      code: |
        #!/bin/bash
        echo "=== Plugin Management Classes ==="
        grep -rn "PluginManager\|PluginLoader\|PluginRegistry" --include="*.java" | head -20

        echo "=== Plugin Manifests ==="
        find . -name "*plugin*.json" -o -name "*plugin*.yaml" -o -name "plugin.xml" | head -15

        echo "=== ClassLoader Usage ==="
        grep -rn "ClassLoader\|URLClassLoader\|loadClass" --include="*.java" | head -20

signals:
  critical:
    - id: "PLUGIN-CRIT-001"
      signal: "Plugins share classloader with core"
      evidence_pattern: "Plugins loaded in same classloader as main application"
      explanation: |
        Shared classloaders mean plugins can access and modify core internals,
        and conflicting plugin dependencies create classpath hell.
      remediation: "Use isolated classloaders or module system for each plugin"

    - id: "PLUGIN-CRIT-002"
      signal: "No security boundary for plugins"
      evidence_pattern: "Plugins can access file system, network, reflection without limits"
      explanation: |
        Unrestricted plugins can be malicious or accidentally destructive.
        Third-party plugins especially need sandboxing.
      remediation: "Implement SecurityManager or permission system for plugins"

  high:
    - id: "PLUGIN-HIGH-001"
      signal: "No plugin versioning or compatibility checking"
      evidence_pattern: "Plugins loaded without checking API version compatibility"
      explanation: |
        Without version checking, plugins built for old API versions can
        crash or behave incorrectly with new core versions.
      remediation: "Add API version to plugin manifest; check at load time"

    - id: "PLUGIN-HIGH-002"
      signal: "Plugin dependencies not managed"
      evidence_pattern: "Plugins can have conflicting versions of same library"
      explanation: |
        Without dependency isolation, plugin A's library v1 can conflict
        with plugin B's library v2, causing runtime errors.
      remediation: "Use isolated dependency management per plugin"

  medium:
    - id: "PLUGIN-MED-001"
      signal: "No plugin unloading support"
      evidence_pattern: "Plugins can be loaded but not cleanly unloaded"
      remediation: "Implement full plugin lifecycle including unload"

    - id: "PLUGIN-MED-002"
      signal: "Plugin discovery requires restart"
      evidence_pattern: "New plugins only detected on application restart"
      remediation: "Add hot-reload capability for development"

  low:
    - id: "PLUGIN-LOW-001"
      signal: "Plugin SDK not documented"
      remediation: "Document plugin development with examples"

  positive:
    - id: "PLUGIN-POS-001"
      signal: "Isolated classloaders per plugin"
    - id: "PLUGIN-POS-002"
      signal: "Plugin sandbox with permissions"
    - id: "PLUGIN-POS-003"
      signal: "Version compatibility checking"

procedure:
  context:
    cognitive_mode: "evaluative"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Map plugin infrastructure"
      description: |
        Identify plugin management components and their responsibilities.
      duration_estimate: "30 min"
      commands:
        - purpose: "Find plugin management"
          command: "grep -rn 'PluginManager\\|PluginLoader\\|PluginService' --include='*.java' | head -30"
        - purpose: "Find plugin interfaces"
          command: "grep -rn 'interface.*Plugin' --include='*.java' | head -20"
      expected_findings:
        - "Plugin infrastructure components"
        - "Plugin contract interfaces"

    - id: "2"
      name: "Assess isolation mechanisms"
      description: |
        Evaluate how plugins are isolated from core and each other.
      duration_estimate: "30 min"
      commands:
        - purpose: "Find classloader usage"
          command: "grep -rn 'ClassLoader\\|URLClassLoader\\|ModuleLayer' --include='*.java' | head -30"
        - purpose: "Find security manager usage"
          command: "grep -rn 'SecurityManager\\|Permission\\|sandbox' --include='*.java' | head -20"
      expected_findings:
        - "Isolation mechanisms"
        - "Security boundaries"

    - id: "3"
      name: "Check version management"
      description: |
        Verify plugin versioning and compatibility checking.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find plugin manifests"
          command: "find . -name '*plugin*.json' -o -name '*plugin*.yaml' | xargs cat 2>/dev/null | head -40"
        - purpose: "Find version checking"
          command: "grep -rn 'apiVersion\\|minVersion\\|compatible' --include='*.java' | head -20"
      expected_findings:
        - "Version metadata"
        - "Compatibility checking"

    - id: "4"
      name: "Evaluate lifecycle management"
      description: |
        Check plugin lifecycle from discovery to unload.
      duration_estimate: "25 min"
      commands:
        - purpose: "Find lifecycle methods"
          command: "grep -rn 'loadPlugin\\|unloadPlugin\\|enablePlugin\\|disablePlugin' --include='*.java' | head -25"
        - purpose: "Find lifecycle hooks"
          command: "grep -rn 'onLoad\\|onUnload\\|onEnable\\|onDisable' --include='*.java' | head -20"
      expected_findings:
        - "Lifecycle stages"
        - "Hook implementations"

    - id: "5"
      name: "Review dependency handling"
      description: |
        Assess how plugin dependencies are managed.
      duration_estimate: "25 min"
      commands:
        - purpose: "Find dependency resolution"
          command: "grep -rn 'dependency\\|require\\|import' $(find . -name '*plugin*.json' -o -name '*plugin*.yaml') 2>/dev/null | head -20"
      expected_findings:
        - "Dependency declaration"
        - "Resolution strategy"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "plugin_architecture_report"
      format: "prose"
      sections:
        - "Architecture Overview"
        - "Isolation Assessment"
        - "Lifecycle Analysis"
        - "Security Review"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Plugin System Assessment"
        - "Recommendations"

  confidence_guidance:
    high: "Clear architectural issue identified"
    medium: "Pattern suggests improvement needed"
    low: "Minor enhancement opportunity"

offline:
  capability: "full"
  cache_manifest:
    knowledge:
      - source_id: "osgi"
        priority: "recommended"
      - source_id: "plugin-systems"
        priority: "required"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires comprehensive architecture review"
    full:
      included: true
      priority: 2
    architecture:
      included: true
      priority: 2

closeout_checklist:
  - id: "plugin-001"
    item: "Plugins isolated in separate classloaders"
    level: "CRITICAL"
    verification: "manual"
    verification_notes: "Each plugin has own classloader or module"
    expected: "Confirmed or documented exception"

  - id: "plugin-002"
    item: "Security boundaries in place"
    level: "CRITICAL"
    verification: "manual"
    verification_notes: "Plugins sandboxed with limited permissions"
    expected: "Confirmed for third-party plugins"

  - id: "plugin-003"
    item: "Version compatibility checked at load time"
    level: "BLOCKING"
    verification: "manual"
    verification_notes: "API version validated before plugin activation"
    expected: "Confirmed by reviewer"

  - id: "plugin-004"
    item: "Plugin SDK documented"
    level: "WARNING"
    verification: "manual"
    verification_notes: "Documentation exists for plugin development"
    expected: "Confirmed by reviewer"

governance:
  applicable_to:
    archetypes: ["framework", "platform"]

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Security", "Modularity"]

relationships:
  commonly_combined:
    - "architecture-design.extensibility-evolution.extension-point"
    - "architecture-design.design-principles.open-closed-principle"
    - "architecture-design.coupling.interface-coupling"
