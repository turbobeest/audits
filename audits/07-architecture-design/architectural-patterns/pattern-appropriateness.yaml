# ============================================================
# AUDIT: Pattern Appropriateness Analysis
# ============================================================
# Evaluates whether chosen design and architectural patterns
# are appropriate for the problem context.
# ============================================================

audit:
  id: "architecture-design.architectural-patterns.pattern-appropriateness"
  name: "Pattern Appropriateness Analysis"
  version: "1.0.0"
  last_updated: "2026-01-18"
  status: "active"

  category: "architecture-design"
  category_number: 7
  subcategory: "architectural-patterns"

  tier: "expert"
  estimated_duration: "3-4 hours"  # median: 3h

  completeness: "complete"
  requires_runtime: false
  destructive: false

execution:
  automatable: "partial"
  severity: "high"
  scope: "architecture"

  default_profiles:
    - "full"
    - "architecture"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    This audit evaluates whether the design and architectural patterns
    used in the codebase are appropriate for the problems they solve.
    It identifies over-engineering (complex patterns for simple problems),
    under-engineering (ad-hoc solutions where patterns would help), and
    misapplied patterns that don't fit the context.

  why_it_matters: |
    Inappropriate patterns cause:
    - Over-engineering: Unnecessary complexity and maintenance burden
    - Under-engineering: Repeated ad-hoc solutions and inconsistency
    - Pattern misuse: Code that's hard to understand and maintain
    - Wrong tool for job: Fighting the pattern instead of leveraging it
    Appropriate patterns simplify design and enable team communication.

  when_to_run:
    - "During architecture reviews"
    - "When complexity seems disproportionate to problem"
    - "When team has difficulty understanding design"
    - "Before major refactoring efforts"

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Complete source code"
    - type: "architecture_documentation"
      description: "Documentation of architectural decisions (ADRs)"

  access_requirements:
    - "Read access to source code"
    - "Understanding of system requirements"

discovery:
  code_patterns:
    - pattern: "Factory|Strategy|Observer|Singleton|Builder|Decorator"
      type: "keyword"
      scope: "source"
      purpose: "Identify GoF pattern usage"

    - pattern: "EventBus|Mediator|Command|Repository|UnitOfWork"
      type: "keyword"
      scope: "source"
      purpose: "Identify enterprise/architectural patterns"

    - pattern: "CQRS|EventSourcing|Saga|DomainEvent"
      type: "keyword"
      scope: "source"
      purpose: "Identify advanced patterns"

  file_patterns:
    - glob: "**/*Factory*.{java,ts,py}"
      purpose: "Factory pattern usage"
    - glob: "**/*Strategy*.{java,ts,py}"
      purpose: "Strategy pattern usage"
    - glob: "**/*Observer*.{java,ts,py}"
      purpose: "Observer pattern usage"
    - glob: "**/adr/**"
      purpose: "Architecture Decision Records"

knowledge_sources:
  specifications:
    - id: "gof-patterns"
      name: "Design Patterns: Elements of Reusable Object-Oriented Software"
      url: "https://en.wikipedia.org/wiki/Design_Patterns"
      offline_cache: true
      priority: "required"

  guides:
    - id: "poeaa"
      name: "Patterns of Enterprise Application Architecture"
      url: "https://martinfowler.com/eaaCatalog/"
      offline_cache: true

    - id: "ddd-patterns"
      name: "Domain-Driven Design Patterns"
      url: "https://www.domainlanguage.com/ddd/"
      offline_cache: true

    - id: "design-patterns-gof"
      name: "Design Patterns - GoF"
      url: "https://refactoring.guru/design-patterns"
      offline_cache: true

    - id: "building-microservices"
      name: "Building Microservices"
      url: "https://samnewman.io/books/building_microservices_2nd_edition/"
      offline_cache: true

  learning_resources:
    - id: "refactoring-to-patterns"
      title: "Refactoring to Patterns"
      type: "book"
      reference: "Joshua Kerievsky"

    - id: "head-first-design-patterns"
      title: "Head First Design Patterns"
      type: "book"
      reference: "Freeman & Robson"

tooling:
  static_analysis:
    - tool: "Structure101"
      purpose: "Visualize patterns and dependencies"
      offline_capable: true

    - tool: "SonarQube"
      purpose: "Detect pattern-related code smells"
      offline_capable: false

  scripts:
    - id: "pattern-inventory"
      language: "bash"
      purpose: "Inventory pattern usage"
      source: "inline"
      code: |
        #!/bin/bash
        echo "=== GoF Pattern Usage ==="
        for pattern in Factory Strategy Observer Singleton Builder Decorator Command Adapter; do
          count=$(find . \( find . -name "*.java" -o -name "*.ts" \) | xargs grep -l "$pattern" 2>/dev/null | wc -l)
          echo "$pattern: $count files"
        done

        echo "=== Enterprise Pattern Usage ==="
        for pattern in Repository UnitOfWork EventBus Mediator Saga; do
          count=$(find . \( find . -name "*.java" -o -name "*.ts" \) | xargs grep -l "$pattern" 2>/dev/null | wc -l)
          echo "$pattern: $count files"
        done

signals:
  critical:
    - id: "PATTERN-CRIT-001"
      signal: "CQRS/Event Sourcing for simple CRUD application"
      evidence_pattern: "Event sourcing infrastructure for basic data management"
      explanation: |
        Advanced patterns like CQRS and Event Sourcing add significant
        complexity. For simple CRUD applications, they're over-engineering
        that creates maintenance burden without proportional benefit.
      remediation: "Simplify to standard repository pattern; document if justified"

    - id: "PATTERN-CRIT-002"
      signal: "Multiple competing patterns for same concern"
      evidence_pattern: "Both Factory and Builder for same object creation; Service Locator and DI"
      explanation: |
        Using multiple patterns for the same concern creates confusion
        and inconsistency. Developers don't know which approach to follow.
      remediation: "Standardize on one pattern per concern; document in ADR"

  high:
    - id: "PATTERN-HIGH-001"
      signal: "Singleton for stateful services"
      evidence_pattern: "Singleton that holds mutable state"
      explanation: |
        Singletons with mutable state create hidden global state, testing
        difficulty, and concurrency issues. It's often misused.
      remediation: "Use dependency injection instead; make state explicit"

    - id: "PATTERN-HIGH-002"
      signal: "Observer pattern without proper cleanup"
      evidence_pattern: "addEventListener without removeEventListener"
      explanation: |
        Observer pattern without proper subscription cleanup leads to
        memory leaks and unexpected behavior from zombie listeners.
      remediation: "Implement proper unsubscription; use weak references where appropriate"

  medium:
    - id: "PATTERN-MED-001"
      signal: "Factory method where constructor suffices"
      evidence_pattern: "Factory that just calls new with same parameters"
      remediation: "Remove unnecessary indirection; use factory only when needed"

    - id: "PATTERN-MED-002"
      signal: "Decorator chains too deep"
      evidence_pattern: "More than 4 levels of decorator wrapping"
      remediation: "Consider if all decorators are needed; review composition"

  low:
    - id: "PATTERN-LOW-001"
      signal: "Pattern usage without documentation"
      remediation: "Document pattern intent and usage in code comments"

  positive:
    - id: "PATTERN-POS-001"
      signal: "Patterns documented in ADRs with rationale"
    - id: "PATTERN-POS-002"
      signal: "Pattern complexity matches problem complexity"
    - id: "PATTERN-POS-003"
      signal: "Consistent pattern usage across codebase"

procedure:
  context:
    cognitive_mode: "evaluative"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Inventory pattern usage"
      description: |
        Catalog all design and architectural patterns in use
        throughout the codebase.
      duration_estimate: "35 min"
      commands:
        - purpose: "Find pattern classes"
          command: "find . -name '*Factory*' -o -name '*Strategy*' -o -name '*Observer*' -o -name '*Builder*' -o -name '*Decorator*' | grep -E '\\.(java|ts|py)$' | head -40"
        - purpose: "Find pattern keywords"
          command: "grep -rn 'pattern\\|Pattern\\|implements.*Strategy\\|implements.*Observer' --include='*.java' | head -30"
      expected_findings:
        - "Pattern inventory"
        - "Usage frequency"

    - id: "2"
      name: "Review Architecture Decision Records"
      description: |
        Check for ADRs documenting pattern choices and their
        rationale.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find ADRs"
          command: "find . -path '*adr*' -name '*.md' -o -path '*decisions*' -name '*.md' | head -20"
        - purpose: "Find pattern documentation"
          command: "grep -rn 'pattern\\|architecture' $(find . -name 'README.md' -o -name 'ARCHITECTURE.md') 2>/dev/null | head -20"
      expected_findings:
        - "Documented decisions"
        - "Pattern rationale"

    - id: "3"
      name: "Assess pattern-problem fit"
      description: |
        For each pattern, evaluate whether it's appropriate for
        the problem it solves.
      duration_estimate: "45 min"
      questions:
        - "What problem does this pattern solve?"
        - "Is the problem complex enough to warrant this pattern?"
        - "Are simpler alternatives available?"
      expected_findings:
        - "Pattern-problem fit assessment"
        - "Over-engineering instances"

    - id: "4"
      name: "Identify missing patterns"
      description: |
        Look for ad-hoc solutions that could benefit from
        established patterns.
      duration_estimate: "30 min"
      commands:
        - purpose: "Find ad-hoc factory logic"
          command: "grep -rn 'if.*type.*new\\|switch.*case.*new' --include='*.java' | head -20"
        - purpose: "Find repeated conditionals"
          command: "grep -rn 'if.*instanceof.*else if.*instanceof' --include='*.java' | head -20"
      expected_findings:
        - "Pattern opportunities"
        - "Repeated ad-hoc solutions"

    - id: "5"
      name: "Check pattern consistency"
      description: |
        Verify that similar problems are solved with consistent
        patterns across the codebase.
      duration_estimate: "30 min"
      questions:
        - "Are similar problems solved the same way?"
        - "Is there a clear convention for pattern application?"
      expected_findings:
        - "Consistency assessment"
        - "Standardization opportunities"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "pattern_catalog"
      format: "tabular"
      sections:
        - "Pattern Name"
        - "Usage Count"
        - "Problem Solved"
        - "Appropriateness"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Pattern Inventory"
        - "Appropriateness Analysis"
        - "Recommendations"

  confidence_guidance:
    high: "Clear pattern misuse identified"
    medium: "Potential over/under-engineering"
    low: "Pattern choice debatable"

offline:
  capability: "full"
  cache_manifest:
    knowledge:
      - source_id: "gof-patterns"
        priority: "required"
      - source_id: "poeaa"
        priority: "required"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires comprehensive pattern analysis"
    full:
      included: true
      priority: 2
    architecture:
      included: true
      priority: 1

closeout_checklist:
  - id: "pattern-001"
    item: "Pattern inventory documented"
    level: "CRITICAL"
    verification: "manual"
    verification_notes: "All major patterns cataloged with usage"
    expected: "Confirmed by reviewer"

  - id: "pattern-002"
    item: "No over-engineering with complex patterns"
    level: "CRITICAL"
    verification: "manual"
    verification_notes: "Pattern complexity matches problem complexity"
    expected: "Confirmed by reviewer"

  - id: "pattern-003"
    item: "Pattern choices documented in ADRs"
    level: "BLOCKING"
    verification: "find . -path '*adr*' -name '*.md' | wc -l"
    expected: ">0 for non-trivial projects"

  - id: "pattern-004"
    item: "Consistent pattern usage across codebase"
    level: "WARNING"
    verification: "manual"
    verification_notes: "Similar problems solved similarly"
    expected: "Confirmed by reviewer"

governance:
  applicable_to:
    archetypes: ["all"]

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Maintainability", "Understandability"]

relationships:
  commonly_combined:
    - "architecture-design.architectural-patterns.pattern-implementation-correctness"
    - "architecture-design.architectural-patterns.anti-pattern-detection"
    - "architecture-design.design-principles.single-responsibility"
