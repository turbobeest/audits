# ============================================================
# AUDIT: Pattern Implementation Correctness
# ============================================================
# Verifies that design patterns are implemented correctly,
# following their intended structure and behavior.
# ============================================================

audit:
  id: "architecture-design.architectural-patterns.pattern-implementation-correctness"
  name: "Pattern Implementation Correctness"
  version: "1.0.0"
  last_updated: "2026-01-18"
  status: "active"

  category: "architecture-design"
  category_number: 7
  subcategory: "architectural-patterns"

  tier: "expert"
  estimated_duration: "2-4 hours"  # median: 3h

  completeness: "complete"
  requires_runtime: false
  destructive: false

execution:
  automatable: "partial"
  severity: "high"
  scope: "codebase"

  default_profiles:
    - "full"
    - "architecture"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    This audit verifies that design patterns are implemented correctly
    according to their intended structure and semantics. It identifies
    broken patterns - implementations that use pattern names but violate
    pattern contracts, creating confusing and unmaintainable code.

  why_it_matters: |
    Incorrect pattern implementations cause:
    - Misleading code - developers expect pattern behavior but don't get it
    - Lost benefits - pattern advantages not realized
    - Extra complexity without reward
    - Team confusion and communication breakdown
    - Maintenance difficulty when pattern intent is unclear

  when_to_run:
    - "During code reviews of pattern implementations"
    - "When patterns don't seem to be working as expected"
    - "During architecture quality assessments"
    - "When onboarding developers report confusion"

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Complete source code"

  access_requirements:
    - "Read access to source code"

discovery:
  code_patterns:
    - pattern: "class\\s+\\w+Factory|class\\s+\\w+Builder"
      type: "regex"
      scope: "source"
      purpose: "Find creational pattern implementations"

    - pattern: "class\\s+\\w+Strategy|implements\\s+\\w+Strategy"
      type: "regex"
      scope: "source"
      purpose: "Find strategy pattern implementations"

    - pattern: "class\\s+\\w+Singleton|getInstance\\(\\)"
      type: "regex"
      scope: "source"
      purpose: "Find singleton implementations"

  file_patterns:
    - glob: "**/*Factory*.{java,ts,py}"
      purpose: "Factory pattern files"
    - glob: "**/*Builder*.{java,ts,py}"
      purpose: "Builder pattern files"
    - glob: "**/*Singleton*.{java,ts,py}"
      purpose: "Singleton pattern files"

knowledge_sources:
  specifications:
    - id: "gof-patterns"
      name: "Design Patterns: Elements of Reusable Object-Oriented Software"
      url: "https://en.wikipedia.org/wiki/Design_Patterns"
      offline_cache: true
      priority: "required"

  guides:
    - id: "pattern-catalog"
      name: "Refactoring.Guru Pattern Catalog"
      url: "https://refactoring.guru/design-patterns"
      offline_cache: true

    - id: "design-patterns-gof"
      name: "Design Patterns - GoF"
      url: "https://refactoring.guru/design-patterns"
      offline_cache: true

    - id: "building-microservices"
      name: "Building Microservices"
      url: "https://samnewman.io/books/building_microservices_2nd_edition/"
      offline_cache: true

  learning_resources:
    - id: "head-first-patterns"
      title: "Head First Design Patterns"
      type: "book"
      reference: "Freeman & Robson"

tooling:
  static_analysis:
    - tool: "SonarQube"
      purpose: "Detect pattern implementation issues"
      offline_capable: false

    - tool: "SpotBugs"
      purpose: "Find singleton implementation problems"
      offline_capable: true

  scripts:
    - id: "pattern-checker"
      language: "bash"
      purpose: "Verify pattern implementation basics"
      source: "inline"
      code: |
        #!/bin/bash
        echo "=== Singleton Checks ==="
        grep -rn "getInstance" --include="*.java" -A3 | head -30

        echo "=== Factory Method Returns ==="
        grep -rn "Factory.*return new" --include="*.java" | head -20

        echo "=== Builder Build Methods ==="
        grep -rn "build()" --include="*.java" -B2 | head -30

signals:
  critical:
    - id: "IMPL-CRIT-001"
      signal: "Singleton with public constructor"
      evidence_pattern: "Singleton class has public constructor alongside getInstance()"
      explanation: |
        A singleton with a public constructor defeats its purpose - multiple
        instances can be created. The pattern's invariant is broken.
      remediation: "Make constructor private; ensure single instantiation path"

    - id: "IMPL-CRIT-002"
      signal: "Factory returning null instead of throwing"
      evidence_pattern: "Factory returns null for unknown type instead of exception"
      explanation: |
        Factories that return null for unknown types push error handling
        to callers and can cause NullPointerExceptions far from the source.
      remediation: "Throw exception for unknown type; use Optional if null is valid"

  high:
    - id: "IMPL-HIGH-001"
      signal: "Builder without fluent interface"
      evidence_pattern: "Builder methods return void instead of this"
      explanation: |
        Builders should return this to enable method chaining. Without
        fluent interface, the builder loses its ergonomic advantage.
      remediation: "Return this from all setter methods"

    - id: "IMPL-HIGH-002"
      signal: "Observer without unsubscribe mechanism"
      evidence_pattern: "Observable has addObserver but no removeObserver"
      explanation: |
        Observers that can't unsubscribe create memory leaks and zombie
        notifications. The pattern requires proper lifecycle management.
      remediation: "Implement removeObserver; consider weak references"

    - id: "IMPL-HIGH-003"
      signal: "Strategy without common interface"
      evidence_pattern: "Strategies implement different interfaces"
      explanation: |
        Strategies must share a common interface to be interchangeable.
        Different interfaces prevent polymorphic usage.
      remediation: "Extract common interface for all strategies"

  medium:
    - id: "IMPL-MED-001"
      signal: "Singleton with lazy initialization race condition"
      evidence_pattern: "Double-checked locking without volatile"
      remediation: "Use volatile keyword or static holder pattern"

    - id: "IMPL-MED-002"
      signal: "Command without undo support where needed"
      evidence_pattern: "Command pattern without unexecute method"
      remediation: "Add undo if operations should be reversible"

  low:
    - id: "IMPL-LOW-001"
      signal: "Pattern implementation differs from canonical form"
      remediation: "Document deviations and their rationale"

  positive:
    - id: "IMPL-POS-001"
      signal: "Pattern implementations follow canonical structure"
    - id: "IMPL-POS-002"
      signal: "Thread-safe singleton implementation"

procedure:
  context:
    cognitive_mode: "critical"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Audit Singleton implementations"
      description: |
        Verify singleton patterns have private constructor, proper
        initialization, and thread safety.
      duration_estimate: "25 min"
      commands:
        - purpose: "Find singletons"
          command: "grep -rn 'getInstance\\|INSTANCE' --include='*.java' | head -30"
        - purpose: "Check constructor visibility"
          command: "find . -name '*.java' -exec grep -l 'getInstance' {} \\; | xargs grep 'public.*constructor\\|public [A-Z].*(' 2>/dev/null | head -20"
      expected_findings:
        - "Singleton implementations"
        - "Constructor visibility issues"

    - id: "2"
      name: "Audit Factory implementations"
      description: |
        Verify factories properly encapsulate creation, return
        correct types, and handle errors.
      duration_estimate: "25 min"
      commands:
        - purpose: "Find factory classes"
          command: "find . -name '*Factory*.java' | head -20"
        - purpose: "Check factory return types"
          command: "grep -rn 'return null' --include='*Factory*.java' | head -20"
      expected_findings:
        - "Factory implementations"
        - "Null return patterns"

    - id: "3"
      name: "Audit Builder implementations"
      description: |
        Verify builders use fluent interface, have proper build
        method, and validate required fields.
      duration_estimate: "25 min"
      commands:
        - purpose: "Find builders"
          command: "find . -name '*Builder*.java' | head -20"
        - purpose: "Check fluent interface"
          command: "grep -rn 'void set\\|void with' --include='*Builder*.java' | head -20"
      expected_findings:
        - "Builder implementations"
        - "Non-fluent method issues"

    - id: "4"
      name: "Audit Observer implementations"
      description: |
        Verify observers have proper subscription/unsubscription
        and prevent memory leaks.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find observer patterns"
          command: "grep -rn 'addObserver\\|addEventListener\\|subscribe' --include='*.java' --include='*.ts' | head -30"
        - purpose: "Find unsubscribe"
          command: "grep -rn 'removeObserver\\|removeEventListener\\|unsubscribe' --include='*.java' --include='*.ts' | head -30"
      expected_findings:
        - "Observer registrations"
        - "Missing unsubscription"

    - id: "5"
      name: "Audit Strategy implementations"
      description: |
        Verify strategies share common interface and are
        properly interchangeable.
      duration_estimate: "25 min"
      commands:
        - purpose: "Find strategies"
          command: "find . -name '*Strategy*.java' | head -20"
        - purpose: "Check interface implementation"
          command: "grep -rn 'implements.*Strategy' --include='*.java' | head -20"
      expected_findings:
        - "Strategy implementations"
        - "Interface consistency"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "pattern_audit_report"
      format: "tabular"
      sections:
        - "Pattern Type"
        - "Implementation"
        - "Correctness Issues"
        - "Recommendations"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Pattern Audits"
        - "Corrections Needed"

  confidence_guidance:
    high: "Clear violation of pattern contract"
    medium: "Deviation from canonical implementation"
    low: "Potential issue requiring context"

offline:
  capability: "full"
  cache_manifest:
    knowledge:
      - source_id: "gof-patterns"
        priority: "required"
      - source_id: "pattern-catalog"
        priority: "required"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires detailed pattern review"
    full:
      included: true
      priority: 2
    architecture:
      included: true
      priority: 2

closeout_checklist:
  - id: "impl-001"
    item: "Singletons have private constructors"
    level: "CRITICAL"
    verification: "manual"
    verification_notes: "All singletons reviewed for proper encapsulation"
    expected: "Confirmed by reviewer"

  - id: "impl-002"
    item: "Factories handle all cases without returning null"
    level: "CRITICAL"
    verification: "grep -rn 'return null' --include='*Factory*.java' | wc -l"
    expected: "0 or documented exceptions"

  - id: "impl-003"
    item: "Builders use fluent interface"
    level: "BLOCKING"
    verification: "manual"
    verification_notes: "Builder methods return this"
    expected: "Confirmed by reviewer"

  - id: "impl-004"
    item: "Observers have cleanup mechanisms"
    level: "WARNING"
    verification: "manual"
    verification_notes: "Unsubscribe available for all subscriptions"
    expected: "Confirmed by reviewer"

governance:
  applicable_to:
    archetypes: ["all"]

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Maintainability", "Reliability"]

relationships:
  commonly_combined:
    - "architecture-design.architectural-patterns.pattern-appropriateness"
    - "architecture-design.architectural-patterns.consistency-of-pattern-usage"
    - "architecture-design.design-principles.single-responsibility"
