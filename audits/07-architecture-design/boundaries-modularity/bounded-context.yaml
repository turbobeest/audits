# ============================================================
# AUDIT: Bounded Context
# ============================================================

audit:
  id: "architecture-design.boundaries-modularity.bounded-context"
  name: "Bounded Context Audit"
  version: "1.0.0"
  last_updated: "2026-01-18"
  status: "active"

  category: "architecture-design"
  category_number: 7
  subcategory: "boundaries-modularity"

  tier: "phd"
  estimated_duration: "120 minutes"

  completeness: "requires_discovery"
  requires_runtime: false
  destructive: false

execution:
  automatable: "partial"
  severity: "high"
  scope: "architecture"

  default_profiles:
    - "full"
    - "architecture"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Evaluates whether the system is properly decomposed into bounded contexts
    as defined in Domain-Driven Design. This includes analyzing whether domain
    models are cohesive within contexts, whether context boundaries align with
    team structures, and whether integration between contexts uses appropriate
    patterns (anti-corruption layers, published language, etc.).

  why_it_matters: |
    Bounded contexts are the most important pattern for managing complexity in
    large systems. Without clear boundaries, domain models become entangled,
    teams step on each other, and the ubiquitous language becomes confused.
    Proper bounded contexts enable team autonomy and prevent design rot.

  when_to_run:
    - "Architecture reviews"
    - "Team restructuring"
    - "Domain model evolution"
    - "Before major feature development"

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Application source code"
    - type: "domain_model"
      description: "Domain model documentation or code"
    - type: "team_structure"
      description: "Team ownership information"

  access_requirements:
    - "Read access to all relevant repositories"
    - "Access to domain documentation"
    - "Understanding of business domains"

discovery:
  code_patterns:
    - pattern: "class\\s+\\w*(Entity|Aggregate|ValueObject)"
      type: "regex"
      scope: "source"
      purpose: "Detect DDD building blocks"

    - pattern: "namespace\\s+\\w+\\.Domain|package\\s+\\w+\\.domain"
      type: "regex"
      scope: "source"
      purpose: "Detect domain packages"

    - pattern: "@AggregateRoot|@Entity|@ValueObject"
      type: "regex"
      scope: "source"
      purpose: "Detect DDD annotations"

  file_patterns:
    - glob: "**/domain/**"
      purpose: "Domain layer"
    - glob: "**/aggregates/**"
      purpose: "Aggregate definitions"
    - glob: "**/contexts/**"
      purpose: "Bounded context directories"

knowledge_sources:
  learning_resources:
    - id: "ddd-blue"
      title: "Domain-Driven Design: Tackling Complexity in the Heart of Software"
      type: "book"
      reference: "Eric Evans, ISBN: 978-0321125217"

    - id: "ddd-distilled"
      title: "Domain-Driven Design Distilled"
      type: "book"
      reference: "Vaughn Vernon, ISBN: 978-0134434421"

    - id: "implementing-ddd"
      title: "Implementing Domain-Driven Design"
      type: "book"
      reference: "Vaughn Vernon, ISBN: 978-0321834577"

  guides:
    - id: "ddd-reference"
      name: "DDD Reference"
      url: "https://www.domainlanguage.com/ddd/reference/"
      offline_cache: true

    - id: "context-mapping"
      name: "Context Mapping Patterns"
      url: "https://www.infoq.com/articles/ddd-contextmapping/"
      offline_cache: true

    - id: "clean-architecture"
      name: "Clean Architecture"
      url: "https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html"
      offline_cache: true

    - id: "pragmatic-programmer"
      name: "Pragmatic Programmer Tips"
      url: "https://pragprog.com/tips/"
      offline_cache: true

tooling:
  static_analysis:
    - tool: "contextmapper"
      purpose: "Context map visualization and validation"
      offline_capable: true

  scripts:
    - id: "bounded-context-scan"
      language: "bash"
      purpose: "Analyze bounded context structure"
      source: "inline"
      code: |
        echo "=== Bounded Context Analysis ==="
        echo "--- Domain directories ---"
        find . -type d -name "domain" -not -path "*/node_modules/*" 2>/dev/null

        echo "--- Aggregate/Entity patterns ---"
        grep -rn "class.*Entity\|class.*Aggregate\|@Entity\|@AggregateRoot" \
          --include="*.java" --include="*.ts" --include="*.cs" . 2>/dev/null | head -30

        echo "--- Cross-context references ---"
        grep -rn "import.*context\|from.*context" \
          --include="*.java" --include="*.ts" --include="*.py" . 2>/dev/null | head -30

signals:
  critical:
    - id: "BC-CRIT-001"
      signal: "Single entity shared across multiple bounded contexts"
      evidence_pattern: "Same User/Order/Product entity imported in multiple contexts"
      explanation: |
        Shared entities across contexts violate DDD fundamentals. The same
        concept has different meanings in different contexts and must be
        modeled separately.
      remediation: "Create context-specific entities, use context mapping for translation"

    - id: "BC-CRIT-002"
      signal: "Missing anti-corruption layer at context boundaries"
      evidence_pattern: "Direct imports from external context domain models"
      explanation: |
        Without anti-corruption layers, one context's model bleeds into
        another, creating tight coupling and polluting the ubiquitous language.
      remediation: "Implement ACL to translate between context models"

  high:
    - id: "BC-HIGH-001"
      signal: "God context (one context contains entire domain)"
      evidence_pattern: "Single 'domain' directory with all entities"
      explanation: |
        A single bounded context for the entire application defeats the
        purpose of DDD. Complexity accumulates without natural boundaries.
      remediation: "Identify and separate distinct bounded contexts"

    - id: "BC-HIGH-002"
      signal: "Same term means different things (no ubiquitous language)"
      evidence_pattern: "'Account' used for user account, billing account, bank account"
      explanation: |
        Overloaded terms indicate missing context boundaries. Each bounded
        context should have its own ubiquitous language.
      remediation: "Define context-specific terminology, document in glossary"

    - id: "BC-HIGH-003"
      signal: "Aggregate boundaries not enforced"
      evidence_pattern: "Direct access to entities within aggregate from outside"
      explanation: |
        Aggregates define consistency boundaries. Bypassing aggregate roots
        violates invariants and creates inconsistent state.
      remediation: "Access entities only through aggregate root"

  medium:
    - id: "BC-MED-001"
      signal: "Missing context map documentation"
      evidence_pattern: "No visual or documented context relationships"
      remediation: "Create and maintain context map diagram"

    - id: "BC-MED-002"
      signal: "Context boundaries don't match team boundaries"
      evidence_pattern: "Multiple teams working in same bounded context"
      remediation: "Align team and context boundaries (Conway's Law)"

    - id: "BC-MED-003"
      signal: "Synchronous calls between bounded contexts"
      evidence_pattern: "HTTP calls between contexts for domain operations"
      remediation: "Consider events, eventual consistency, or context merge"

  low:
    - id: "BC-LOW-001"
      signal: "No explicit context boundary markers in code"
      evidence_pattern: "Contexts distinguished only by directory"
      remediation: "Use modules, packages, or namespaces to enforce boundaries"

    - id: "BC-LOW-002"
      signal: "Missing domain events for cross-context communication"
      evidence_pattern: "Direct method calls instead of events"
      remediation: "Use domain events for loose coupling between contexts"

  positive:
    - id: "BC-POS-001"
      signal: "Clear context separation with explicit boundaries"
      evidence_pattern: "Separate modules/packages per bounded context"

    - id: "BC-POS-002"
      signal: "Anti-corruption layers at integration points"
      evidence_pattern: "Adapters/translators between contexts"

    - id: "BC-POS-003"
      signal: "Context map maintained and current"
      evidence_pattern: "Documented context relationships"

    - id: "BC-POS-004"
      signal: "Ubiquitous language documented per context"
      evidence_pattern: "Glossary per bounded context"

procedure:
  context:
    cognitive_mode: "architectural"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Identify Bounded Contexts"
      description: |
        Map out the bounded contexts in the codebase, whether explicit
        or implicit.
      duration_estimate: "25 min"
      commands:
        - purpose: "Find domain directories"
          command: |
            find . -type d \( -name "domain" -o -name "contexts" -o -name "bounded-context" \) \
              -not -path "*/node_modules/*" 2>/dev/null
        - purpose: "Find aggregate/entity definitions"
          command: |
            grep -rn "class.*Aggregate\|class.*Entity\|@AggregateRoot\|@Entity" \
              --include="*.java" --include="*.ts" --include="*.cs" --include="*.py" . 2>/dev/null | head -40

      expected_findings:
        - "Bounded context inventory"
        - "Domain model locations"

    - id: "2"
      name: "Analyze Context Boundaries"
      description: |
        Evaluate whether boundaries are well-defined and enforced.
      duration_estimate: "25 min"
      commands:
        - purpose: "Find cross-context imports"
          command: |
            grep -rn "import.*domain\|from.*domain" --include="*.ts" --include="*.java" --include="*.py" . 2>/dev/null | \
              grep -v node_modules | head -40
        - purpose: "Check module/package structure"
          command: |
            find . -name "package.json" -exec grep -l "name" {} \; 2>/dev/null | xargs cat | grep "name" | head -20

      expected_findings:
        - "Boundary enforcement level"
        - "Cross-context dependencies"

    - id: "3"
      name: "Review Integration Patterns"
      description: |
        Analyze how bounded contexts communicate and integrate.
      duration_estimate: "25 min"
      commands:
        - purpose: "Find integration patterns"
          command: |
            grep -rn "AntiCorruption\|ACL\|Adapter\|Translator\|event\." \
              --include="*.java" --include="*.ts" --include="*.cs" . 2>/dev/null | head -30
        - purpose: "Find domain events"
          command: |
            grep -rn "Event\|publish\|emit\|dispatch" --include="*.java" --include="*.ts" . 2>/dev/null | \
              grep -i "domain\|event" | head -30

      expected_findings:
        - "Integration patterns used"
        - "Event-driven communication"

    - id: "4"
      name: "Assess Ubiquitous Language"
      description: |
        Check for consistent terminology within contexts.
      duration_estimate: "20 min"
      questions:
        - "Are core domain terms defined consistently?"
        - "Do different contexts use different terms for same concept?"
        - "Is there glossary documentation?"
      expected_findings:
        - "Language consistency"
        - "Term overloading issues"

    - id: "5"
      name: "Check Context Map"
      description: |
        Review or create context map showing relationships.
      duration_estimate: "25 min"
      expected_findings:
        - "Context map existence"
        - "Relationship patterns identified"
        - "Integration strategy"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"
      content:
        - "context_inventory"
        - "boundary_violations"
        - "integration_patterns"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Context Map"
        - "Boundary Assessment"
        - "DDD Compliance"
        - "Recommendations"

  confidence_guidance:
    high: "Clear DDD violation or pattern detected"
    medium: "Architecture suggests potential issue"
    low: "Requires domain expert input"

offline:
  capability: "full"

  cache_manifest:
    knowledge:
      - source_id: "ddd-blue"
        priority: "required"
      - source_id: "ddd-reference"
        priority: "required"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires deep architectural analysis"
    full:
      included: true
      priority: 1
    architecture:
      included: true
      priority: 1

closeout_checklist:
  - id: "bc-001"
    item: "Bounded contexts identified and documented"
    level: "CRITICAL"
    verification: "Context map exists"
    expected: "Documented context boundaries"

  - id: "bc-002"
    item: "No shared domain entities across contexts"
    level: "CRITICAL"
    verification: "Each context has its own models"
    expected: "Context isolation"

  - id: "bc-003"
    item: "Anti-corruption layers at boundaries"
    level: "HIGH"
    verification: "ACL/adapters for cross-context communication"
    expected: "Protected contexts"

governance:
  applicable_to:
    archetypes: ["enterprise", "domain-heavy"]

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Modularity", "Maintainability"]

relationships:
  commonly_combined:
    - "architecture-design.boundaries-modularity.service-boundary"
    - "architecture-design.boundaries-modularity.module-boundary"
    - "architecture-design.patterns.domain-driven-design"
