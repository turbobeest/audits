audit:
  id: architecture-design.boundaries-modularity.package-namespace-structure
  name: Package/Namespace Structure Audit
  version: 1.0.0
  last_updated: '2026-01-18'
  status: active
  category: architecture-design
  category_number: 7
  subcategory: boundaries-modularity
  tier: expert
  estimated_duration: 45 minutes
  completeness: complete
  requires_runtime: false
  destructive: false
execution:
  automatable: 'yes'
  severity: medium
  scope: codebase
  default_profiles:
  - full
  - quality
  blocks_phase: false
  parallelizable: true
description:
  what: |
    Evaluates the organization of code into packages, namespaces, and modules.
    This includes checking naming conventions, hierarchy depth, cohesion within
    packages, and whether the structure reflects the domain and architecture
    appropriately.
  why_it_matters: |
    Good package structure makes code discoverable, maintainable, and helps
    enforce architectural boundaries. Poor structure leads to confusion about
    where code belongs, encourages coupling, and makes navigation difficult
    for new team members.
  when_to_run:
  - Project setup/standardization
  - Technical debt assessments
  - Onboarding improvement
  - Refactoring planning
prerequisites:
  required_artifacts:
  - type: source_code
    description: Application source code
  access_requirements:
  - Read access to source code repository
discovery:
  code_patterns:
  - pattern: package\s+[\w\.]+|namespace\s+[\w\.]+|from\s+\.
    type: regex
    scope: source
    purpose: Detect package/namespace declarations
  file_patterns:
  - glob: '**/package.json'
    purpose: NPM packages
  - glob: '**/__init__.py'
    purpose: Python packages
  - glob: '**/go.mod'
    purpose: Go modules
  - glob: '**/*.csproj'
    purpose: .NET projects
knowledge_sources:
  guides:
  - id: java-package-naming
    name: Java Package Naming Conventions
    url: https://docs.oracle.com/javase/tutorial/java/package/namingpkgs.html
    offline_cache: true
  - id: python-packages
    name: Python Packages
    url: https://docs.python.org/3/tutorial/modules.html#packages
    offline_cache: true
  - id: go-project-layout
    name: Standard Go Project Layout
    url: https://github.com/golang-standards/project-layout
    offline_cache: true
  - id: ddd-evans
    name: Domain-Driven Design Reference
    url: https://www.domainlanguage.com/ddd/reference/
    offline_cache: true
  - id: clean-architecture
    name: Clean Architecture
    url: https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html
    offline_cache: true
  - id: pragmatic-programmer
    name: Pragmatic Programmer Tips
    url: https://pragprog.com/tips/
    offline_cache: true
tooling:
  static_analysis:
  - tool: eslint-plugin-import
    purpose: Import organization enforcement
    offline_capable: true
  - tool: isort
    purpose: Python import sorting
    offline_capable: true
  scripts:
  - id: package-structure-scan
    language: bash
    purpose: Analyze package structure
    source: inline
    code: |
      echo "=== Package/Namespace Structure Analysis ==="
      echo "--- Directory structure depth ---"
      find . -type d -not -path "*/node_modules/*" -not -path "*/.git/*" | \
        awk -F'/' '{print NF-1}' | sort -n | uniq -c | tail -10

      echo "--- Package/module files ---"
      find . -name "package.json" -o -name "__init__.py" -o -name "go.mod" | \
        grep -v node_modules | wc -l

      echo "--- Files per directory (potential cohesion issue) ---"
      find . -type d -not -path "*/node_modules/*" -not -path "*/.git/*" | while read dir; do
        count=$(find "$dir" -maxdepth 1 -type f \( -name "*.js" -o -name "*.ts" -o -name "*.py" -o -name "*.java" \) 2>/dev/null | wc -l)
        if [ "$count" -gt 15 ]; then
          echo "$dir: $count files"
        fi
      done | head -20
signals:
  critical:
  - id: PKG-CRIT-001
    signal: Flat structure with hundreds of files
    evidence_pattern: Single src/ directory with >100 files
    explanation: |
      No organization makes code undiscoverable. Developers can't find
      where functionality lives, leading to duplication and inconsistency.
    remediation: Organize by domain, feature, or layer
  - id: PKG-CRIT-002
    signal: Deeply nested structure (>7 levels)
    evidence_pattern: a/b/c/d/e/f/g/h/file.ts
    explanation: |
      Excessively deep nesting makes navigation painful and often indicates
      over-engineering or misunderstanding of proper organization.
    remediation: Flatten structure, organize by business domain
  high:
  - id: PKG-HIGH-001
    signal: Inconsistent package naming conventions
    evidence_pattern: Mix of PascalCase, camelCase, snake_case directories
    explanation: |
      Inconsistent naming creates confusion and makes automation difficult.
      Team members waste time guessing correct casing.
    remediation: Standardize on language-appropriate convention
  - id: PKG-HIGH-002
    signal: Packages organized by technical layer only
    evidence_pattern: controllers/, services/, models/ with no domain split
    explanation: |
      Pure technical organization splits related code across the codebase.
      Changes to a feature touch many directories.
    remediation: Organize by feature/domain within technical layers
  - id: PKG-HIGH-003
    signal: Large packages with mixed responsibilities
    evidence_pattern: Package with >30 files of unrelated functionality
    explanation: |
      Large packages with mixed concerns violate Single Responsibility
      and make understanding scope difficult.
    remediation: Split into smaller, cohesive packages
  medium:
  - id: PKG-MED-001
    signal: util/common/shared packages as dumping ground
    evidence_pattern: Large utils/ or common/ with diverse functionality
    remediation: Split utilities by purpose, consider domain placement
  - id: PKG-MED-002
    signal: Package names don't reflect content
    evidence_pattern: Package 'foo' contains UserService, OrderController
    remediation: Name packages to reflect their domain/purpose
  - id: PKG-MED-003
    signal: Orphaned files outside package structure
    evidence_pattern: Files in root src/ alongside subdirectories
    remediation: Move all files into appropriate packages
  low:
  - id: PKG-LOW-001
    signal: Missing __init__.py in Python packages
    evidence_pattern: Python directories without __init__.py
    remediation: Add __init__.py (can be empty) to all packages
  - id: PKG-LOW-002
    signal: No index.ts/index.js barrel files
    evidence_pattern: No public API definition for packages
    remediation: Add barrel files to define public exports
  positive:
  - id: PKG-POS-001
    signal: Consistent naming conventions
    evidence_pattern: Uniform casing throughout codebase
  - id: PKG-POS-002
    signal: Domain-oriented package structure
    evidence_pattern: /users, /orders, /payments with internal layers
  - id: PKG-POS-003
    signal: Small, focused packages
    evidence_pattern: Packages with <15 files, cohesive functionality
procedure:
  context:
    cognitive_mode: analytical
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Map Package Structure
    description: |
      Create a map of the package/namespace hierarchy.
    duration_estimate: 10 min
    commands:
    - purpose: List top-level structure
      command: |
        ls -la src/ 2>/dev/null || ls -la app/ 2>/dev/null || ls -la . 2>/dev/null | head -30
    - purpose: Count nesting depth
      command: |
        find . -type d -not -path "*/node_modules/*" -not -path "*/.git/*" | \
          awk -F'/' '{print NF-1}' | sort -n | uniq -c
    expected_findings:
    - Structure overview
    - Nesting depth distribution
  - id: '2'
    name: Analyze Package Sizes
    description: |
      Check for oversized or undersized packages.
    duration_estimate: 10 min
    commands:
    - purpose: Count files per directory
      command: |
        find . -type d -not -path "*/node_modules/*" -not -path "*/.git/*" | while read dir; do
          count=$(find "$dir" -maxdepth 1 -type f \( -name "*.js" -o -name "*.ts" -o -name "*.py" -o -name "*.java" \) 2>/dev/null | wc -l)
          echo "$count $dir"
        done | sort -rn | head -30
    expected_findings:
    - Large package identification
    - Size distribution
  - id: '3'
    name: Check Naming Conventions
    description: |
      Verify consistent naming across packages.
    duration_estimate: 10 min
    commands:
    - purpose: Find naming patterns
      command: |
        find . -type d -not -path "*/node_modules/*" -not -path "*/.git/*" | \
          grep -E "^./[a-zA-Z]" | head -50
    expected_findings:
    - Naming convention consistency
    - Violations
  - id: '4'
    name: Evaluate Organization Strategy
    description: |
      Determine if organization is by feature, layer, or hybrid.
    duration_estimate: 15 min
    commands:
    - purpose: Check for layer-based organization
      command: |
        ls -d */controllers 2>/dev/null || ls -d */services 2>/dev/null || echo "No layer dirs"
    - purpose: Check for feature-based organization
      command: |
        ls -la src/ 2>/dev/null | grep -E "user|order|product|auth" || echo "No obvious feature dirs"
    expected_findings:
    - Organization strategy
    - Consistency assessment
output:
  deliverables:
  - type: finding_list
    format: structured
    content:
    - structure_analysis
    - naming_violations
    - size_issues
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Structure Assessment
    - Recommendations
  confidence_guidance:
    high: Clear structural issue detected
    medium: Pattern suggests potential issue
    low: Subjective organization preference
offline:
  capability: full
  cache_manifest:
    knowledge:
    - source_id: go-project-layout
      priority: recommended
profiles:
  membership:
    quick:
      included: true
      priority: 3
    full:
      included: true
      priority: 2
    quality:
      included: true
      priority: 2
closeout_checklist:
- id: pkg-001
  item: No extremely deep nesting (>7 levels)
  level: HIGH
  verification: find . -type d | depth check
  expected: Max 5-6 levels typical
- id: pkg-002
  item: Consistent naming conventions
  level: BLOCKING
  verification: Visual inspection of directory names
  expected: Uniform casing
- id: pkg-003
  item: No oversized packages (>30 files)
  level: WARNING
  verification: Files per directory check
  expected: Reasonable package sizes
governance:
  applicable_to:
    archetypes:
    - all
  compliance_frameworks:
  - framework: ISO 25010
    controls:
    - Maintainability
    - Modularity
relationships:
  commonly_combined:
  - architecture-design.boundaries-modularity.module-boundary
  - code-quality.maintainability.code-organization
