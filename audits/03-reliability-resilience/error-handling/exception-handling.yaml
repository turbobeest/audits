audit:
  id: reliability-resilience.error-handling.exception-handling
  name: Exception Handling Audit
  version: 1.0.0
  last_updated: '2026-01-18'
  status: active
  category: reliability-resilience
  category_number: 3
  subcategory: error-handling
  tier: phd
  estimated_duration: 2-4 hours  # median: 3h
  completeness: complete
  requires_runtime: false
  destructive: false
execution:
  automatable: partial
  severity: high
  scope: codebase
  default_profiles:
  - full
  - security
  blocks_phase: false
  parallelizable: true
description:
  what: |
    Examines exception handling patterns across the codebase to identify
    poor practices such as catching generic exceptions, swallowing errors,
    missing exception handling in critical paths, and improper exception
    chaining. Reviews try-catch-finally structures, exception type hierarchies,
    and ensures exceptions contain actionable context.
  why_it_matters: |
    Poor exception handling leads to silent failures, data corruption, security
    vulnerabilities, and debugging nightmares. When exceptions are swallowed or
    caught too broadly, root causes become impossible to trace. Unhandled exceptions
    can crash systems, while improperly handled ones mask underlying problems that
    compound over time. Proper exception handling is foundational to reliable systems.
  when_to_run:
  - Code review or pull request integration
  - After adding new error-prone functionality
  - When debugging elusive production issues
  - Security audits
prerequisites:
  required_artifacts:
  - type: source_code
    description: Access to the full application codebase
  - type: coding_standards
    description: Team's exception handling guidelines if available
  access_requirements:
  - Read access to source code repository
  - Access to language-specific linter configurations
discovery:
  code_patterns:
  - pattern: catch\s*\(\s*(Exception|Error|Throwable|BaseException|\.\.\.)\s*
    type: regex
    scope: source
    purpose: Find overly broad exception catches
  - pattern: catch\s*\([^)]+\)\s*\{\s*\}
    type: regex
    scope: source
    purpose: Find empty catch blocks that swallow exceptions
  - pattern: 'except:\s*$|except\s+Exception:'
    type: regex
    scope: source
    purpose: Python bare except or generic Exception catch
  - pattern: // TODO|// FIXME|# TODO|# FIXME
    type: regex
    scope: source
    purpose: Find deferred error handling marked with TODO
  - pattern: e\.printStackTrace\(\)
    type: regex
    scope: source
    purpose: Find Java stack traces printed to stdout instead of logging
  file_patterns:
  - glob: '**/*.java'
    purpose: Java source files for exception handling review
  - glob: '**/*.py'
    purpose: Python source files for exception handling review
  - glob: '**/*.ts'
    purpose: TypeScript source files for exception handling review
  - glob: '**/*.go'
    purpose: Go source files for error handling review
  - glob: '**/*.rs'
    purpose: Rust source files for Result/Option handling review
knowledge_sources:
  guides:
  - id: effective-java
    name: Effective Java - Exception Handling
    url: https://www.oracle.com/java/technologies/effective-java.html
    offline_cache: true
  - id: python-errors
    name: Python Exception Handling Best Practices
    url: https://docs.python.org/3/tutorial/errors.html
    offline_cache: true
  - id: release-it
    name: Michael Nygard - Release It!
    url: https://pragprog.com/titles/mnee2/release-it-second-edition/
    offline_cache: true
  learning_resources:
  - id: clean-code-exceptions
    title: Clean Code - Error Handling Chapter
    type: book
    reference: 'ISBN: 978-0132350884'
tooling:
  static_analysis:
  - tool: SonarQube
    purpose: Detect exception handling code smells
    offline_capable: false
  - tool: ESLint
    purpose: JavaScript/TypeScript exception pattern checking
    offline_capable: true
  - tool: Pylint
    purpose: Python exception handling analysis
    offline_capable: true
  - tool: ErrorProne
    purpose: Java compile-time exception checking
    offline_capable: true
  scripts:
  - id: find-empty-catches
    language: bash
    purpose: Find empty catch blocks across languages
    source: inline
    code: |
      #!/bin/bash
      # Find empty catch blocks
      echo "=== Java Empty Catches ==="
      grep -rn "catch.*{[[:space:]]*}" --include="*.java" . 2>/dev/null || echo "None found"
      echo ""
      echo "=== Python Bare Excepts ==="
      grep -rn "except:[[:space:]]*$\|except:[[:space:]]*#" --include="*.py" . 2>/dev/null || echo "None found"
      echo ""
      echo "=== TypeScript Empty Catches ==="
      grep -rn "catch.*{[[:space:]]*}" --include="*.ts" . 2>/dev/null || echo "None found"
signals:
  critical:
  - id: EXC-CRIT-001
    signal: Security-sensitive code with swallowed exceptions
    evidence_pattern: catch.*\{\s*\}|except:\s*pass
    explanation: |
      Empty catch blocks in security-sensitive areas (authentication,
      authorization, cryptography) can mask critical security failures,
      allowing unauthorized access or data breaches to go undetected.
    remediation: Log exceptions with security context and take appropriate recovery action
  - id: EXC-CRIT-002
    signal: Transaction code catching and ignoring exceptions
    evidence_pattern: transaction|commit|rollback
    explanation: |
      Swallowing exceptions in transaction handling can lead to data
      corruption, partial commits, and database inconsistency.
    remediation: Ensure all transaction exceptions trigger proper rollback and logging
  high:
  - id: EXC-HIGH-001
    signal: Generic exception catch covering specific errors
    evidence_pattern: catch\s*\(Exception\s
    explanation: |
      Catching generic exceptions masks specific error types and makes
      it impossible to handle different failure modes appropriately.
    remediation: Catch specific exception types and handle each appropriately
  - id: EXC-HIGH-002
    signal: Exception caught but only message logged
    evidence_pattern: catch.*log.*getMessage\(\)
    explanation: |
      Logging only the exception message loses the stack trace, making
      root cause analysis nearly impossible.
    remediation: Log the full exception including stack trace
  medium:
  - id: EXC-MED-001
    signal: Exception re-thrown without original cause
    evidence_pattern: throw new.*Exception\([^,)]+\)(?!.*cause)
    remediation: Chain exceptions using the cause parameter to preserve stack trace
  - id: EXC-MED-002
    signal: printStackTrace() used instead of logger
    evidence_pattern: printStackTrace\(\)
    remediation: Use structured logging framework instead of printStackTrace()
  low:
  - id: EXC-LOW-001
    signal: Overly verbose exception handling in simple operations
  - id: EXC-LOW-002
    signal: Inconsistent exception naming conventions
  positive:
  - id: EXC-POS-001
    signal: Custom exception hierarchy with domain context
  - id: EXC-POS-002
    signal: Comprehensive exception documentation
procedure:
  context:
    cognitive_mode: critical
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Identify exception handling patterns
    description: |
      Scan the codebase for try-catch blocks, exception declarations,
      and error handling patterns. Categorize by language and context.
    duration_estimate: 30 min
    commands:
    - purpose: Find all try-catch blocks
      command: grep -rn 'try\s*{\|try:\|except\|catch' --include='*.java' --include='*.py' --include='*.ts'
        .
    expected_findings:
    - List of all exception handling locations
    - Patterns of exception usage
  - id: '2'
    name: Analyze exception granularity
    description: |
      Review caught exception types to identify overly broad catches.
      Check if specific exceptions are being caught where appropriate.
    duration_estimate: 45 min
    commands:
    - purpose: Find generic exception catches
      command: grep -rn 'catch\s*(Exception\|catch\s*(Error\|except Exception\|except:' --include='*.java'
        --include='*.py' --include='*.ts' .
    expected_findings:
    - Generic exception catches that should be specific
    - Appropriate use of exception hierarchies
  - id: '3'
    name: Check exception handling completeness
    description: |
      Verify that exceptions contain appropriate context, are logged
      properly, and that error recovery paths are implemented.
    duration_estimate: 45 min
    commands:
    - purpose: Find empty catch blocks
      command: grep -rn -A1 'catch.*{' --include='*.java' --include='*.ts' . | grep -B1 '^[^:]*:[[:space:]]*}'
    expected_findings:
    - Empty or minimal catch blocks
    - Missing error context in exceptions
  - id: '4'
    name: Review critical path exception handling
    description: |
      Focus on security, transaction, and data handling code to ensure
      exception handling is thorough and appropriate.
    duration_estimate: 45 min
    expected_findings:
    - Critical paths with inadequate exception handling
    - Security implications of exception handling gaps
output:
  deliverables:
  - type: finding_list
    format: structured
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Exception Handling Patterns Found
    - Critical Issues
    - Recommendations
  confidence_guidance:
    high: Direct code evidence of poor exception handling patterns
    medium: Pattern suggests potential issues, context needed for confirmation
    low: Indirect indicators or style preferences
offline:
  capability: full
  cache_manifest:
    knowledge:
    - source_id: effective-java
      priority: recommended
profiles:
  membership:
    quick:
      included: false
      reason: Requires thorough code analysis
    full:
      included: true
      priority: 1
    security:
      included: true
      priority: 2
closeout_checklist:
- id: exception-handling-001
  item: No empty catch blocks in security-critical code
  level: CRITICAL
  verification: grep -rn 'catch.*{[[:space:]]*}' --include='*.java' --include='*.ts' src/auth src/security
    2>/dev/null | wc -l | xargs -I{} sh -c 'if [ {} -eq 0 ]; then echo PASS; else echo FAIL; fi'
  expected: PASS
- id: exception-handling-002
  item: No bare except clauses in Python code
  level: CRITICAL
  verification: grep -rn '^[[:space:]]*except:[[:space:]]*$' --include='*.py' . 2>/dev/null | wc -l |
    xargs -I{} sh -c 'if [ {} -eq 0 ]; then echo PASS; else echo FAIL; fi'
  expected: PASS
- id: exception-handling-003
  item: No printStackTrace() calls in production code
  level: BLOCKING
  verification: grep -rn 'printStackTrace()' --include='*.java' src/ 2>/dev/null | grep -v test | wc -l
    | xargs -I{} sh -c 'if [ {} -eq 0 ]; then echo PASS; else echo FAIL; fi'
  expected: PASS
- id: exception-handling-004
  item: Custom exception classes exist for domain errors
  level: WARNING
  verification: manual
  verification_notes: Verify that domain-specific exceptions are defined and used
  expected: Confirmed by reviewer
governance:
  applicable_to:
    archetypes:
    - all
  compliance_frameworks:
  - framework: OWASP
    controls:
    - A09:2021-Security Logging and Monitoring Failures
relationships:
  commonly_combined:
  - reliability-resilience.error-handling.error-logging
  - reliability-resilience.error-handling.error-propagation
