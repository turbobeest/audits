audit:
  id: reliability-resilience.error-handling.partial-failure-handling
  name: Partial Failure Handling Audit
  version: 1.0.0
  last_updated: '2026-01-18'
  status: active
  category: reliability-resilience
  category_number: 3
  subcategory: error-handling
  tier: phd
  estimated_duration: 3-5 hours  # median: 4h
  completeness: complete
  requires_runtime: false
  destructive: false
execution:
  automatable: partial
  severity: high
  scope: codebase
  default_profiles:
  - full
  - production
  blocks_phase: false
  parallelizable: true
description:
  what: |
    Examines how applications handle partial failures where some components
    or dependencies fail while others remain operational. Reviews fallback
    mechanisms, graceful degradation patterns, circuit breakers, bulkheads,
    and the ability to continue providing value when operating in degraded
    mode. Ensures failures don't cascade unnecessarily.
  why_it_matters: |
    In distributed systems, partial failures are the norm, not the exception.
    Systems that fail completely when one dependency is down provide poor
    user experience and waste the availability of healthy components.
    Well-designed partial failure handling maintains core functionality
    during outages and prevents cascade failures.
  when_to_run:
  - Architecture reviews
  - Before production deployment
  - After adding new dependencies
  - During chaos engineering exercises
prerequisites:
  required_artifacts:
  - type: source_code
    description: Application source code
  - type: architecture_docs
    description: System dependencies and architecture diagram
  access_requirements:
  - Read access to source code
  - Understanding of service dependencies
discovery:
  code_patterns:
  - pattern: circuit.*breaker|CircuitBreaker|circuitBreaker
    type: regex
    scope: source
    purpose: Find circuit breaker implementations
  - pattern: fallback|Fallback|degraded
    type: keyword
    scope: source
    purpose: Find fallback mechanisms
  - pattern: bulkhead|Bulkhead|isolation
    type: keyword
    scope: source
    purpose: Find bulkhead patterns
  - pattern: timeout|Timeout|TIMEOUT
    type: keyword
    scope: source
    purpose: Find timeout configurations
  - pattern: hystrix|resilience4j|polly|Retry
    type: keyword
    scope: source
    purpose: Find resilience libraries
  file_patterns:
  - glob: '**/client/**/*.{java,ts,go,py}'
    purpose: Service clients with resilience patterns
  - glob: '**/circuit/**/*.{java,ts,go,py}'
    purpose: Circuit breaker implementations
  - glob: '**/resilience/**/*.{java,ts,go,py}'
    purpose: Resilience pattern implementations
  - glob: '**/fallback/**/*.{java,ts,go,py}'
    purpose: Fallback implementations
knowledge_sources:
  guides:
  - id: ms-resilience
    name: Microsoft Cloud Design Patterns - Resilience
    url: https://docs.microsoft.com/en-us/azure/architecture/patterns/category/resiliency
    offline_cache: true
  - id: netflix-hystrix
    name: Netflix Hystrix Patterns
    url: https://github.com/Netflix/Hystrix/wiki
    offline_cache: true
  - id: release-it
    name: Michael Nygard - Release It!
    url: https://pragprog.com/titles/mnee2/release-it-second-edition/
    offline_cache: true
  papers:
  - id: harvest-yield
    title: Harvest, Yield, and Scalable Tolerant Systems
    url: https://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.24.3690&rep=rep1&type=pdf
  learning_resources:
  - id: release-it
    title: Release It! - Stability Patterns
    type: book
    reference: 'ISBN: 978-1680502398'
tooling:
  static_analysis:
  - tool: SonarQube
    purpose: Detect missing error handling
    offline_capable: false
  scripts:
  - id: find-resilience-patterns
    language: bash
    purpose: Find resilience pattern implementations
    source: inline
    code: |
      #!/bin/bash
      echo "=== Circuit Breaker Usage ==="
      grep -rn "circuit.*[Bb]reaker\\|CircuitBreaker" --include="*.java" --include="*.ts" --include="*.go" --include="*.py" . 2>/dev/null | head -20
      echo ""
      echo "=== Fallback Implementations ==="
      grep -rn "fallback\\|Fallback\\|degraded" --include="*.java" --include="*.ts" --include="*.go" --include="*.py" . 2>/dev/null | head -20
      echo ""
      echo "=== Timeout Configurations ==="
      grep -rn "timeout\\|Timeout" --include="*.java" --include="*.ts" --include="*.go" --include="*.yaml" . 2>/dev/null | head -30
      echo ""
      echo "=== Bulkhead/Isolation Patterns ==="
      grep -rn "bulkhead\\|Bulkhead\\|semaphore\\|Semaphore" --include="*.java" --include="*.ts" --include="*.go" --include="*.py" . 2>/dev/null | head -20
signals:
  critical:
  - id: PARTIAL-CRIT-001
    signal: No timeouts on external service calls
    evidence_pattern: http\.Get|fetch|request(?!.*timeout)
    explanation: |
      Without timeouts, a slow or unresponsive dependency can cause
      resource exhaustion and cascade failures throughout the system.
    remediation: Configure timeouts on all external service calls (typically 1-30 seconds)
  - id: PARTIAL-CRIT-002
    signal: Single dependency failure causes complete system failure
    evidence_indicators:
    - No fallback mechanisms for critical paths
    - All errors propagate directly to users
    explanation: |
      When one dependency can take down the entire system, availability
      is limited to the least reliable component.
    remediation: Implement fallbacks, caching, or degraded modes for critical dependencies
  high:
  - id: PARTIAL-HIGH-001
    signal: No circuit breakers on unreliable dependencies
    explanation: |
      Without circuit breakers, repeated calls to failing services
      waste resources and slow recovery.
    remediation: Add circuit breakers that trip after consecutive failures
  - id: PARTIAL-HIGH-002
    signal: Tight coupling prevents graceful degradation
    explanation: |
      Synchronous dependencies without fallbacks make the system only
      as available as its least available component.
    remediation: Implement async patterns or fallbacks to decouple availability
  medium:
  - id: PARTIAL-MED-001
    signal: No bulkhead isolation between components
    remediation: Use separate thread pools/connection pools for different dependencies
  - id: PARTIAL-MED-002
    signal: Fallback mechanisms not tested
    remediation: Add chaos testing to verify fallback behavior
  - id: PARTIAL-MED-003
    signal: Cached fallback data may be stale
    remediation: Configure appropriate cache TTLs and stale data indicators
  low:
  - id: PARTIAL-LOW-001
    signal: Inconsistent timeout values across services
  positive:
  - id: PARTIAL-POS-001
    signal: Comprehensive circuit breaker coverage
  - id: PARTIAL-POS-002
    signal: Well-defined degraded modes with clear user communication
procedure:
  context:
    cognitive_mode: critical
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Map dependencies and failure modes
    description: |
      Identify all external dependencies and understand what happens
      when each one fails.
    duration_estimate: 45 min
    questions:
    - What external services does this system depend on?
    - What happens to the user if each dependency fails?
    - Which dependencies are critical vs. optional?
    expected_findings:
    - Dependency inventory
    - Failure impact mapping
  - id: '2'
    name: Review timeout configuration
    description: |
      Check that all external calls have appropriate timeouts configured.
    duration_estimate: 45 min
    commands:
    - purpose: Find timeout configurations
      command: grep -rn 'timeout\|Timeout\|TIMEOUT' --include='*.java' --include='*.ts' --include='*.go'
        --include='*.yaml' --include='*.json' . 2>/dev/null | head -50
    expected_findings:
    - Timeout coverage
    - Timeout values appropriateness
  - id: '3'
    name: Analyze circuit breaker usage
    description: |
      Identify circuit breaker implementations and verify they cover
      all unreliable dependencies.
    duration_estimate: 45 min
    commands:
    - purpose: Find circuit breaker implementations
      command: grep -rn 'circuit\|Circuit\|breaker\|Breaker' --include='*.java' --include='*.ts' --include='*.go'
        --include='*.py' . 2>/dev/null | head -40
    expected_findings:
    - Circuit breaker coverage
    - Configuration appropriateness
  - id: '4'
    name: Review fallback mechanisms
    description: |
      Check that critical paths have fallback mechanisms for when
      dependencies are unavailable.
    duration_estimate: 45 min
    commands:
    - purpose: Find fallback implementations
      command: grep -rn 'fallback\|Fallback\|default\|cached' --include='*.java' --include='*.ts' --include='*.go'
        --include='*.py' . 2>/dev/null | head -40
    expected_findings:
    - Fallback coverage
    - Fallback quality
output:
  deliverables:
  - type: finding_list
    format: structured
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Dependency Risk Analysis
    - Resilience Pattern Coverage
    - Recommendations
  confidence_guidance:
    high: Direct evidence of missing resilience patterns
    medium: Pattern suggests potential gaps
    low: Requires chaos testing to confirm behavior
offline:
  capability: full
  cache_manifest:
    knowledge:
    - source_id: ms-resilience
      priority: required
profiles:
  membership:
    quick:
      included: false
      reason: Requires thorough dependency and pattern analysis
    full:
      included: true
      priority: 1
    production:
      included: true
      priority: 1
closeout_checklist:
- id: partial-failure-handling-001
  item: Timeouts configured on all external service calls
  level: CRITICAL
  verification: manual
  verification_notes: Review external client code to verify timeout configuration
  expected: Confirmed by reviewer
- id: partial-failure-handling-002
  item: Circuit breakers on unreliable dependencies
  level: CRITICAL
  verification: grep -rni 'circuit.*breaker\|CircuitBreaker' --include='*.java' --include='*.ts' --include='*.go'
    --include='*.py' . 2>/dev/null | wc -l | xargs -I{} sh -c 'if [ {} -gt 0 ]; then echo PASS; else echo
    FAIL; fi'
  expected: PASS
- id: partial-failure-handling-003
  item: Fallback mechanisms for critical dependencies
  level: BLOCKING
  verification: grep -rni 'fallback\|Fallback' --include='*.java' --include='*.ts' --include='*.go' --include='*.py'
    . 2>/dev/null | wc -l | xargs -I{} sh -c 'if [ {} -gt 0 ]; then echo PASS; else echo FAIL; fi'
  expected: PASS
- id: partial-failure-handling-004
  item: Degraded mode behavior documented
  level: BLOCKING
  verification: manual
  verification_notes: Verify documentation describes behavior during partial failures
  expected: Confirmed by reviewer
- id: partial-failure-handling-005
  item: Chaos/failure testing verifies fallback behavior
  level: WARNING
  verification: manual
  verification_notes: Verify fallback paths are tested through chaos engineering
  expected: Confirmed by reviewer
governance:
  applicable_to:
    archetypes:
    - distributed
    - microservices
    - cloud-native
  compliance_frameworks:
  - framework: SRE Best Practices
    controls:
    - Graceful Degradation
    - Circuit Breakers
relationships:
  commonly_combined:
  - reliability-resilience.error-handling.retry-logic
  - reliability-resilience.error-handling.error-rate-monitoring
