# ============================================================
# HOT PATH OPTIMIZATION AUDIT
# ============================================================
# Identifies critical execution paths that handle the majority of
# traffic and evaluates their optimization level.

audit:
  id: "performance-efficiency.algorithmic-efficiency.hot-path-optimization"
  name: "Hot Path Optimization Audit"
  version: "1.0.0"
  last_updated: "2026-01-18"
  status: "active"

  category: "performance-efficiency"
  category_number: 2
  subcategory: "algorithmic-efficiency"

  tier: "expert"
  estimated_duration: "3 hours"

  completeness: "complete"
  requires_runtime: true
  destructive: false

execution:
  automatable: "partial"
  severity: "high"
  scope: "codebase"

  default_profiles:
    - "full"
    - "production"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Identifies and analyzes the most frequently executed code paths
    (hot paths) for optimization opportunities. Reviews profiling data,
    traces request flows, and evaluates whether critical paths receive
    appropriate optimization attention.

  why_it_matters: |
    Hot paths account for the majority of execution time. Optimizing a
    function called 1 million times per minute has far greater impact
    than optimizing code called once per hour. Focus optimization effort
    where it matters most using data-driven identification.

  when_to_run:
    - "Performance optimization initiatives"
    - "Before high-traffic events"
    - "After adding new high-volume features"
    - "Production performance review"

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Application source code"
    - type: "profiling_data"
      description: "CPU/time profiling data from production or load tests"
    - type: "traffic_analytics"
      description: "Request volume by endpoint"

  access_requirements:
    - "Source code repository access"
    - "APM or profiling tool access"
    - "Traffic analytics access"

discovery:
  metrics_queries:
    - system: "APM (New Relic, Datadog, etc.)"
      query: "Top endpoints by request volume"
      purpose: "Identify highest-traffic paths"
      threshold: "Top 10% of endpoints by volume"

    - system: "Profiler"
      query: "CPU time by function"
      purpose: "Find CPU-intensive functions"
      threshold: "Functions consuming >5% of CPU time"

  code_patterns:
    - pattern: "@app\\.route|@router\\.|def handle|async.*handler"
      type: "regex"
      scope: "source"
      purpose: "Find request handlers"

    - pattern: "for.*\\{|while.*\\{|\\.forEach\\(|\\.map\\("
      type: "regex"
      scope: "source"
      purpose: "Find loops in hot paths"

knowledge_sources:
  guides:
    - id: "profiling-guide"
      name: "Performance Profiling Guide"
      url: "https://docs.python.org/3/library/profile.html"
      offline_cache: true

    - id: "chrome-devtools"
      name: "Chrome DevTools Performance"
      url: "https://developer.chrome.com/docs/devtools/performance/"
      offline_cache: true

tooling:
  static_analysis:
    - tool: "profiler"
      purpose: "Identify CPU-intensive code paths"
      offline_capable: false

    - tool: "flame graph generator"
      purpose: "Visualize call stacks"
      offline_capable: false

  infrastructure_tools:
    - tool: "APM traces"
      purpose: "Trace request flow through services"
      command: "Review APM dashboard for slowest traces"

  scripts:
    - id: "hot-path-identifier"
      language: "bash"
      purpose: "Find potential hot paths by code patterns"
      source: "inline"
      code: |
        #!/bin/bash
        # Find request handlers and their complexity
        echo "=== Request Handlers ==="
        rg -n '@app.route|@router|def get|def post' --type py --type js
        echo
        echo "=== Loops in handlers ==="
        rg -l '@app.route|@router' --type py | xargs rg -n 'for |while '

signals:
  critical:
    - id: "HOT-PATH-CRIT-001"
      signal: "Unoptimized O(n^2) algorithm in highest-traffic endpoint"
      evidence_pattern: "Top endpoint by volume contains nested loops"
      explanation: |
        The highest-traffic code paths have the greatest optimization leverage.
        An O(n^2) algorithm in a hot path will dominate system resources and
        create scaling limits.
      remediation: "Prioritize optimization of highest-impact algorithms"

    - id: "HOT-PATH-CRIT-002"
      signal: "Blocking I/O in hot synchronous path"
      evidence_pattern: "Synchronous file read or HTTP call in high-traffic handler"
      explanation: |
        Blocking I/O in hot paths blocks threads/event loop, limiting
        throughput and causing tail latency spikes under load.
      remediation: "Convert to async I/O or move to background processing"

  high:
    - id: "HOT-PATH-HIGH-001"
      signal: "No profiling data for production traffic"
      evidence_pattern: "Optimization decisions made without profiling"
      explanation: |
        Without profiling data, optimization is guesswork. Developers often
        optimize cold paths while hot paths remain unoptimized.
      remediation: "Enable production profiling and use data to guide optimization"

    - id: "HOT-PATH-HIGH-002"
      signal: "Hot path performs unnecessary work"
      evidence_pattern: "Repeated computation, unused data fetching, redundant validation"
      explanation: |
        Any unnecessary work in hot paths is multiplied by traffic volume.
        Fetching data that's never used or recomputing cached values wastes
        significant resources at scale.
      remediation: "Audit hot paths for unnecessary operations and remove them"

  medium:
    - id: "HOT-PATH-MED-001"
      signal: "Hot path not using optimal data structures"
      evidence_pattern: "Array lookups instead of hash maps in frequently called code"
      remediation: "Replace with O(1) data structures"

    - id: "HOT-PATH-MED-002"
      signal: "Excessive logging in hot path"
      evidence_pattern: "Debug-level logging in high-traffic code"
      remediation: "Reduce logging verbosity or sample in hot paths"

  low:
    - id: "HOT-PATH-LOW-001"
      signal: "Hot paths not documented"
      remediation: "Document critical paths and their performance requirements"

  positive:
    - id: "HOT-PATH-POS-001"
      signal: "Hot paths identified and optimized with profiling data"

    - id: "HOT-PATH-POS-002"
      signal: "Critical paths have performance tests"

procedure:
  context:
    cognitive_mode: "critical"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Identify hot paths from traffic data"
      description: |
        Use traffic analytics and APM data to identify the highest-volume
        request paths and most CPU-intensive functions.
      duration_estimate: "30 min"

      commands:
        - purpose: "Find request handlers"
          command: "rg -n '@app\\.route|@router|def.*handler|async.*handler' --type py --type js --type ts"

      expected_findings:
        - "Top 10 endpoints by volume"
        - "Top 10 functions by CPU time"

    - id: "2"
      name: "Analyze hot path complexity"
      description: |
        Examine identified hot paths for algorithmic complexity, I/O patterns,
        and unnecessary work.
      duration_estimate: "60 min"

      commands:
        - purpose: "Find loops in handlers"
          command: "rg -l '@app.route|@router' --type py --type js | head -10 | xargs rg -n 'for |while |\\.map\\('"

      expected_findings:
        - "Complexity assessment per hot path"
        - "I/O pattern identification"

    - id: "3"
      name: "Identify optimization opportunities"
      description: |
        Catalog specific optimization opportunities ranked by expected
        impact based on traffic volume and current inefficiency.
      duration_estimate: "30 min"

      expected_findings:
        - "Prioritized optimization list"
        - "Expected impact estimates"

    - id: "4"
      name: "Review performance testing coverage"
      description: |
        Verify that hot paths have performance tests and benchmarks to
        prevent regression.
      duration_estimate: "20 min"

      commands:
        - purpose: "Find performance tests"
          command: "rg -n 'benchmark|perf.*test|load.*test' --type py --type js"

      expected_findings:
        - "Performance test coverage"
        - "Benchmark availability"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Hot Path Identification"
        - "Optimization Opportunities"
        - "Prioritized Recommendations"

  confidence_guidance:
    high: "Profiling data from production with traffic analysis"
    medium: "Load test profiling with traffic estimates"
    low: "Code analysis without profiling data"

offline:
  capability: "partial"

  cache_manifest:
    knowledge:
      - source_id: "profiling-guide"
        priority: "recommended"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires profiling data analysis"
    full:
      included: true
      priority: 1
    production:
      included: true
      priority: 1

closeout_checklist:
  - id: "hot-path-001"
    item: "Hot paths identified from production data"
    level: "CRITICAL"
    verification: "manual"
    verification_notes: "Top endpoints and functions documented with traffic data"
    expected: "Confirmed by reviewer"

  - id: "hot-path-002"
    item: "No blocking I/O in critical hot paths"
    level: "CRITICAL"
    verification: "manual"
    verification_notes: "Hot paths use async I/O or connection pools"
    expected: "Confirmed by reviewer"

  - id: "hot-path-003"
    item: "Hot paths have performance tests"
    level: "BLOCKING"
    verification: "rg -l 'benchmark|perf' && echo PASS || echo NEEDS_REVIEW"
    expected: "PASS"

governance:
  applicable_to:
    archetypes: ["all"]

  compliance_frameworks:
    - framework: "Performance Engineering"
      controls: ["Optimization Strategy"]

relationships:
  commonly_combined:
    - "performance-efficiency.algorithmic-efficiency.time-complexity"
    - "performance-efficiency.performance-measurement.profiling"
    - "performance-efficiency.latency.p99-latency"
