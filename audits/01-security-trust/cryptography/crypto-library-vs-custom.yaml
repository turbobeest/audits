audit:
  id: security-trust.cryptography.crypto-library-vs-custom
  name: Crypto Library vs Custom Implementation Audit
  version: 1.0.0
  last_updated: '2026-01-18'
  status: active
  category: security-trust
  category_number: 1
  subcategory: cryptography
  tier: phd
  estimated_duration: 3 hours
  completeness: complete
  requires_runtime: false
  destructive: false
execution:
  automatable: partial
  severity: critical
  scope: codebase
  default_profiles:
  - full
  - security
  blocks_phase: true
  parallelizable: true
description:
  what: |
    This audit examines the codebase for custom cryptographic implementations
    versus established, peer-reviewed libraries. It identifies instances where
    developers have "rolled their own crypto" - implementing cryptographic
    algorithms, protocols, or primitives from scratch rather than using
    vetted libraries like OpenSSL, Libsodium, Google Tink, or platform APIs.
  why_it_matters: |
    Custom cryptographic implementations are almost always insecure. Even
    expert cryptographers have designed broken algorithms (see Dual_EC_DRBG).
    Cryptography is extremely fragile - minor implementation errors create
    exploitable side-channel attacks, timing vulnerabilities, and data leaks.
    The Zerologon breach and countless others resulted from custom crypto.
    OWASP explicitly states: "Don't roll your own crypto!" A single
    cryptographic weakness can lead to full data breach, credential theft,
    and regulatory violations.
  when_to_run:
  - Initial security audit of any codebase
  - Code review for cryptographic changes
  - When evaluating new cryptographic dependencies
  - Before security compliance certification
  - After developer changes to encryption code
prerequisites:
  required_artifacts:
  - type: source_code
    description: Complete source code including all cryptographic modules
  - type: dependencies
    description: Dependency manifests (package.json, requirements.txt, go.mod)
  access_requirements:
  - Read access to source code repositories
  - Access to dependency management files
discovery:
  code_patterns:
  - pattern: def\s+encrypt|function\s+encrypt|func\s+Encrypt
    type: regex
    scope: source
    purpose: Detect custom encryption function definitions
  - pattern: class\s+.*Cipher|class\s+.*Encrypt|class\s+.*Crypto
    type: regex
    scope: source
    purpose: Detect custom cryptographic classes
  - pattern: \^.*key|key.*\^|xor.*encrypt|encrypt.*xor
    type: regex
    scope: source
    purpose: Detect XOR-based encryption (insecure)
  - pattern: def\s+hash|function\s+hash|func\s+Hash
    type: regex
    scope: source
    purpose: Detect custom hash function definitions
  - pattern: (<<|>>|\^|\|).*crypt|crypt.*(<<|>>|\^|\|)
    type: regex
    scope: source
    purpose: Detect bit manipulation in crypto context (potential custom impl)
  - pattern: def\s+derive.*key|function\s+deriveKey|derivationFunction
    type: regex
    scope: source
    purpose: Detect custom key derivation (should use PBKDF2, Argon2, etc.)
  - pattern: def\s+hmac|function\s+hmac|custom.*mac|homemade.*hash
    type: regex
    scope: source
    purpose: Detect custom MAC implementations
  - pattern: base64.*encrypt|encrypt.*base64|encode.*secret|decode.*secret
    type: regex
    scope: source
    purpose: Detect base64 misused as encryption
  - pattern: from\s+cryptography|import\s+cryptography|crypto/aes|crypto/cipher
    type: regex
    scope: source
    purpose: Detect approved cryptography library usage (Python/Go)
  - pattern: javax\.crypto|java\.security\.cipher
    type: regex
    scope: source
    purpose: Detect Java standard crypto library usage
  - pattern: libsodium|nacl|tweetnacl|sodium
    type: regex
    scope: source
    purpose: Detect Libsodium/NaCl usage (recommended)
  - pattern: tink|google\.crypto\.tink
    type: regex
    scope: source
    purpose: Detect Google Tink usage (recommended)
  - pattern: crypto\.subtle|WebCrypto
    type: regex
    scope: source
    purpose: Detect Web Crypto API usage
  file_patterns:
  - glob: '**/*crypt*.py'
    purpose: Python cryptography modules
  - glob: '**/*crypt*.js'
    purpose: JavaScript cryptography modules
  - glob: '**/*crypt*.java'
    purpose: Java cryptography modules
  - glob: '**/*crypt*.go'
    purpose: Go cryptography modules
  - glob: '**/*cipher*.py'
    purpose: Cipher-related Python modules
  - glob: '**/*hash*.py'
    purpose: Hash-related Python modules
  - glob: '**/encryption/**'
    purpose: Encryption directories
  - glob: '**/crypto/**'
    purpose: Crypto directories
knowledge_sources:
  specifications:
  - id: nist-sp-800-175b
    name: 'NIST SP 800-175B: Guideline for Using Cryptographic Standards'
    url: https://csrc.nist.gov/pubs/sp/800/175/b/r1/final
    offline_cache: true
    priority: required
  - id: nist-800-53
    name: NIST SP 800-53 Security and Privacy Controls
    url: https://csrc.nist.gov/publications/detail/sp/800-53/rev-5/final
    offline_cache: true
    priority: required
  - id: owasp-asvs
    name: OWASP Application Security Verification Standard
    url: https://owasp.org/www-project-application-security-verification-standard/
    offline_cache: true
    priority: required
  guides:
  - id: owasp-crypto-practices
    name: 'OWASP Developer Guide: Cryptographic Practices'
    url: https://owasp.org/www-project-developer-guide/draft/appendices/implementation_dos_donts/cryptographic_practices/
    offline_cache: true
  - id: owasp-crypto-storage
    name: OWASP Cryptographic Storage Cheat Sheet
    url: https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html
    offline_cache: true
  - id: owasp-proactive-c2
    name: 'OWASP Proactive Controls: Use Cryptography to Protect Data'
    url: https://top10proactive.owasp.org/the-top-10/c2-crypto/
    offline_cache: true
  - id: owasp-mobile-m10
    name: 'OWASP Mobile Top 10: Insufficient Cryptography'
    url: https://owasp.org/www-project-mobile-top-10/2023-risks/m10-insufficient-cryptography
    offline_cache: true
  - id: cwe-327
    name: 'CWE-327: Use of a Broken or Risky Cryptographic Algorithm'
    url: https://cwe.mitre.org/data/definitions/327.html
    offline_cache: true
  - id: cwe-329
    name: 'CWE-329: Generation of Predictable IV with CBC Mode'
    url: https://cwe.mitre.org/data/definitions/329.html
    offline_cache: true
  learning_resources:
  - id: google-tink
    title: Google Tink Cryptographic Library
    type: article
    reference: https://github.com/google/tink
  - id: libsodium
    title: 'Libsodium: Easy-to-use Cryptography'
    type: article
    reference: https://doc.libsodium.org/
tooling:
  static_analysis:
  - tool: semgrep
    purpose: Detect custom crypto patterns and insecure implementations
    offline_capable: true
  - tool: bandit
    purpose: Python security linter with crypto checks
    offline_capable: true
  - tool: gosec
    purpose: Go security scanner for crypto issues
    offline_capable: true
  - tool: eslint-plugin-security
    purpose: JavaScript security linting
    offline_capable: true
  scripts:
  - id: detect-custom-crypto
    language: bash
    purpose: Detect potential custom cryptographic implementations
    source: inline
    code: |
      #!/bin/bash
      echo "=== Custom Cryptography Detection ==="

      echo "--- Custom encrypt/decrypt functions ---"
      grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
        -E "(def|function|func)\s+(encrypt|decrypt|cipher|hash)" . 2>/dev/null | head -30 || echo "None found"

      echo "--- XOR-based encryption ---"
      grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
        -E "(\^.*key|key.*\^|xor.*crypt|crypt.*xor)" . 2>/dev/null | head -20 || echo "None found"

      echo "--- Custom crypto classes ---"
      grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
        -E "class\s+.*(Cipher|Crypto|Encrypt|Decrypt|Hash)" . 2>/dev/null | head -20 || echo "None found"

      echo "--- Base64 as encryption ---"
      grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
        -E "(base64|b64).*(encrypt|secret|password)" . 2>/dev/null | head -20 || echo "None found"
  - id: verify-crypto-libraries
    language: bash
    purpose: Verify approved cryptographic libraries are in use
    source: inline
    code: |
      #!/bin/bash
      echo "=== Approved Crypto Library Verification ==="

      echo "--- Python cryptography/pynacl ---"
      grep -l "from cryptography\|import nacl\|from Crypto" . -r --include="*.py" 2>/dev/null | head -10

      echo "--- Go crypto packages ---"
      grep -l "crypto/\|golang.org/x/crypto" . -r --include="*.go" 2>/dev/null | head -10

      echo "--- Java crypto APIs ---"
      grep -l "javax.crypto\|java.security" . -r --include="*.java" 2>/dev/null | head -10

      echo "--- Node.js crypto ---"
      grep -l "require.*crypto\|from.*crypto\|tweetnacl\|libsodium" . -r --include="*.js" --include="*.ts" 2>/dev/null | head -10
signals:
  critical:
  - id: CUSTOM-CRIT-001
    signal: Custom encryption algorithm implemented
    cwe: CWE-327
    evidence_pattern: (def|function|func)\s+(encrypt|decrypt)\s*\([^)]*\)\s*[:{](?!.*from\s+cryptography|import\s+Crypto)
    explanation: |
      Custom encryption algorithms are almost always insecure. Even expert
      cryptographers have designed broken algorithms. Implementation errors
      lead to side-channel attacks, timing vulnerabilities, and data leaks.
      OWASP explicitly states: "Don't roll your own crypto!"
    remediation: |
      Replace custom encryption with established libraries:
      - Python: cryptography, pynacl, or Google Tink
      - Java: JCA/JCE with Bouncy Castle or Google Tink
      - Go: crypto/aes, crypto/cipher, or nacl
      - JavaScript: Web Crypto API, tweetnacl, or libsodium-wrappers
  - id: CUSTOM-CRIT-002
    signal: XOR-based encryption used
    cwe: CWE-327
    evidence_pattern: (\^|xor).*key.*(encrypt|crypt)|encrypt.*\^|for.*\^.*secret
    explanation: |
      XOR encryption with a static key is trivially broken by frequency
      analysis or known-plaintext attacks. Even with a "random" key, XOR
      ciphers lack authentication and proper key derivation, making them
      vulnerable to practical attacks.
    remediation: |
      Replace XOR encryption with authenticated encryption (AES-GCM or
      ChaCha20-Poly1305) from a vetted library. Never implement encryption
      using basic XOR operations.
  - id: CUSTOM-CRIT-003
    signal: Base64 encoding used as encryption
    cwe: CWE-261
    evidence_pattern: base64.*(encrypt|password|secret|credential)|encode.*(password|secret)
    explanation: |
      Base64 is an encoding, not encryption. It provides zero security -
      anyone can decode base64 trivially. Storing passwords or secrets
      in base64 is equivalent to plaintext storage.
    remediation: |
      Replace base64 "encryption" with proper cryptographic encryption.
      For passwords, use bcrypt, scrypt, or Argon2 hashing.
      For secrets, use AES-GCM encryption with proper key management.
  - id: CUSTOM-CRIT-004
    signal: Custom hash function implemented
    cwe: CWE-328
    evidence_pattern: (def|function|func)\s+hash\s*\([^)]*\)(?!lib|.*hashlib|.*crypto)
    explanation: |
      Custom hash functions lack the mathematical rigor and extensive
      analysis that standard algorithms (SHA-256, SHA-3) have undergone.
      Custom hashes are likely vulnerable to collisions, preimage attacks,
      or extension attacks.
    remediation: |
      Use standard hash functions from approved libraries:
      - SHA-256 or SHA-3 for general hashing
      - bcrypt, scrypt, or Argon2 for password hashing
      - HMAC-SHA256 for message authentication
  high:
  - id: CUSTOM-HIGH-001
    signal: Custom key derivation function
    cwe: CWE-916
    evidence_pattern: (derive|generate).*(key|Key).*(password|Password|secret)
    explanation: |
      Custom key derivation functions typically lack proper salting,
      iteration counts, and memory hardness. This makes derived keys
      vulnerable to rainbow table and brute-force attacks.
    remediation: |
      Use standard key derivation functions:
      - PBKDF2 (minimum 100,000 iterations)
      - scrypt (memory-hard)
      - Argon2 (recommended for new applications)
  - id: CUSTOM-HIGH-002
    signal: Direct block cipher usage without mode
    cwe: CWE-327
    evidence_pattern: AES\s*\(|Cipher\.getInstance\(["']AES["']\)
    explanation: |
      Using block ciphers without specifying a mode of operation
      defaults to ECB mode, which leaks patterns in encrypted data
      (the infamous "ECB penguin" vulnerability).
    remediation: |
      Always specify an authenticated encryption mode:
      - AES-GCM (recommended)
      - ChaCha20-Poly1305
      Never use ECB mode. Avoid CBC without authentication.
  - id: CUSTOM-HIGH-003
    signal: Custom random number generation for crypto
    cwe: CWE-338
    evidence_pattern: (random|Random).*(key|Key|iv|IV|nonce|secret)
    explanation: |
      Using non-cryptographic PRNGs (random.random, Math.random) for
      keys, IVs, or nonces produces predictable values that can be
      guessed by attackers.
    remediation: |
      Use cryptographically secure random generators:
      - Python: secrets module or os.urandom()
      - Java: SecureRandom
      - Go: crypto/rand
      - JavaScript: crypto.randomBytes() or crypto.getRandomValues()
  - id: CUSTOM-HIGH-004
    signal: Hardcoded IV or nonce
    cwe: CWE-329
    evidence_pattern: (iv|IV|nonce|NONCE)\s*[=:]\s*["'][A-Za-z0-9+/=]{8,}["']
    explanation: |
      Hardcoded IVs/nonces defeat their purpose of ensuring ciphertext
      uniqueness. Reusing IVs with the same key, especially in GCM mode,
      completely breaks confidentiality and authenticity.
    remediation: |
      Generate unique IVs/nonces for each encryption operation using
      cryptographically secure random generators. For GCM, never reuse
      nonces with the same key.
  medium:
  - id: CUSTOM-MED-001
    signal: Deprecated crypto library in use
    cwe: CWE-327
    evidence_pattern: from\s+Crypto\.|import\s+Crypto\.
    explanation: |
      PyCrypto is deprecated and has known vulnerabilities. While not
      custom crypto, using unmaintained libraries introduces risk.
    remediation: |
      Migrate from PyCrypto to the maintained 'cryptography' library
      or PyCryptodome (a PyCrypto fork with security fixes).
  - id: CUSTOM-MED-002
    signal: Cryptographic operations in utility files
    evidence_pattern: (util|helper|common).*(encrypt|decrypt|hash|cipher)
    explanation: |
      Crypto scattered in utility files suggests ad-hoc implementation
      without centralized security review. This increases the risk of
      inconsistent or insecure implementations.
    remediation: |
      Centralize cryptographic operations in dedicated, well-reviewed
      modules. Use a crypto service layer that wraps approved libraries.
  - id: CUSTOM-MED-003
    signal: No explicit crypto library dependency
    evidence_indicators:
    - No cryptography library in requirements.txt/package.json
    - Crypto code present without library imports
    explanation: |
      Cryptographic code without explicit library dependencies suggests
      custom implementation or reliance on undocumented internals.
    remediation: |
      Add approved cryptographic libraries to dependencies and ensure
      all crypto code uses them.
  low:
  - id: CUSTOM-LOW-001
    signal: Crypto code without peer review annotation
    evidence_indicators:
    - No security review comments in crypto files
    - No audit trail for crypto changes
    explanation: |
      Cryptographic code requires expert review. Lack of review markers
      suggests potential oversight.
    remediation: |
      Implement mandatory security review for all crypto-related changes.
      Document review in code comments or PR history.
  positive:
  - id: CUSTOM-POS-001
    signal: Approved cryptographic library in use
    evidence_pattern: (cryptography|nacl|libsodium|tink|WebCrypto|javax\.crypto)
    explanation: |
      The codebase uses established, peer-reviewed cryptographic libraries
      as recommended by OWASP and security best practices.
  - id: CUSTOM-POS-002
    signal: Centralized crypto service/module
    evidence_pattern: (CryptoService|CryptoProvider|crypto_utils|encryption_service)
    explanation: |
      A centralized cryptographic service promotes consistent usage
      and simplifies security review.
  - id: CUSTOM-POS-003
    signal: High-level crypto API usage (Fernet, Tink)
    evidence_pattern: (Fernet|MultiFernet|KeysetHandle|Aead|DeterministicAead)
    explanation: |
      High-level APIs like Fernet and Tink provide secure defaults
      and make it harder to misuse cryptography.
procedure:
  context:
    cognitive_mode: critical
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Identify all cryptographic code
    description: |
      Search for all files and functions related to cryptography,
      encryption, hashing, and key management.
    duration_estimate: 30 min
    commands:
    - purpose: Find crypto-related files
      command: |
        find . -name "*crypt*" -o -name "*cipher*" -o -name "*encrypt*" -o -name "*hash*" 2>/dev/null | grep -v node_modules | grep -v __pycache__
    - purpose: Find crypto function definitions
      command: |
        grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
          -E "(def|function|func)\s+(encrypt|decrypt|hash|cipher|derive)" . 2>/dev/null | head -50
    expected_findings:
    - Inventory of all cryptographic code locations
    - Initial assessment of custom vs library usage
  - id: '2'
    name: Verify library usage
    description: |
      Check that cryptographic operations use approved libraries
      rather than custom implementations.
    duration_estimate: 30 min
    commands:
    - purpose: Check for approved library imports
      command: |
        grep -rn --include="*.py" "from cryptography\|import nacl\|from Crypto\|import hashlib" . 2>/dev/null | head -30
    - purpose: Check dependencies for crypto libraries
      command: |
        cat requirements.txt package.json go.mod Gemfile 2>/dev/null | grep -i "crypto\|nacl\|sodium\|tink"
    expected_findings:
    - Verification of approved library usage
    - Dependencies including crypto libraries
  - id: '3'
    name: Detect custom implementations
    description: |
      Search for patterns indicating custom cryptographic
      implementations that should be replaced.
    duration_estimate: 45 min
    commands:
    - purpose: Find XOR encryption
      command: |
        grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
          -E "(\^|xor).*(key|crypt)|for.*\^.*byte" . 2>/dev/null | head -20
    - purpose: Find base64 as encryption
      command: |
        grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
          -E "(base64|b64).*(encrypt|password|secret)" . 2>/dev/null | head -20
    - purpose: Find custom hash functions
      command: |
        grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
          -E "def\s+hash\s*\(|function\s+hash\s*\(" . 2>/dev/null | head -20
    expected_findings:
    - Custom crypto implementations identified
    - Risk assessment for each finding
  - id: '4'
    name: Review crypto configurations
    description: |
      Verify that cryptographic parameters (algorithms, key sizes,
      modes) are properly configured.
    duration_estimate: 30 min
    commands:
    - purpose: Check for ECB mode usage
      command: |
        grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
          -E "(ECB|MODE_ECB)" . 2>/dev/null
    - purpose: Check for hardcoded IVs
      command: |
        grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
          -E "(iv|IV|nonce)\s*[=:]\s*[\"'][A-Za-z0-9+/=]+[\"']" . 2>/dev/null | head -20
    expected_findings:
    - Cryptographic configuration issues
    - Hardcoded parameters identified
  - id: '5'
    name: Run static analysis
    description: |
      Execute security-focused static analysis tools to catch
      additional cryptographic issues.
    duration_estimate: 30 min
    commands:
    - purpose: Run Semgrep crypto rules
      command: |
        semgrep --config=p/security-audit --config=p/secrets . 2>/dev/null | head -100 || echo "Semgrep not available"
    - purpose: Run Bandit for Python
      command: |
        bandit -r . -f json 2>/dev/null | jq '.results[] | select(.issue_text | contains("crypto") or contains("hash"))' | head -50 || echo "Bandit not available"
    expected_findings:
    - Static analysis crypto findings
    - Additional vulnerabilities from tooling
output:
  deliverables:
  - type: finding_list
    format: structured
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Custom Implementation Findings
    - Library Usage Assessment
    - Configuration Issues
    - Remediation Roadmap
  confidence_guidance:
    high: Direct evidence of custom crypto implementation
    medium: Patterns suggest custom crypto, needs code review
    low: Potential issues based on file names or structure
offline:
  capability: full
  cache_manifest:
    knowledge:
    - source_id: owasp-crypto-practices
      priority: required
    - source_id: cwe-327
      priority: required
profiles:
  membership:
    quick:
      included: true
      reason: Custom crypto is critical enough to check in quick scans
      priority: 1
    full:
      included: true
      priority: 1
    security:
      included: true
      priority: 1
closeout_checklist:
- id: custom-001
  item: No custom encryption algorithm implementations
  level: CRITICAL
  verification: |
    ! grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
      -E "def\s+encrypt\s*\(|function\s+encrypt\s*\(|func\s+Encrypt" . 2>/dev/null | \
      grep -v "test\|mock\|example" | grep -v "cryptography\|crypto\.|Crypto\." && echo "PASS" || echo "NEEDS_REVIEW"
  expected: PASS
- id: custom-002
  item: No XOR-based encryption
  level: CRITICAL
  verification: |
    ! grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
      -E "(\^|xor).*(key|crypt|encrypt)" . 2>/dev/null | grep -v test && echo "PASS" || echo "FAIL"
  expected: PASS
- id: custom-003
  item: No base64 used as encryption
  level: CRITICAL
  verification: |
    ! grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
      -E "(base64|b64).*(encrypt|password|secret)" . 2>/dev/null | grep -v test && echo "PASS" || echo "FAIL"
  expected: PASS
- id: custom-004
  item: Approved cryptographic library in dependencies
  level: BLOCKING
  verification: |
    cat requirements.txt package.json go.mod 2>/dev/null | grep -qi "cryptography\|nacl\|sodium\|tink\|crypto" && echo "PASS" || echo "NEEDS_REVIEW"
  expected: PASS
- id: custom-005
  item: No ECB mode encryption
  level: BLOCKING
  verification: |
    ! grep -rn --include="*.py" --include="*.js" --include="*.java" --include="*.go" \
      -E "(ECB|MODE_ECB)" . 2>/dev/null | grep -v test && echo "PASS" || echo "FAIL"
  expected: PASS
governance:
  applicable_to:
    archetypes:
    - all
  compliance_frameworks:
  - framework: OWASP Top 10
    controls:
    - A02:2021 - Cryptographic Failures
  - framework: OWASP Proactive Controls
    controls:
    - C2 - Use Cryptography to Protect Data
  - framework: CWE
    controls:
    - CWE-327
    - CWE-328
    - CWE-329
    - CWE-338
    - CWE-261
  - framework: OWASP Mobile Top 10
    controls:
    - M10 - Insufficient Cryptography
  - framework: PCI DSS
    controls:
    - 6.5.3
    - 6.5.4
relationships:
  commonly_combined:
  - security-trust.cryptography.cryptographic-agility
  - security-trust.cryptography.random-number-generation
  - security-trust.cryptography.key-rotation
