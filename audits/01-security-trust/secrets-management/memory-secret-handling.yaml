audit:
  id: security-trust.secrets-management.memory-secret-handling
  name: Memory Secret Handling Audit
  version: 1.0.0
  last_updated: '2026-01-18'
  status: active
  category: security-trust
  category_number: 1
  subcategory: secrets-management
  tier: phd
  estimated_duration: 2 hours
  completeness: complete
  requires_runtime: false
  destructive: false
execution:
  automatable: partial
  severity: high
  scope: codebase
  default_profiles:
  - full
  - security
  blocks_phase: false
  parallelizable: true
description:
  what: |
    This audit examines how secrets are handled in memory including secure
    allocation, zeroization after use, protection against memory dumps, and
    prevention of swap file exposure. It covers cryptographic key handling,
    password storage in memory, and sensitive data lifecycle management in
    applications written in C/C++, Java, Go, Rust, and other languages.
  why_it_matters: |
    CWE-316 (Cleartext Storage of Sensitive Information in Memory) addresses
    the risk of secrets persisting in memory after use. Memory can be accessed
    through core dumps, swap files, memory forensics, or cold boot attacks.
    CERT C Secure Coding Standard MSC18-C requires careful handling of sensitive
    data in program memory. High-security environments require HSM or TEE for
    cryptographic operations.
  when_to_run:
  - When implementing cryptographic operations
  - During security reviews of authentication systems
  - For applications handling financial or healthcare data
  - When deploying in untrusted environments
prerequisites:
  required_artifacts:
  - type: source_code
    description: Application source code handling secrets and cryptographic operations
  access_requirements:
  - Read access to application source code
  - Access to cryptographic library usage patterns
discovery:
  code_patterns:
  - pattern: SecureString|SecureZeroMemory|explicit_bzero|memset_s
    type: regex
    scope: source
    purpose: Secure memory clearing functions
  - pattern: mlock|mprotect|VirtualLock|CryptProtectMemory
    type: regex
    scope: source
    purpose: Memory protection primitives
  - pattern: password.*=.*String|key.*=.*String|secret.*=.*string
    type: regex
    scope: source
    purpose: Immutable strings for sensitive data
  - pattern: Arrays\.fill|memset.*password|bzero
    type: regex
    scope: source
    purpose: Memory clearing attempts
  file_patterns:
  - glob: '**/*.{c,cpp,h,hpp}'
    purpose: C/C++ source files
  - glob: '**/*.{java,kt}'
    purpose: Java/Kotlin source files
  - glob: '**/*.{go,rs}'
    purpose: Go/Rust source files
  - glob: '**/crypto/**'
    purpose: Cryptography-related code
  - glob: '**/auth/**'
    purpose: Authentication-related code
knowledge_sources:
  specifications:
  - id: cwe-316
    name: 'CWE-316: Cleartext Storage of Sensitive Information in Memory'
    url: https://cwe.mitre.org/data/definitions/316.html
    offline_cache: true
    priority: required
  - id: cert-msc18-c
    name: 'CERT C MSC18-C: Handle Sensitive Data in Memory'
    url: https://wiki.sei.cmu.edu/confluence/display/c/MSC18-C.+Be+careful+while+handling+sensitive+data%2C+such+as+passwords%2C+in+program+code
    offline_cache: true
    priority: required
  - id: nist-800-53
    name: NIST SP 800-53 Security and Privacy Controls
    url: https://csrc.nist.gov/publications/detail/sp/800-53/rev-5/final
    offline_cache: true
    priority: required
  - id: owasp-asvs
    name: OWASP Application Security Verification Standard
    url: https://owasp.org/www-project-application-security-verification-standard/
    offline_cache: true
    priority: required
  guides:
  - id: owasp-cryptographic-storage
    name: OWASP Cryptographic Storage Cheat Sheet
    url: https://cheatsheetseries.owasp.org/cheatsheets/Cryptographic_Storage_Cheat_Sheet.html
    offline_cache: true
  - id: embedded-appsec-secrets
    name: Embedded Application Security - Securing Sensitive Information
    url: https://scriptingxss.gitbook.io/embedded-appsec-best-practices/4_securing_sensitive_information
    offline_cache: true
tooling:
  static_analysis:
  - tool: semgrep
    purpose: Detect insecure memory handling patterns
    offline_capable: true
  - tool: cppcheck
    purpose: C/C++ memory security analysis
    offline_capable: true
  - tool: spotbugs
    purpose: Java security analysis including memory handling
    offline_capable: true
  scripts:
  - id: memory-handling-scan
    language: bash
    purpose: Scan for memory secret handling issues
    source: inline
    code: |
      #!/bin/bash
      echo "=== Scanning for Memory Secret Handling Issues ==="

      # Check for immutable strings with secrets (Java)
      grep -rn --include="*.java" 'String.*password\|String.*secret' . 2>/dev/null | head -20

      # Check for missing memory clearing (C/C++)
      grep -rn --include="*.c" --include="*.cpp" 'password\|secret\|key' . 2>/dev/null | \
        grep -v 'memset\|bzero\|SecureZeroMemory' | head -20

      # Check for secure allocation usage
      grep -rn 'mlock\|SecureString\|explicit_bzero' . 2>/dev/null | head -20
signals:
  critical:
  - id: MEM-CRIT-001
    signal: Secrets stored in immutable strings without clearing
    evidence_pattern: String\s+password|String\s+secret|const.*char.*password
    explanation: |
      In Java, String objects are immutable and cannot be cleared from memory.
      The JVM may retain password strings until garbage collection. In C/C++,
      const char* prevents clearing. CWE-316.
    remediation: Use char[] in Java, mutable buffers in C/C++, clear immediately after use
    cwe: CWE-316
  - id: MEM-CRIT-002
    signal: Missing secret zeroization after use
    evidence_pattern: password.*=.*null|secret.*=.*undefined|key.*=.*None
    explanation: |
      Setting a variable to null does not clear the memory - the original
      data remains until overwritten. Explicit zeroization is required. CWE-316.
    remediation: Use SecureZeroMemory/explicit_bzero/memset_s before nullifying
    cwe: CWE-316
  - id: MEM-CRIT-003
    signal: Compiler may optimize away memset
    evidence_pattern: memset\(.*password.*0|memset\(.*key.*0
    explanation: |
      Standard memset() can be optimized away by compilers when the buffer
      is not subsequently used. Use memset_s, SecureZeroMemory, or
      explicit_bzero instead. CWE-14.
    remediation: Use memset_s, explicit_bzero, SecureZeroMemory, or volatile function pointers
    cwe: CWE-14
  high:
  - id: MEM-HIGH-001
    signal: Memory not protected from swap
    evidence_pattern: password|secret|key
    explanation: |
      Sensitive data in unpinned memory can be swapped to disk where it
      may persist indefinitely and be recovered by attackers. CWE-591.
    remediation: Use mlock() to pin sensitive pages, or use TEE/HSM
    cwe: CWE-591
  - id: MEM-HIGH-002
    signal: Core dumps enabled with sensitive data in memory
    explanation: |
      Core dumps capture full process memory including secrets. If not
      disabled or filtered, secrets persist in dump files. CWE-316.
    remediation: Disable core dumps for sensitive processes, or use prctl(PR_SET_DUMPABLE, 0)
    cwe: CWE-316
  - id: MEM-HIGH-003
    signal: Cryptographic keys held in user-space memory
    evidence_pattern: private.?key.*=|secret.?key.*=|aes.?key.*=
    explanation: |
      Cryptographic keys in user-space memory are vulnerable to extraction
      via memory attacks. High-security applications should use HSM or
      kernel crypto subsystems. CWE-522.
    remediation: Use HSM, kernel keyring, or TEE for key operations
    cwe: CWE-522
  medium:
  - id: MEM-MED-001
    signal: No secure memory allocation for secrets
    explanation: |
      Standard malloc does not provide protection against memory disclosure.
      Secure allocators provide guard pages and zeroization. CWE-316.
    remediation: Use secure allocators like libsodium sodium_malloc()
    cwe: CWE-316
  - id: MEM-MED-002
    signal: Secrets passed as function parameters
    evidence_pattern: function.*password|def.*secret|void.*key
    explanation: |
      Function parameters may be passed via registers or stack which can
      retain copies. Prefer passing pointers to secret buffers.
    remediation: Pass pointers to secret buffers, clear after use
  - id: MEM-MED-003
    signal: Garbage collection delay for secret clearing
    explanation: |
      In garbage-collected languages, secrets remain in memory until GC
      runs. Explicit clearing mechanisms should be used. CWE-316.
    remediation: Use explicit clearing with Arrays.fill() before dereferencing
    cwe: CWE-316
  positive:
  - id: MEM-POS-001
    signal: SecureString/SecureZeroMemory in use
  - id: MEM-POS-002
    signal: Memory locking (mlock) for sensitive data
  - id: MEM-POS-003
    signal: HSM or TEE integration for cryptographic keys
  - id: MEM-POS-004
    signal: Explicit zeroization with compiler-safe functions
procedure:
  context:
    cognitive_mode: critical
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Identify secret handling code
    description: |
      Locate code that handles passwords, cryptographic keys,
      tokens, and other sensitive data.
    duration_estimate: 20 min
    commands:
    - purpose: Find password handling
      command: grep -rn --include='*.{c,cpp,java,go,rs,py,js,ts}' -iE 'password|passwd|pwd' . 2>/dev/null
        | grep -v test | grep -v node_modules | head -30
    - purpose: Find key handling
      command: grep -rn --include='*.{c,cpp,java,go,rs,py,js,ts}' -iE 'private.?key|secret.?key|aes.?key|crypto.*key'
        . 2>/dev/null | grep -v test | grep -v node_modules | head -30
    - purpose: Find token handling
      command: grep -rn --include='*.{c,cpp,java,go,rs,py,js,ts}' -iE 'access.?token|api.?token|jwt' .
        2>/dev/null | grep -v test | grep -v node_modules | head -30
    expected_findings:
    - Secret handling locations
    - Types of secrets managed
  - id: '2'
    name: Check memory clearing practices
    description: |
      Examine how secrets are cleared from memory after use.
    duration_estimate: 25 min
    commands:
    - purpose: Find secure clearing functions
      command: grep -rn 'SecureZeroMemory\|explicit_bzero\|memset_s\|sodium_memzero' . 2>/dev/null | head
        -20
    - purpose: Find standard memset (potentially unsafe)
      command: grep -rn 'memset.*0.*password\|memset.*0.*key\|memset.*0.*secret' . 2>/dev/null | head
        -20
    - purpose: Find Java char[] clearing
      command: grep -rn --include='*.java' 'Arrays\.fill.*password\|Arrays\.fill.*key' . 2>/dev/null |
        head -20
    expected_findings:
    - Memory clearing implementations
    - Potentially unsafe clearing patterns
  - id: '3'
    name: Analyze string usage for secrets
    description: |
      Check whether immutable strings are used for secrets
      instead of mutable buffers.
    duration_estimate: 20 min
    commands:
    - purpose: Find String for passwords in Java
      command: grep -rn --include='*.java' 'String.*password\|String.*secret' . 2>/dev/null | grep -v
        test | head -20
    - purpose: Find const char* for secrets in C/C++
      command: grep -rn --include='*.c' --include='*.cpp' 'const.*char.*password\|const.*char.*secret'
        . 2>/dev/null | head -20
    - purpose: Check for char[] password usage (good)
      command: grep -rn --include='*.java' 'char\[\].*password\|password.*char\[' . 2>/dev/null | head
        -20
    expected_findings:
    - Immutable string usage for secrets
    - Proper buffer usage
  - id: '4'
    name: Check memory protection
    description: |
      Verify whether memory pages containing secrets are
      protected from swapping.
    duration_estimate: 20 min
    commands:
    - purpose: Find mlock usage
      command: grep -rn 'mlock\|VirtualLock\|mlockall' . 2>/dev/null | head -20
    - purpose: Find mprotect usage
      command: grep -rn 'mprotect\|VirtualProtect' . 2>/dev/null | head -20
    - purpose: Check for core dump prevention
      command: grep -rn 'PR_SET_DUMPABLE\|setrlimit.*RLIMIT_CORE\|dumpable' . 2>/dev/null | head -20
    expected_findings:
    - Memory locking usage
    - Core dump configuration
  - id: '5'
    name: Evaluate HSM/TEE integration
    description: |
      Check for hardware security module or trusted execution
      environment usage for cryptographic operations.
    duration_estimate: 15 min
    commands:
    - purpose: Find HSM integration
      command: grep -rn -iE 'hsm|pkcs11\|softhsm\|luna\|thales' . 2>/dev/null | head -20
    - purpose: Find TEE/enclave usage
      command: grep -rn -iE 'enclave\|sgx\|trustzone\|tee' . 2>/dev/null | head -20
    - purpose: Find kernel keyring usage
      command: grep -rn 'keyctl\|request_key\|add_key' . 2>/dev/null | head -10
    expected_findings:
    - HSM integration
    - TEE/enclave usage
output:
  deliverables:
  - type: finding_list
    format: structured
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Memory Clearing Assessment
    - String Usage Issues
    - Memory Protection Status
    - Recommendations
  confidence_guidance:
    high: Direct evidence of unsafe memory handling for secrets
    medium: Patterns that could lead to memory exposure
    low: Concerns requiring runtime or compiler analysis
offline:
  capability: full
  cache_manifest:
    knowledge:
    - source_id: cwe-316
      priority: required
    - source_id: cert-msc18-c
      priority: required
profiles:
  membership:
    quick:
      included: false
      reason: Requires detailed code analysis
    full:
      included: true
      priority: 1
    security:
      included: true
      priority: 1
closeout_checklist:
- id: memory-secret-handling-001
  item: No Java String for passwords
  level: CRITICAL
  verification: grep -rn --include='*.java' 'String.*password\|password.*String' . 2>/dev/null | grep
    -v test | wc -l | xargs -I {} test {} -eq 0 && echo PASS || echo FAIL
  expected: PASS
- id: memory-secret-handling-002
  item: Secure memory clearing in use
  level: CRITICAL
  verification: grep -rn 'SecureZeroMemory\|explicit_bzero\|memset_s\|Arrays\.fill' . 2>/dev/null | head
    -1 | grep -q . && echo PASS || echo FAIL
  expected: PASS
- id: memory-secret-handling-003
  item: Memory locking for sensitive data
  level: BLOCKING
  verification: manual
  verification_notes: Verify mlock or equivalent is used for sensitive memory pages
  expected: Confirmed by reviewer
- id: memory-secret-handling-004
  item: Core dumps disabled or filtered
  level: WARNING
  verification: grep -rn 'PR_SET_DUMPABLE\|RLIMIT_CORE' . 2>/dev/null | head -1 | grep -q . && echo PASS
    || echo FAIL
  expected: PASS
governance:
  applicable_to:
    archetypes:
    - security-critical
    - financial
    - healthcare
  compliance_frameworks:
  - framework: CWE
    controls:
    - CWE-316
    - CWE-14
    - CWE-522
  - framework: CERT C
    controls:
    - MSC18-C
  - framework: PCI-DSS
    controls:
    - '3.2'
    - '3.4'
  - framework: FIPS 140-2
    controls:
    - Key Management
relationships:
  commonly_combined:
  - security-trust.secrets-management.secret-storage
  - security-trust.cryptography.key-management
  - security-trust.data-protection.encryption
