# ============================================================
# AUDIT: Versioning Strategy Assessment
# ============================================================
# Evaluates API versioning approach and implementation
# ============================================================

audit:
  id: "api-integration.versioning.versioning-strategy"

  name: "Versioning Strategy Assessment"

  version: "1.0.0"
  last_updated: "2026-01-18"
  status: "active"

  category: "api-integration"
  category_number: 9
  subcategory: "versioning"

  tier: "expert"
  estimated_duration: "2 hours"

  completeness: "complete"
  requires_runtime: false
  destructive: false

execution:
  automatable: "partial"
  severity: "high"
  scope: "codebase"

  default_profiles:
    - "full"
    - "production"

  parallelizable: true

description:
  what: |
    Evaluates API versioning strategy including the chosen approach (URL path,
    header, query parameter, content negotiation), consistency of implementation,
    version format (semantic versioning, date-based, etc.), and alignment with
    API evolution needs.

  why_it_matters: |
    A clear versioning strategy enables API evolution without breaking existing
    consumers. Without versioning, every change risks breaking clients. Poor
    versioning leads to version explosion, consumer confusion, and difficult
    maintenance.

  when_to_run:
    - "During API architecture design"
    - "Before implementing versioning changes"
    - "When consolidating multiple APIs"
    - "During API governance setup"

prerequisites:
  required_artifacts:
    - type: "api-source"
      description: "API route definitions"
    - type: "api-spec"
      description: "OpenAPI specifications"

  access_requirements:
    - "Read access to API source code"
    - "Access to API documentation"

discovery:
  code_patterns:
    - pattern: "/v[0-9]+/|/api/v[0-9]+"
      type: "regex"
      scope: "source"
      purpose: "URL path versioning"
    - pattern: "api-version|X-API-Version|Accept-Version"
      type: "regex"
      scope: "source"
      purpose: "Header-based versioning"
    - pattern: "version=|api_version="
      type: "regex"
      scope: "source"
      purpose: "Query parameter versioning"
    - pattern: "application/vnd\\.[^+]+\\+json"
      type: "regex"
      scope: "source"
      purpose: "Content negotiation versioning"

  file_patterns:
    - glob: "**/routes/**/*.{java,ts,py}"
      purpose: "Route definitions"
    - glob: "**/*openapi*.{yaml,yml,json}"
      purpose: "OpenAPI specifications"
    - glob: "**/controllers/**/*.{java,ts,py}"
      purpose: "Controller implementations"

knowledge_sources:
  guides:
    - id: "api-versioning-guide"
      name: "API Versioning Best Practices"
      url: "https://cloud.google.com/apis/design/versioning"
      offline_cache: true
    - id: "roy-fielding-versioning"
      name: "REST API Versioning - Roy Fielding"
      url: "https://www.infoq.com/articles/roy-fielding-on-versioning/"
      offline_cache: true

  specifications:
    - id: "semver"
      name: "Semantic Versioning 2.0.0"
      url: "https://semver.org/"
      offline_cache: true
      priority: "required"

tooling:
  static_analysis:
    - tool: "spectral"
      purpose: "Check version in OpenAPI"
      offline_capable: true

signals:
  critical:
    - id: "VERSION-CRIT-001"
      signal: "No versioning strategy implemented"
      evidence_indicators:
        - "No version in URL paths"
        - "No version headers accepted"
        - "Single unversioned API"
      explanation: |
        Without versioning, any breaking change affects all consumers
        simultaneously. There's no way to evolve the API without coordinated
        consumer updates.
      remediation: "Implement versioning (URL path is most common: /v1/users)"

    - id: "VERSION-CRIT-002"
      signal: "Multiple conflicting versioning schemes"
      evidence_pattern: "/v[0-9].*api-version|version=.*X-API-Version"
      explanation: |
        Using multiple versioning schemes (e.g., URL and header simultaneously
        with different values) confuses consumers and complicates routing.
      remediation: "Standardize on a single versioning approach"

  high:
    - id: "VERSION-HIGH-001"
      signal: "Version in URL but no routing logic"
      evidence_pattern: "/v[0-9].*(?!router|route|mapping)"
      explanation: |
        Version in URL without proper routing means version parameter is
        ignored, giving false impression of version support.
      remediation: "Implement version-aware routing or remove version from URLs"

    - id: "VERSION-HIGH-002"
      signal: "Inconsistent version format across endpoints"
      evidence_pattern: "/v1/.*|/v1\\.0/.*|/version-1/"
      explanation: |
        Inconsistent version formats (v1, v1.0, version-1) make APIs harder
        to use and automate. Consumers must handle multiple formats.
      remediation: "Standardize version format (e.g., v1, v2)"

  medium:
    - id: "VERSION-MED-001"
      signal: "No default version for unversioned requests"
      evidence_indicators:
        - "Unversioned endpoints return 404"
        - "No version default configuration"
      remediation: "Route unversioned requests to latest stable or default version"

    - id: "VERSION-MED-002"
      signal: "Version bump without breaking changes"
      evidence_pattern: "v[0-9].*//.*no.*breaking"
      remediation: "Only bump major version for breaking changes (semantic versioning)"

  low:
    - id: "VERSION-LOW-001"
      signal: "No version documented in OpenAPI spec"
      remediation: "Add version info to OpenAPI specification"

  positive:
    - id: "VERSION-POS-001"
      signal: "Consistent URL path versioning implemented"
    - id: "VERSION-POS-002"
      signal: "Semantic versioning with clear changelog"

procedure:
  context:
    cognitive_mode: "evaluative"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Identify Versioning Approach"
      description: |
        Determine what versioning strategy is in use.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find URL path versions"
          command: "grep -rEo '/v[0-9]+/|/api/v[0-9]+' --include='*.java' --include='*.ts' --include='*.yaml' . | sort -u"
        - purpose: "Find version headers"
          command: "grep -rn 'api-version\\|X-API-Version\\|Accept-Version' --include='*.java' --include='*.ts' --include='*.py' ."
        - purpose: "Find query param versions"
          command: "grep -rn 'version=\\|api_version=' --include='*.java' --include='*.ts' --include='*.py' ."
      expected_findings:
        - "Versioning approach"
        - "Version patterns"

    - id: "2"
      name: "Check Versioning Consistency"
      description: |
        Verify version implementation is consistent across endpoints.
      duration_estimate: "20 min"
      commands:
        - purpose: "List all version patterns"
          command: "grep -rEo '/v[0-9\\.]+/' --include='*.java' --include='*.ts' --include='*.yaml' . | sort | uniq -c | sort -rn"
        - purpose: "Find unversioned endpoints"
          command: "grep -rn '@\\(Get\\|Post\\|Put\\|Delete\\)Mapping\\|app\\.\\(get\\|post\\)' --include='*.java' --include='*.ts' . | grep -v '/v[0-9]' | head -20"
      expected_findings:
        - "Version consistency"
        - "Unversioned endpoints"

    - id: "3"
      name: "Analyze Version Routing"
      description: |
        Check how version routing is implemented.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find version routing logic"
          command: "grep -rn 'version.*route\\|route.*version\\|ApiVersion' --include='*.java' --include='*.ts' ."
        - purpose: "Check for version middleware"
          command: "grep -rn 'version.*middleware\\|middleware.*version' --include='*.java' --include='*.ts' ."
      expected_findings:
        - "Routing implementation"
        - "Version selection logic"

    - id: "4"
      name: "Review Version Documentation"
      description: |
        Check if versioning is documented for consumers.
      duration_estimate: "15 min"
      commands:
        - purpose: "Check OpenAPI version"
          command: "grep -n 'version:' $(find . -name '*openapi*.yaml' | head -1) 2>/dev/null | head -5"
        - purpose: "Find versioning docs"
          command: "grep -rn 'version\\|Version' --include='*.md' . | head -20"
      expected_findings:
        - "Version documentation"
        - "Consumer guidance"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"
    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Versioning Approach"
        - "Implementation Analysis"
        - "Recommendations"

  confidence_guidance:
    high: "Versioning strategy clearly identified and analyzed"
    medium: "Partial versioning found"
    low: "Limited versioning evidence"

offline:
  capability: "full"
  cache_manifest:
    knowledge:
      - source_id: "semver"
        priority: "required"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires architecture analysis"
    full:
      included: true
      priority: 1

closeout_checklist:
  - id: "version-001"
    item: "Versioning strategy is implemented"
    level: "CRITICAL"
    verification: |
      if grep -rEq '/v[0-9]+/|api-version|X-API-Version' --include='*.java' --include='*.ts' --include='*.yaml' . 2>/dev/null; then echo "PASS"; else echo "FAIL"; fi
    expected: "PASS"

  - id: "version-002"
    item: "Single consistent versioning approach"
    level: "BLOCKING"
    verification: "manual"
    verification_notes: "Reviewer confirms one versioning scheme is used consistently"
    expected: "Confirmed by reviewer"

  - id: "version-003"
    item: "All endpoints include version"
    level: "BLOCKING"
    verification: "manual"
    verification_notes: "Reviewer confirms no unversioned public endpoints exist"
    expected: "Confirmed by reviewer"

  - id: "version-004"
    item: "Version format is consistent"
    level: "WARNING"
    verification: |
      formats=$(grep -rEo '/v[0-9]+[\.0-9]*/' --include='*.java' --include='*.ts' --include='*.yaml' . 2>/dev/null | sed 's/[0-9]/#/g' | sort -u | wc -l); if [ "$formats" -le 1 ]; then echo "PASS"; else echo "FAIL"; fi
    expected: "PASS"

governance:
  applicable_to:
    archetypes: ["api-service", "microservice", "platform"]

relationships:
  commonly_combined:
    - "api-integration.versioning.deprecation-communication"
    - "api-integration.versioning.multi-version-support"
    - "api-integration.api-contracts.breaking-change-detection"
