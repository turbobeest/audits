audit:
  id: api-integration.third-party-integration.integration-abstraction
  name: Integration Abstraction Audit
  version: 1.0.0
  last_updated: '2026-01-18'
  status: active
  category: api-integration
  category_number: 9
  subcategory: third-party-integration
  tier: phd
  estimated_duration: 90 minutes
  completeness: complete
  requires_runtime: false
  destructive: false
execution:
  automatable: partial
  severity: medium
  scope: codebase
  default_profiles:
  - full
  - architecture
  blocks_phase: false
  parallelizable: true
description:
  what: |
    Evaluates abstraction layers for third-party integrations including
    interface-based design, adapter patterns, dependency injection,
    testability, and vendor swap capability. Analyzes whether the system
    is properly decoupled from specific vendors.
  why_it_matters: |
    Direct coupling to third-party APIs creates vendor lock-in. Changing
    providers requires changes throughout the codebase. Proper abstraction
    allows swapping providers with minimal code changes, enables testing
    without external dependencies, and isolates integration complexity.
  when_to_run:
  - Architecture reviews
  - Vendor evaluation
  - Before adding new integrations
  - Technical debt assessment
prerequisites:
  required_artifacts:
  - type: source_code
    description: Integration code and interfaces
  - type: architecture
    description: System architecture documentation
  access_requirements:
  - Read access to integration code
  - Access to architecture documentation
discovery:
  code_patterns:
  - pattern: interface|Interface|abstract|Abstract
    type: regex
    scope: source
    purpose: Detect abstraction interfaces
  - pattern: Adapter|Provider|Gateway|Client
    type: regex
    scope: source
    purpose: Detect adapter patterns
  - pattern: inject|Inject|@Injectable|DI|dependency
    type: regex
    scope: source
    purpose: Detect dependency injection
  file_patterns:
  - glob: '**/interfaces/**'
    purpose: Interface definitions
  - glob: '**/adapters/**'
    purpose: Adapter implementations
  - glob: '**/providers/**'
    purpose: Provider implementations
knowledge_sources:
  guides:
  - id: adapter-pattern
    name: Adapter Pattern
    url: https://refactoring.guru/design-patterns/adapter
    offline_cache: true
  - id: hexagonal-architecture
    name: Hexagonal Architecture
    url: https://alistair.cockburn.us/hexagonal-architecture/
    offline_cache: true
  learning_resources:
  - id: clean-architecture
    title: Clean Architecture
    type: book
    reference: Robert C. Martin
tooling:
  static_analysis:
  - tool: dependency-cruiser
    purpose: Analyze module dependencies
    offline_capable: true
  scripts:
  - id: abstraction-scan
    language: bash
    purpose: Analyze abstraction patterns
    source: inline
    code: |
      echo "=== Integration Abstraction Analysis ==="
      echo "--- Interface definitions ---"
      grep -rn "interface\|Interface\|abstract class" \
        --include="*.ts" --include="*.java" . 2>/dev/null | \
        grep -i "service\|provider\|client\|api" | grep -v node_modules | head -30

      echo "--- Adapter implementations ---"
      grep -rn "Adapter\|Provider\|Gateway\|implements" \
        --include="*.ts" --include="*.java" . 2>/dev/null | \
        grep -v node_modules | head -30

      echo "--- Dependency injection ---"
      grep -rn "@Injectable\|@Inject\|inject\|provide" \
        --include="*.ts" --include="*.java" . 2>/dev/null | \
        grep -v node_modules | head -20
signals:
  critical:
  - id: IA-CRIT-001
    signal: Vendor SDK used directly throughout codebase
    evidence_pattern: Stripe/Twilio/etc SDK calls scattered across business logic
    explanation: |
      Direct SDK usage throughout the codebase creates tight coupling.
      Changing vendors requires modifying every usage site. Testing
      requires mocking the SDK at every call site.
    remediation: Create abstraction layer; use interface-based design
  - id: IA-CRIT-002
    signal: Business logic mixed with integration code
    evidence_pattern: Domain logic in same file as API calls
    explanation: |
      Mixing business logic with integration code makes both harder
      to test and maintain. Changes to integration leak into business
      logic and vice versa.
    remediation: Separate business logic from integration concerns
  high:
  - id: IA-HIGH-001
    signal: No interface for third-party capabilities
    evidence_pattern: Concrete implementations without interface
    explanation: |
      Without interfaces, you cannot swap implementations. Testing
      requires the real external service. Mock implementations are
      not possible.
    remediation: Define interfaces for all external capabilities
  - id: IA-HIGH-002
    signal: Multiple integrations for same capability
    evidence_pattern: Different payment providers with duplicate patterns
    explanation: |
      When adding a second provider for the same capability, the lack
      of abstraction becomes painfully obvious. Duplicate patterns
      indicate missing abstraction.
    remediation: Create unified interface for capability, implement adapters
  - id: IA-HIGH-003
    signal: No dependency injection for integrations
    evidence_pattern: New StripeClient() instantiated in business code
    explanation: |
      Hard-coded instantiation prevents configuration-based swapping
      and makes testing difficult. Dependency injection allows
      flexible wiring and test doubles.
    remediation: Use dependency injection for all external clients
  medium:
  - id: IA-MED-001
    signal: Vendor-specific types in domain model
    evidence_pattern: Stripe.Customer in domain entities
    explanation: |
      Vendor types in the domain create coupling. The domain should
      use its own types with adapters translating at boundaries.
    remediation: Map vendor types to domain types at boundaries
  - id: IA-MED-002
    signal: Abstraction too thin
    evidence_pattern: Interface that just mirrors SDK methods
    explanation: |
      A thin wrapper that just delegates to SDK doesn't add value.
      Abstractions should represent capabilities at your domain
      level, not mirror vendor APIs.
    remediation: Design abstraction around business capabilities
  - id: IA-MED-003
    signal: No fake/stub implementations for testing
    evidence_pattern: Tests mock SDK directly
    explanation: |
      Without in-memory implementations, tests require mocking
      specific SDK methods. This is fragile and doesn't test the
      integration logic properly.
    remediation: Create in-memory implementations for testing
  low:
  - id: IA-LOW-001
    signal: Abstraction patterns not documented
    evidence_pattern: No documentation of integration architecture
    remediation: Document abstraction approach and patterns used
  positive:
  - id: IA-POS-001
    signal: Interface-based integration design
    evidence_pattern: PaymentProvider interface with Stripe/Braintree adapters
  - id: IA-POS-002
    signal: Dependency injection throughout
    evidence_pattern: Clients injected via constructor or DI container
  - id: IA-POS-003
    signal: In-memory implementations for testing
    evidence_pattern: FakePaymentProvider used in tests
procedure:
  context:
    cognitive_mode: critical
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Identify Integration Points
    description: |
      Find all third-party integration code.
    duration_estimate: 15 min
    commands:
    - purpose: Find external clients
      command: |
        grep -rn "Client\|SDK\|Api" \
          --include="*.ts" --include="*.java" . 2>/dev/null | \
          grep -i "stripe\|twilio\|aws\|google" | grep -v node_modules | head -30
    expected_findings:
    - Integration points
    - Direct vs abstracted usage
  - id: '2'
    name: Analyze Abstraction Layer
    description: |
      Check for interfaces and adapters.
    duration_estimate: 25 min
    commands:
    - purpose: Find interfaces
      command: |
        grep -rn "interface\|Interface" \
          --include="*.ts" --include="*.java" . 2>/dev/null | \
          grep -i "service\|provider\|client" | grep -v node_modules | head -30
    - purpose: Find adapters
      command: |
        grep -rn "Adapter\|Provider\|Gateway" \
          --include="*.ts" --include="*.java" . 2>/dev/null | \
          grep -v node_modules | head -30
    expected_findings:
    - Abstraction presence
    - Pattern consistency
  - id: '3'
    name: Review Dependency Injection
    description: |
      Check how integrations are wired.
    duration_estimate: 20 min
    commands:
    - purpose: Find DI patterns
      command: |
        grep -rn "@Injectable\|@Inject\|inject\|provide\|useClass" \
          --include="*.ts" --include="*.java" . 2>/dev/null | \
          grep -v node_modules | head -30
    expected_findings:
    - DI usage
    - Wiring approach
  - id: '4'
    name: Check Test Implementations
    description: |
      Look for fake/stub implementations.
    duration_estimate: 15 min
    commands:
    - purpose: Find test doubles
      command: |
        grep -rn "Fake\|Mock\|Stub\|InMemory" \
          --include="*.ts" --include="*.java" . 2>/dev/null | \
          grep -i "provider\|client\|service" | head -30
    expected_findings:
    - Test implementations
    - Testing approach
  - id: '5'
    name: Evaluate Domain Separation
    description: |
      Check if domain is vendor-agnostic.
    duration_estimate: 15 min
    commands:
    - purpose: Find vendor types in domain
      command: |
        grep -rn "Stripe\.\|Twilio\.\|AWS\." \
          --include="*.ts" --include="*.java" . 2>/dev/null | \
          grep -i "domain\|entity\|model" | grep -v node_modules | head -20
    expected_findings:
    - Domain coupling
    - Type boundaries
output:
  deliverables:
  - type: finding_list
    format: structured
    content:
    - integration_inventory
    - abstraction_assessment
    - coupling_analysis
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Abstraction Analysis
    - Coupling Assessment
    - Recommendations
  confidence_guidance:
    high: Clear direct coupling or missing interfaces
    medium: Abstraction exists but quality uncertain
    low: Requires deeper analysis to assess swappability
offline:
  capability: full
  cache_manifest:
    knowledge:
    - source_id: adapter-pattern
      priority: recommended
    - source_id: hexagonal-architecture
      priority: recommended
profiles:
  membership:
    quick:
      included: false
      reason: Requires architecture analysis
    full:
      included: true
      priority: 1
    architecture:
      included: true
      priority: 1
closeout_checklist:
- id: ia-001
  item: Interfaces exist for external capabilities
  level: BLOCKING
  verification: |
    grep -rn "interface\|Interface" \
      --include="*.ts" --include="*.java" . 2>/dev/null | \
      grep -i "service\|provider\|client" | grep -v node_modules | \
      wc -l | xargs -I {} test {} -gt 0 && echo "PASS" || echo "FAIL"
  expected: PASS
- id: ia-002
  item: Dependency injection used for integrations
  level: BLOCKING
  verification: |
    grep -rn "@Injectable\|@Inject\|inject" \
      --include="*.ts" --include="*.java" . 2>/dev/null | \
      grep -v node_modules | wc -l | xargs -I {} test {} -gt 0 && echo "PASS" || echo "FAIL"
  expected: PASS
- id: ia-003
  item: Test implementations available
  level: WARNING
  verification: |
    grep -rn "Fake\|Mock\|InMemory" \
      --include="*.ts" --include="*.java" . 2>/dev/null | \
      grep -i "provider\|client" | wc -l | xargs -I {} test {} -gt 0 && echo "PASS" || echo "FAIL"
  expected: PASS
governance:
  applicable_to:
    archetypes:
    - all
  compliance_frameworks:
  - framework: ISO 25010
    controls:
    - Maintainability
    - Modularity
relationships:
  commonly_combined:
  - api-integration.third-party-integration.third-party-api-dependency
  - architecture-design.modularity.dependency-management
  - code-quality.testability.dependency-injection
