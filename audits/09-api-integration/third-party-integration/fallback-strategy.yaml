# ============================================================
# AUDIT: Fallback Strategy
# ============================================================

audit:
  id: "api-integration.third-party-integration.fallback-strategy"
  name: "Fallback Strategy Audit"
  version: "1.0.0"
  last_updated: "2026-01-18"
  status: "active"

  category: "api-integration"
  category_number: 9
  subcategory: "third-party-integration"

  tier: "expert"
  estimated_duration: "90 minutes"

  completeness: "complete"
  requires_runtime: false
  destructive: false

execution:
  automatable: "partial"
  severity: "high"
  scope: "codebase"

  default_profiles:
    - "full"
    - "reliability"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Evaluates fallback mechanisms for third-party API failures including
    graceful degradation, alternative providers, cached responses,
    default values, and user communication. Analyzes whether the
    system handles external failures gracefully.

  why_it_matters: |
    Third-party APIs will fail - it's a matter of when, not if.
    Without fallback strategies, external failures become your failures.
    Proper fallbacks maintain functionality during outages and provide
    better user experience during degraded service.

  when_to_run:
    - "Reliability assessments"
    - "After third-party outages"
    - "Before critical integrations"
    - "Chaos engineering preparation"

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Integration code with error handling"
    - type: "configuration"
      description: "Fallback configuration"

  access_requirements:
    - "Read access to integration code"
    - "Access to error handling logic"

discovery:
  code_patterns:
    - pattern: "fallback|Fallback|FALLBACK"
      type: "regex"
      scope: "source"
      purpose: "Detect fallback implementations"

    - pattern: "default|backup|alternative"
      type: "regex"
      scope: "source"
      purpose: "Detect backup mechanisms"

    - pattern: "graceful|degrade|degradation"
      type: "regex"
      scope: "source"
      purpose: "Detect graceful degradation"

  file_patterns:
    - glob: "**/fallback/**"
      purpose: "Fallback implementations"
    - glob: "**/error/**"
      purpose: "Error handling"
    - glob: "**/resilience/**"
      purpose: "Resilience patterns"

knowledge_sources:
  guides:
    - id: "graceful-degradation"
      name: "Graceful Degradation Pattern"
      url: "https://docs.microsoft.com/en-us/azure/architecture/patterns/circuit-breaker"
      offline_cache: true

    - id: "fallback-patterns"
      name: "Fallback Patterns"
      url: "https://resilience4j.readme.io/docs/fallback"
      offline_cache: true

  learning_resources:
    - id: "chaos-engineering"
      title: "Chaos Engineering Principles"
      type: "book"
      reference: "Casey Rosenthal - Chaos Engineering"

tooling:
  static_analysis:
    - tool: "semgrep"
      purpose: "Detect missing error handling"
      offline_capable: true

  scripts:
    - id: "fallback-scan"
      language: "bash"
      purpose: "Analyze fallback patterns"
      source: "inline"
      code: |
        echo "=== Fallback Strategy Analysis ==="
        echo "--- Fallback implementations ---"
        grep -rn "fallback\|Fallback" \
          --include="*.ts" --include="*.java" --include="*.py" . 2>/dev/null | \
          grep -v node_modules | head -30

        echo "--- Default/backup values ---"
        grep -rn "default\|backup\|alternative" \
          --include="*.ts" --include="*.java" --include="*.py" . 2>/dev/null | \
          grep -i "api\|service\|provider" | grep -v node_modules | head -20

        echo "--- Circuit breaker ---"
        grep -rn "circuit\|breaker\|CircuitBreaker" \
          --include="*.ts" --include="*.java" --include="*.py" . 2>/dev/null | \
          grep -v node_modules | head -20

signals:
  critical:
    - id: "FS-CRIT-001"
      signal: "No fallback for critical third-party failure"
      evidence_pattern: "Critical API call with no error handling or fallback"
      explanation: |
        When critical third-party APIs have no fallback, their failures
        become your failures. Users see errors instead of degraded
        functionality. A payment provider outage means no sales.
      remediation: "Implement fallback for all critical third-party APIs"

    - id: "FS-CRIT-002"
      signal: "Fallback reveals implementation details"
      evidence_pattern: "Error messages expose vendor names or internal errors"
      explanation: |
        Exposing vendor details in errors helps attackers understand
        your architecture and target specific weaknesses. It also
        creates poor user experience.
      remediation: "Use generic user-facing errors; log details internally"

  high:
    - id: "FS-HIGH-001"
      signal: "No circuit breaker for external APIs"
      evidence_pattern: "Continuous calls to failing external service"
      explanation: |
        Without circuit breakers, calls continue to a failing service,
        wasting resources and increasing latency. Circuit breakers
        fail fast and allow recovery.
      remediation: "Implement circuit breaker for external API calls"

    - id: "FS-HIGH-002"
      signal: "Stale cache not used as fallback"
      evidence_pattern: "Cache miss returns error instead of stale data"
      explanation: |
        When fresh data is unavailable, slightly stale cached data
        is often better than an error. Many use cases can tolerate
        eventual consistency during degradation.
      remediation: "Consider serving stale cache during third-party outages"

    - id: "FS-HIGH-003"
      signal: "No degraded mode for non-critical features"
      evidence_pattern: "Entire page fails if one widget's API fails"
      explanation: |
        Non-critical features should fail independently. A recommendation
        widget failure shouldn't prevent viewing products. Design for
        partial functionality.
      remediation: "Implement graceful degradation for non-critical features"

  medium:
    - id: "FS-MED-001"
      signal: "Fallback not tested"
      evidence_pattern: "No tests or chaos experiments for fallback paths"
      remediation: "Test fallback behavior; implement chaos engineering"

    - id: "FS-MED-002"
      signal: "No alternative provider configured"
      evidence_pattern: "Single vendor for critical capability"
      remediation: "Configure alternative provider for critical capabilities"

    - id: "FS-MED-003"
      signal: "Fallback latency not monitored"
      evidence_pattern: "No metrics on fallback activation or duration"
      remediation: "Monitor fallback activation frequency and duration"

  low:
    - id: "FS-LOW-001"
      signal: "Fallback strategy not documented"
      evidence_pattern: "No runbook for third-party failures"
      remediation: "Document fallback behavior and manual intervention options"

  positive:
    - id: "FS-POS-001"
      signal: "Circuit breaker on all external calls"
      evidence_pattern: "External calls wrapped in circuit breaker"

    - id: "FS-POS-002"
      signal: "Graceful degradation implemented"
      evidence_pattern: "Non-critical failures don't break critical paths"

    - id: "FS-POS-003"
      signal: "Fallback tested in production-like environment"
      evidence_pattern: "Chaos experiments validate fallback behavior"

procedure:
  context:
    cognitive_mode: "critical"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Identify External Integration Points"
      description: |
        Find all third-party API call sites.
      duration_estimate: "15 min"
      commands:
        - purpose: "Find external API calls"
          command: |
            grep -rn "fetch\|axios\|http\|HttpClient" \
              --include="*.ts" --include="*.java" --include="*.py" . 2>/dev/null | \
              grep -v node_modules | grep -v test | head -40

      expected_findings:
        - "Integration points"
        - "API call sites"

    - id: "2"
      name: "Analyze Fallback Implementation"
      description: |
        Check if fallbacks exist for external calls.
      duration_estimate: "25 min"
      commands:
        - purpose: "Find fallback logic"
          command: |
            grep -rn "fallback\|default\|catch" \
              --include="*.ts" --include="*.java" --include="*.py" . 2>/dev/null | \
              grep -v node_modules | head -40
        - purpose: "Find circuit breaker"
          command: |
            grep -rn "circuit\|breaker\|CircuitBreaker\|Hystrix\|resilience4j" \
              --include="*.ts" --include="*.java" --include="*.py" . 2>/dev/null | \
              grep -v node_modules | head -20

      expected_findings:
        - "Fallback presence"
        - "Circuit breaker usage"

    - id: "3"
      name: "Review Error Handling"
      description: |
        Check how external errors are handled.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find error handling"
          command: |
            grep -rn "catch\|except\|error\|Error" \
              --include="*.ts" --include="*.java" --include="*.py" . 2>/dev/null | \
              grep -i "api\|service\|client" | grep -v node_modules | head -30

      expected_findings:
        - "Error handling patterns"
        - "User-facing errors"

    - id: "4"
      name: "Check Degraded Mode"
      description: |
        Verify graceful degradation for non-critical features.
      duration_estimate: "15 min"
      questions:
        - "Can core functionality work without each external API?"
        - "Are non-critical features isolated?"
        - "What user experience during degradation?"

      expected_findings:
        - "Degradation strategy"
        - "Feature isolation"

    - id: "5"
      name: "Evaluate Fallback Testing"
      description: |
        Check if fallbacks are tested.
      duration_estimate: "15 min"
      commands:
        - purpose: "Find fallback tests"
          command: |
            grep -rn "fallback\|circuit\|degrade" \
              --include="*.test.*" --include="*.spec.*" --include="*Test.java" . 2>/dev/null | \
              grep -v node_modules | head -20

      expected_findings:
        - "Test coverage"
        - "Chaos testing"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"
      content:
        - "fallback_inventory"
        - "coverage_assessment"
        - "testing_status"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Fallback Coverage"
        - "Testing Assessment"
        - "Recommendations"

  confidence_guidance:
    high: "Clear missing fallback for critical integration"
    medium: "Fallback exists but completeness uncertain"
    low: "Requires failure testing to confirm behavior"

offline:
  capability: "full"

  cache_manifest:
    knowledge:
      - source_id: "graceful-degradation"
        priority: "required"
      - source_id: "fallback-patterns"
        priority: "required"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires detailed analysis"
    full:
      included: true
      priority: 1
    reliability:
      included: true
      priority: 1

closeout_checklist:
  - id: "fs-001"
    item: "Fallbacks exist for critical third-party APIs"
    level: "CRITICAL"
    verification: |
      grep -rn "fallback\|catch\|default" \
        --include="*.ts" --include="*.java" --include="*.py" . 2>/dev/null | \
        grep -v node_modules | wc -l | xargs -I {} test {} -gt 0 && echo "PASS" || echo "FAIL"
    expected: "PASS"

  - id: "fs-002"
    item: "Circuit breaker implemented"
    level: "BLOCKING"
    verification: |
      grep -rn "circuit\|breaker\|CircuitBreaker" \
        --include="*.ts" --include="*.java" --include="*.py" . 2>/dev/null | \
        grep -v node_modules | wc -l | xargs -I {} test {} -gt 0 && echo "PASS" || echo "FAIL"
    expected: "PASS"

  - id: "fs-003"
    item: "Fallback paths tested"
    level: "WARNING"
    verification: |
      grep -rn "fallback\|circuit\|degrade" \
        --include="*.test.*" --include="*.spec.*" . 2>/dev/null | \
        grep -v node_modules | wc -l | xargs -I {} test {} -gt 0 && echo "PASS" || echo "FAIL"
    expected: "PASS"

governance:
  applicable_to:
    archetypes: ["all"]

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Reliability", "Fault Tolerance"]

relationships:
  commonly_combined:
    - "api-integration.third-party-integration.third-party-api-dependency"
    - "reliability-resilience.circuit-breaker.circuit-implementation"
    - "reliability-resilience.graceful-degradation.degradation-strategy"
