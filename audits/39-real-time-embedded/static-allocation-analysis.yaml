audit:
  id: real-time-embedded.memory-management.static-allocation-analysis
  name: Static Allocation Analysis Audit
  version: 1.0.0
  last_updated: '2025-01-22'
  status: active
  category: real-time-embedded
  category_number: 39
  subcategory: memory-management
  tier: expert
  estimated_duration: 4-6 hours  # median: 5h
  completeness: requires_discovery
  requires_runtime: false
  destructive: false
execution:
  automatable: partial
  severity: high
  scope: embedded-systems
  default_profiles:
  - full
  - quick
  blocks_phase: false
  parallelizable: true
description:
  what: |
    Evaluates the use of static memory allocation in embedded systems to ensure
    deterministic behavior and predictable memory usage. Reviews compile-time
    allocation of buffers, task stacks, and data structures. Analyzes memory
    layout, alignment requirements, and placement directives. Verifies that
    dynamic allocation is avoided in safety-critical paths.
  why_it_matters: |
    Static allocation eliminates fragmentation, allocation failure risks, and
    non-deterministic timing associated with dynamic memory. Safety standards
    like DO-178C and ISO 26262 often require or strongly recommend static
    allocation for safety-critical functions. Proper static allocation ensures
    memory usage is completely known at compile time.
  when_to_run:
  - During architecture review
  - Before safety certification
  - After memory-related issues
  - When optimizing memory usage
  - During code review
prerequisites:
  required_artifacts:
  - type: source_code
    description: Complete embedded source code
  - type: linker_script
    description: Memory layout and linker directives
  - type: map_file
    description: Linker map file
  - type: memory_specs
    description: Target memory specifications
  access_requirements:
  - Access to source code
  - Access to build system
  - Access to linker output
  - Memory analysis tools
discovery:
  file_patterns:
  - glob: '**/*.c'
    purpose: Find C source for allocation patterns
  - glob: '**/*.ld'
    purpose: Find linker scripts
  - glob: '**/*.map'
    purpose: Find map files
  - glob: '**/memory*.h'
    purpose: Find memory configuration
  - glob: '**/buffers.h'
    purpose: Find buffer definitions
knowledge_sources:
  guides:
  - id: static-alloc
    name: Static Memory Allocation Patterns
    url: https://www.embedded.com/static-allocation
  - id: misra-memory
    name: MISRA C Memory Guidelines
    url: https://www.misra.org.uk/
  standards:
  - id: do-178c
    name: DO-178C Software Considerations
    relevance: Aviation memory requirements
  - id: iso-26262
    name: ISO 26262 Functional Safety
    relevance: Automotive memory constraints
  - id: misra-c
    name: MISRA C Guidelines
    relevance: Dir 4.12 Dynamic memory
tooling:
  analysis_tools:
  - tool: pc-lint
    purpose: Static allocation analysis
  - tool: polyspace
    purpose: Memory usage verification
  - tool: nm
    purpose: Symbol size analysis
  - tool: size
    purpose: Section size analysis
signals:
  critical:
  - id: SAA-CRIT-001
    signal: Dynamic allocation in safety-critical code
    evidence_indicators:
    - malloc/free in critical paths
    - Dynamic allocation after initialization
    - Runtime allocation failures possible
    explanation: |
      Dynamic allocation in safety-critical code introduces failure
      modes and non-determinism. Safety standards prohibit this for
      highest integrity levels.
    remediation: Replace dynamic allocation with static allocation
  - id: SAA-CRIT-002
    signal: Static allocation exceeds available memory
    evidence_indicators:
    - Linker error or warning
    - Total allocation > memory size
    - No margin remaining
    explanation: |
      When static allocation exceeds memory, the system cannot function.
      Memory must be reduced or target upgraded.
    remediation: Reduce allocations or increase memory
  high:
  - id: SAA-HIGH-001
    signal: Insufficient static buffer sizes
    evidence_indicators:
    - Buffer sizes based on assumptions
    - No worst-case analysis
    - Runtime overflow possible
    explanation: |
      Static buffers must be sized for worst-case data. Undersized
      buffers cause overflow and corruption.
    remediation: Size buffers based on worst-case requirements
  - id: SAA-HIGH-002
    signal: Memory alignment violations
    evidence_indicators:
    - Unaligned access to hardware registers
    - DMA buffer alignment incorrect
    - Performance penalty from misalignment
    explanation: |
      Hardware often requires specific alignment. Violations cause
      faults or performance degradation.
    remediation: Apply proper alignment attributes
  medium:
  - id: SAA-MED-001
    signal: Excessive static allocation margin
    evidence_indicators:
    - Large unused memory regions
    - Oversized buffers without justification
    - Memory waste significant
    explanation: |
      While margin is good, excessive over-allocation wastes limited
      embedded memory resources.
    remediation: Right-size allocations with justified margin
  - id: SAA-MED-002
    signal: No memory budget tracking
    evidence_indicators:
    - Memory usage not monitored
    - No allocation targets
    - Growth uncontrolled
    explanation: |
      Without tracking, memory grows until it hits limits late in
      development when changes are expensive.
    remediation: Implement memory budget tracking
  low:
  - id: SAA-LOW-001
    signal: Static allocation not documented
    evidence_indicators:
    - Buffer purpose unclear
    - Size rationale not recorded
    - Memory map undocumented
    explanation: |
      Documentation supports maintenance and certification evidence.
    remediation: Document static allocation design
  positive:
  - id: SAA-POS-001
    signal: Complete static allocation approach
    evidence_indicators:
    - No dynamic allocation used
    - All memory known at compile time
    - Deterministic memory usage
  - id: SAA-POS-002
    signal: Well-documented memory layout
    evidence_indicators:
    - Memory map documented
    - Allocations justified
    - Budget tracked
procedure:
  context:
    cognitive_mode: analytical
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Analyze Memory Map
    description: Review linker script and map file for layout
    duration_estimate: 1 hour
  - id: '2'
    name: Identify Allocation Patterns
    description: Find all static and dynamic allocations
    duration_estimate: 1-2 hours
  - id: '3'
    name: Check Dynamic Allocation Usage
    description: Identify any dynamic allocation and context
    duration_estimate: 1 hour
  - id: '4'
    name: Verify Buffer Sizing
    description: Confirm buffer sizes match requirements
    duration_estimate: 1 hour
  - id: '5'
    name: Review Alignment and Placement
    description: Check alignment attributes and section placement
    duration_estimate: 30 minutes
  - id: '6'
    name: Document Findings
    description: Compile analysis results and recommendations
    duration_estimate: 30 minutes
output:
  deliverables:
  - type: finding_list
    format: structured
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Memory Layout Analysis
    - Allocation Pattern Review
    - Dynamic Allocation Findings
    - Recommendations
closeout_checklist:
- id: saa-001
  item: Memory map analyzed
  level: HIGH
  verification: manual
- id: saa-002
  item: Allocation patterns identified
  level: HIGH
  verification: automated
- id: saa-003
  item: Dynamic allocation reviewed
  level: CRITICAL
  verification: automated
- id: saa-004
  item: Buffer sizing verified
  level: HIGH
  verification: manual
governance:
  applicable_to:
    archetypes:
    - embedded-systems
    - safety-critical
    - automotive
    - avionics
  compliance_mappings:
  - framework: DO-178C
    control: 6.3.3
    description: Memory management
  - framework: ISO 26262
    control: Part 6
    description: Memory constraints
  - framework: MISRA C
    control: Dir 4.12
    description: Dynamic memory allocation
relationships:
  commonly_combined:
  - real-time-embedded.memory-management.fragmentation-prevention
  - real-time-embedded.memory-management.stack-overflow-protection
  depends_on:
  - requirements.memory-requirements
  - architecture.memory-architecture
  feeds_into:
  - safety.memory-safety
  - certification.memory-certification

# Glossary of domain-specific terms:
glossary:
  "WCET": "Worst-Case Execution Time - maximum possible execution time for a code path"
  "ISR": "Interrupt Service Routine - function executed in response to hardware interrupt"
  "jitter": "Variation in timing between expected and actual execution"
