audit:
  id: real-time-embedded.memory-management.stack-overflow-protection
  name: Stack Overflow Protection Audit
  version: 1.0.0
  last_updated: '2025-01-22'
  status: active
  category: real-time-embedded
  category_number: 39
  subcategory: memory-management
  tier: expert
  estimated_duration: 4-6 hours  # median: 5h
  completeness: requires_discovery
  requires_runtime: true
  destructive: false
execution:
  automatable: partial
  severity: critical
  scope: embedded-systems
  default_profiles:
  - full
  - quick
  blocks_phase: false
  parallelizable: true
description:
  what: |
    Evaluates stack overflow detection and prevention mechanisms in embedded
    systems. Reviews stack size allocations, worst-case stack usage analysis,
    guard regions, runtime stack checking, and MPU-based protection. Analyzes
    recursive function usage, large local variables, and call chain depth.
  why_it_matters: |
    Stack overflow corrupts adjacent memory, causing unpredictable behavior
    ranging from data corruption to security vulnerabilities. In embedded
    systems without MMU protection, stack overflow can corrupt neighboring
    task stacks or global data. Detection mechanisms enable graceful handling
    rather than silent corruption and eventual crash.
  when_to_run:
  - During task stack sizing
  - After adding deep call chains
  - Before safety certification
  - When debugging memory corruption
  - After adding recursive functions
prerequisites:
  required_artifacts:
  - type: source_code
    description: Complete application source code
  - type: stack_configuration
    description: Task stack size assignments
  - type: call_graph
    description: Function call graph analysis
  - type: linker_output
    description: Stack frame size information
  access_requirements:
  - Access to source code
  - Access to build system
  - Static analysis tools
  - Runtime stack monitoring
discovery:
  file_patterns:
  - glob: '**/task_config*.c'
    purpose: Find task stack definitions
  - glob: '**/FreeRTOSConfig.h'
    purpose: Find stack checking configuration
  - glob: '**/stack*.c'
    purpose: Find stack-related code
  - glob: '**/mpu_config*.c'
    purpose: Find MPU configuration
  - glob: '**/*.su'
    purpose: Find GCC stack usage files
knowledge_sources:
  guides:
  - id: stack-analysis
    name: Embedded Stack Usage Analysis
    url: https://www.embedded.com/stack-analysis
  - id: freertos-stack
    name: FreeRTOS Stack Overflow Detection
    url: https://www.freertos.org/Stacks-and-stack-overflow-checking.html
  standards:
  - id: do-178c
    name: DO-178C Software Considerations
    relevance: Stack analysis requirements
  - id: iso-26262
    name: ISO 26262 Functional Safety
    relevance: Memory protection
  - id: misra-c
    name: MISRA C Guidelines
    relevance: Stack usage rules
tooling:
  analysis_tools:
  - tool: gcc-stack-usage
    purpose: Static stack analysis
  - tool: absint-stackanalyzer
    purpose: Worst-case stack analysis
  - tool: polyspace
    purpose: Stack depth verification
  - tool: tracealyzer
    purpose: Runtime stack monitoring
signals:
  critical:
  - id: SOP-CRIT-001
    signal: Stack overflow detected at runtime
    evidence_indicators:
    - Stack corruption observed
    - Guard pattern overwritten
    - Task crash or hang
    explanation: |
      Actual stack overflow indicates stack is undersized or analysis
      is incomplete. Memory corruption may have already occurred.
    remediation: Increase stack size and investigate root cause
  - id: SOP-CRIT-002
    signal: No stack overflow detection enabled
    evidence_indicators:
    - No guard regions
    - No runtime checking
    - No MPU protection
    explanation: |
      Without detection, stack overflow causes silent corruption.
      Problems may not manifest until much later, making debugging
      extremely difficult.
    remediation: Enable stack overflow detection mechanism
  high:
  - id: SOP-HIGH-001
    signal: Stack usage analysis incomplete
    evidence_indicators:
    - Recursive functions not analyzed
    - Call chain depth unknown
    - Worst-case not calculated
    explanation: |
      Without complete analysis, stack size may be inadequate for
      worst-case execution paths.
    remediation: Complete worst-case stack usage analysis
  - id: SOP-HIGH-002
    signal: Insufficient stack margin
    evidence_indicators:
    - High-water mark near stack limit
    - Less than 20% margin
    - No room for interrupt stacking
    explanation: |
      Minimal margin leaves no room for additional interrupt contexts
      or unanticipated call chains.
    remediation: Increase stack size to maintain adequate margin
  medium:
  - id: SOP-MED-001
    signal: Large local variables on stack
    evidence_indicators:
    - Arrays allocated on stack
    - Large structures as locals
    - Single function consumes majority of stack
    explanation: |
      Large local variables consume significant stack space. Consider
      static or heap allocation for large data structures.
    remediation: Move large data to static storage
  - id: SOP-MED-002
    signal: Unbounded recursion possible
    evidence_indicators:
    - Recursive function without depth limit
    - Recursion depth depends on input
    - Stack exhaustion possible
    explanation: |
      Unbounded recursion can exhaust any stack size. All recursion
      must have provable depth limits.
    remediation: Add recursion depth limits or convert to iteration
  low:
  - id: SOP-LOW-001
    signal: Stack sizing not documented
    evidence_indicators:
    - Stack size rationale missing
    - Analysis results not recorded
    - Margin not justified
    explanation: |
      Documentation supports maintenance and certification evidence.
    remediation: Document stack analysis and sizing rationale
  positive:
  - id: SOP-POS-001
    signal: Comprehensive stack protection in place
    evidence_indicators:
    - Stack overflow detection enabled
    - MPU guards stack regions
    - Runtime monitoring active
  - id: SOP-POS-002
    signal: Stack usage fully analyzed
    evidence_indicators:
    - Worst-case analysis complete
    - Adequate margin maintained
    - Results documented
procedure:
  context:
    cognitive_mode: analytical
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Inventory Task Stacks
    description: Document all task stack allocations
    duration_estimate: 30 minutes
  - id: '2'
    name: Review Detection Mechanisms
    description: Assess stack overflow detection configuration
    duration_estimate: 30 minutes
  - id: '3'
    name: Analyze Worst-Case Stack Usage
    description: Calculate maximum stack depth for each task
    duration_estimate: 2-3 hours
  - id: '4'
    name: Check for Recursion and Large Locals
    description: Identify stack-heavy code patterns
    duration_estimate: 1 hour
  - id: '5'
    name: Measure Runtime Stack High-Water
    description: Monitor actual stack usage during operation
    duration_estimate: 1 hour
  - id: '6'
    name: Document Findings
    description: Compile analysis results and recommendations
    duration_estimate: 30 minutes
output:
  deliverables:
  - type: finding_list
    format: structured
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Stack Inventory
    - Detection Mechanisms
    - Usage Analysis
    - Recommendations
closeout_checklist:
- id: sop-001
  item: Task stacks inventoried
  level: HIGH
  verification: manual
- id: sop-002
  item: Detection mechanisms reviewed
  level: CRITICAL
  verification: automated
- id: sop-003
  item: Worst-case analysis completed
  level: CRITICAL
  verification: automated
- id: sop-004
  item: Runtime high-water measured
  level: HIGH
  verification: automated
governance:
  applicable_to:
    archetypes:
    - embedded-systems
    - safety-critical
    - automotive
    - avionics
  compliance_mappings:
  - framework: DO-178C
    control: 6.3.3
    description: Memory requirements
  - framework: ISO 26262
    control: Part 6
    description: Memory protection
  - framework: MISRA C
    control: Rule 17.2
    description: Recursion
relationships:
  commonly_combined:
  - real-time-embedded.memory-management.static-allocation-analysis
  - real-time-embedded.timing-analysis.wcet-analysis
  depends_on:
  - build.compiler-configuration
  feeds_into:
  - safety.memory-safety
  - reliability.corruption-prevention

# Glossary of domain-specific terms:
glossary:
  "WCET": "Worst-Case Execution Time - maximum possible execution time for a code path"
  "ISR": "Interrupt Service Routine - function executed in response to hardware interrupt"
  "jitter": "Variation in timing between expected and actual execution"
