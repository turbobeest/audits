audit:
  id: real-time-embedded.memory-management.heap-usage-analysis
  name: Heap Usage Analysis Audit
  version: 1.0.0
  last_updated: '2025-01-22'
  status: active
  category: real-time-embedded
  category_number: 39
  subcategory: memory-management
  tier: expert
  estimated_duration: 4-6 hours  # median: 5h
  completeness: requires_discovery
  requires_runtime: true
  destructive: false
execution:
  automatable: partial
  severity: high
  scope: embedded-systems
  default_profiles:
  - full
  - quick
  blocks_phase: false
  parallelizable: true
description:
  what: |
    Analyzes heap memory usage patterns in embedded systems where dynamic
    allocation is used. Reviews allocation frequency, sizes, lifetimes, and
    peak usage. Identifies memory leaks, inefficient allocation patterns,
    and determinism concerns. Evaluates heap allocator implementation and
    configuration for embedded appropriateness.
  why_it_matters: |
    Heap usage in embedded systems must be carefully controlled to avoid
    exhaustion, fragmentation, and non-deterministic timing. Memory leaks
    accumulate over time leading to eventual failure. Understanding heap
    usage patterns enables proper sizing, leak detection, and decisions
    about allocation strategy appropriateness.
  when_to_run:
  - When dynamic allocation is used
  - During memory debugging
  - Before long-duration testing
  - When investigating allocation failures
  - During performance optimization
prerequisites:
  required_artifacts:
  - type: source_code
    description: Application source with heap usage
  - type: heap_configuration
    description: Heap size and allocator settings
  - type: runtime_data
    description: Heap monitoring information
  - type: allocation_traces
    description: Allocation/free sequence logs
  access_requirements:
  - Access to source code
  - Heap instrumentation capability
  - Memory debugging tools
  - Runtime monitoring access
discovery:
  file_patterns:
  - glob: '**/*.c'
    purpose: Find allocation calls
  - glob: '**/heap*.c'
    purpose: Find heap implementation
  - glob: '**/FreeRTOSConfig.h'
    purpose: Find heap configuration
  - glob: '**/memory*.c'
    purpose: Find memory management code
knowledge_sources:
  guides:
  - id: embedded-heap
    name: Heap Management in Embedded Systems
    url: https://www.embedded.com/heap-management
  - id: leak-detection
    name: Memory Leak Detection Techniques
    url: https://www.embedded.com/leak-detection
  standards:
  - id: misra-c
    name: MISRA C Guidelines
    relevance: Dynamic memory rules
  - id: cert-c
    name: CERT C Coding Standard
    relevance: Memory management rules
tooling:
  analysis_tools:
  - tool: valgrind
    purpose: Memory leak detection
  - tool: heaptrack
    purpose: Heap profiling
  - tool: tracealyzer
    purpose: Memory visualization
  - tool: custom-wrapper
    purpose: Embedded heap instrumentation
signals:
  critical:
  - id: HUA-CRIT-001
    signal: Memory leak detected
    evidence_indicators:
    - Allocated memory never freed
    - Heap usage grows continuously
    - Eventual exhaustion observed
    explanation: |
      Memory leaks accumulate until heap is exhausted. In long-running
      embedded systems, even small leaks cause eventual failure.
    remediation: Fix leak by adding proper free calls
  - id: HUA-CRIT-002
    signal: Heap exhaustion during operation
    evidence_indicators:
    - Allocation returns NULL
    - Heap size insufficient
    - Peak usage exceeds capacity
    explanation: |
      Heap exhaustion causes immediate operational failure. Either
      heap is undersized or usage is excessive.
    remediation: Increase heap size or reduce allocations
  high:
  - id: HUA-HIGH-001
    signal: Allocation in real-time critical path
    evidence_indicators:
    - malloc in time-critical code
    - Non-deterministic timing observed
    - Allocation time varies
    explanation: |
      Heap allocation has variable timing. In real-time paths,
      this introduces non-determinism and potential deadline misses.
    remediation: Pre-allocate or use deterministic allocator
  - id: HUA-HIGH-002
    signal: High allocation churn
    evidence_indicators:
    - Frequent allocation/free cycles
    - Same data repeatedly allocated
    - Fragmentation risk high
    explanation: |
      High allocation churn increases fragmentation risk and
      overhead. Consider object pooling or buffer reuse.
    remediation: Implement object pools or buffer caching
  medium:
  - id: HUA-MED-001
    signal: Heap sizing based on guesswork
    evidence_indicators:
    - Heap size not justified
    - No usage analysis performed
    - Large margin without rationale
    explanation: |
      Proper heap sizing requires understanding of actual usage.
      Guesswork leads to waste or exhaustion.
    remediation: Analyze usage and size heap appropriately
  - id: HUA-MED-002
    signal: No heap monitoring capability
    evidence_indicators:
    - Usage unknown at runtime
    - No high-water tracking
    - Problems only found after failure
    explanation: |
      Without monitoring, heap problems go undetected until
      they cause failures.
    remediation: Implement heap monitoring and reporting
  low:
  - id: HUA-LOW-001
    signal: Allocation patterns not documented
    evidence_indicators:
    - Purpose of allocations unclear
    - Expected usage not specified
    - Lifetime not documented
    explanation: |
      Documentation supports maintenance and enables proper
      analysis of allocation appropriateness.
    remediation: Document allocation purposes and patterns
  positive:
  - id: HUA-POS-001
    signal: Heap usage well-characterized
    evidence_indicators:
    - All allocations documented
    - Peak usage known
    - No leaks detected
  - id: HUA-POS-002
    signal: Heap monitoring in place
    evidence_indicators:
    - Usage tracked at runtime
    - Alerts for high usage
    - Historical data available
procedure:
  context:
    cognitive_mode: analytical
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Identify All Allocation Points
    description: Find all heap allocations in codebase
    duration_estimate: 1 hour
  - id: '2'
    name: Analyze Allocation Patterns
    description: Document sizes, frequencies, and lifetimes
    duration_estimate: 1-2 hours
  - id: '3'
    name: Check for Memory Leaks
    description: Run leak detection tools and analysis
    duration_estimate: 1 hour
  - id: '4'
    name: Measure Peak Usage
    description: Monitor heap during various scenarios
    duration_estimate: 1 hour
  - id: '5'
    name: Evaluate Allocator Suitability
    description: Assess if allocator is appropriate for patterns
    duration_estimate: 30 minutes
  - id: '6'
    name: Document Findings
    description: Compile analysis results and recommendations
    duration_estimate: 30 minutes
output:
  deliverables:
  - type: finding_list
    format: structured
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Allocation Analysis
    - Leak Detection Results
    - Usage Statistics
    - Recommendations
closeout_checklist:
- id: hua-001
  item: Allocation points identified
  level: HIGH
  verification: automated
- id: hua-002
  item: Patterns analyzed
  level: HIGH
  verification: manual
- id: hua-003
  item: Leak check completed
  level: CRITICAL
  verification: automated
- id: hua-004
  item: Peak usage measured
  level: HIGH
  verification: automated
governance:
  applicable_to:
    archetypes:
    - embedded-systems
    - long-running
    - resource-constrained
  compliance_mappings:
  - framework: MISRA C
    control: Dir 4.12
    description: Dynamic memory
  - framework: CERT C
    control: MEM
    description: Memory management
  - framework: DO-178C
    control: 6.3.3
    description: Memory usage
relationships:
  commonly_combined:
  - real-time-embedded.memory-management.fragmentation-prevention
  - real-time-embedded.memory-management.static-allocation-analysis
  depends_on:
  - architecture.memory-architecture
  feeds_into:
  - reliability.memory-reliability
  - performance.memory-optimization

# Glossary of domain-specific terms:
glossary:
  "WCET": "Worst-Case Execution Time - maximum possible execution time for a code path"
  "ISR": "Interrupt Service Routine - function executed in response to hardware interrupt"
  "jitter": "Variation in timing between expected and actual execution"
