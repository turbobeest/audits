audit:
  id: legacy-migration.technical-debt-assessment.complexity-metrics
  name: Complexity Metrics Analysis Audit
  version: 1.0.0
  last_updated: '2025-01-22'
  status: active
  category: legacy-migration
  category_number: 33
  subcategory: technical-debt-assessment
  tier: expert
  estimated_duration: 3-5 hours  # median: 4h
  completeness: requires_discovery
  requires_runtime: false
  destructive: false
execution:
  automatable: full
  severity: medium
  scope: codebase
  default_profiles:
  - full
  - quick
  blocks_phase: false
  parallelizable: true
description:
  what: |
    Calculates and analyzes code complexity metrics including cyclomatic complexity,
    cognitive complexity, lines of code, depth of inheritance, coupling between objects,
    and Halstead metrics. This audit identifies overly complex code that poses
    maintenance and testing challenges, measuring complexity at method, class,
    and module levels.
  why_it_matters: |
    High complexity directly correlates with defect density and maintenance difficulty.
    Complex code is harder to test, review, and modify safely. By measuring complexity
    metrics, teams can identify areas requiring simplification and predict where
    bugs are most likely to occur, enabling proactive quality improvement.
  when_to_run:
  - During code review processes
  - Before release quality gates
  - When planning refactoring efforts
  - As part of technical debt assessments
prerequisites:
  required_artifacts:
  - type: source_code
    description: Complete source code access
  - type: build_configuration
    description: Build files for dependency resolution
  access_requirements:
  - Read access to source repositories
  - Ability to execute analysis tools
discovery:
  file_patterns:
  - glob: '**/*.{java,cs,py,js,ts,cpp,c,go}'
    purpose: Find source files for complexity analysis
  - glob: '**/complexity-report*'
    purpose: Find existing complexity reports
  interview_questions:
  - role: Developer
    questions:
    - Which methods are you most afraid to modify?
    - What areas have the most nested conditionals?
    - Where do code reviews take the longest?
knowledge_sources:
  guides:
  - id: cyclomatic-complexity
    name: McCabe Cyclomatic Complexity
    url: https://en.wikipedia.org/wiki/Cyclomatic_complexity
  - id: cognitive-complexity
    name: SonarSource Cognitive Complexity
    url: https://www.sonarsource.com/docs/CognitiveComplexity.pdf
  standards:
  - id: sei-complexity
    name: SEI Complexity Guidelines
    relevance: Industry thresholds for acceptable complexity
tooling:
  analysis_tools:
  - tool: SonarQube
    purpose: Comprehensive complexity measurement
    command: sonar-scanner
  - tool: radon
    purpose: Python cyclomatic complexity
    command: radon cc -s -a src/
  - tool: lizard
    purpose: Multi-language complexity analyzer
    command: lizard -l python -l java src/
  - tool: gocyclo
    purpose: Go cyclomatic complexity
    command: gocyclo -over 10 .
  - tool: complexity-report
    purpose: JavaScript complexity metrics
    command: cr --format json src/
signals:
  critical:
  - id: CMA-CRIT-001
    signal: Cyclomatic complexity exceeds 50 in critical functions
    evidence_indicators:
    - Methods with >50 independent paths
    - Deeply nested conditional logic
    - Multiple exit points with complex conditions
    explanation: |
      Extreme cyclomatic complexity makes thorough testing practically impossible.
      Each additional path doubles the testing permutations required, leading
      to untested edge cases and hidden bugs.
    remediation: Decompose into smaller functions with clear single responsibilities
  - id: CMA-CRIT-002
    signal: Cognitive complexity exceeds 100 in single method
    evidence_indicators:
    - Deeply nested control structures
    - Complex boolean expressions
    - Recursive or interconnected logic
    explanation: |
      High cognitive complexity indicates code that is extremely difficult
      for humans to understand and reason about correctly.
    remediation: Simplify logic and extract well-named helper methods
  high:
  - id: CMA-HIGH-001
    signal: Cyclomatic complexity between 20-50 in multiple methods
    remediation: Refactor methods to reduce branching complexity
  - id: CMA-HIGH-002
    signal: Average class complexity exceeds threshold
    remediation: Break down complex classes into smaller, focused units
  - id: CMA-HIGH-003
    signal: High nesting depth (>5 levels) prevalent
    remediation: Use early returns and guard clauses to flatten nesting
  medium:
  - id: CMA-MED-001
    signal: Cyclomatic complexity between 10-20
    remediation: Schedule simplification in technical debt backlog
  - id: CMA-MED-002
    signal: High coupling between modules
    remediation: Introduce abstractions to reduce coupling
  low:
  - id: CMA-LOW-001
    signal: Minor complexity threshold violations
    remediation: Address during routine code maintenance
  - id: CMA-LOW-002
    signal: Inconsistent complexity across similar functions
    remediation: Standardize approaches for similar operations
  positive:
  - id: CMA-POS-001
    signal: Average cyclomatic complexity below 10
  - id: CMA-POS-002
    signal: Complexity metrics improving over time
procedure:
  context:
    cognitive_mode: analytical
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Configure Metrics Tools
    description: Set up complexity analysis with appropriate thresholds
    duration_estimate: 30 minutes
  - id: '2'
    name: Execute Complexity Analysis
    description: Run metrics tools across all source files
    duration_estimate: 1 hour
  - id: '3'
    name: Analyze Distribution
    description: Review complexity distribution and identify outliers
    duration_estimate: 1 hour
  - id: '4'
    name: Map to Risk Areas
    description: Correlate complexity with defect history and change frequency
    duration_estimate: 1 hour
  - id: '5'
    name: Generate Recommendations
    description: Create prioritized simplification recommendations
    duration_estimate: 1 hour
output:
  deliverables:
  - type: finding_list
    format: structured
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Complexity Distribution Analysis
    - High-Complexity Hotspots
    - Trend Analysis
    - Simplification Recommendations
closeout_checklist:
- id: cma-001
  item: All source files analyzed for complexity
  level: WARNING
  verification: tool_output
- id: cma-002
  item: High-complexity areas documented
  level: WARNING
  verification: manual
- id: cma-003
  item: Thresholds compared against industry standards
  level: WARNING
  verification: manual
governance:
  applicable_to:
    archetypes:
    - any-codebase
    - safety-critical-systems
    - regulated-software
  compliance_mappings:
  - framework: ISO 25010
    control: Maintainability
    description: Analyzability and modifiability characteristics
  - framework: IEC 62304
    control: Software Development
    description: Medical device software complexity requirements
relationships:
  commonly_combined:
  - code-quality.test-coverage
  - legacy-migration.technical-debt-assessment.code-smell-analysis
  depends_on:
  - code-quality.static-analysis
  feeds_into:
  - risk-management.defect-prediction
  - legacy-migration.code-modernization.refactoring-strategy
