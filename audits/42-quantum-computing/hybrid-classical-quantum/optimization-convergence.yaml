# ============================================================
# AUDIT: Optimization Convergence
# Category: 42 - Quantum Computing
# Subcategory: hybrid-classical-quantum
# ============================================================

audit:
  id: "quantum-computing.hybrid-classical-quantum.optimization-convergence"
  name: "Quantum Optimization Convergence Audit"
  version: "1.0.0"
  last_updated: "2025-01-22"
  status: "active"

  category: "quantum-computing"
  category_number: 42
  subcategory: "hybrid-classical-quantum"

  tier: "expert"
  estimated_duration: "4-6 hours"  # median: 5h

  completeness: "requires_discovery"
  requires_runtime: true
  destructive: false

execution:
  automatable: "partial"
  severity: "high"
  scope: "quantum-systems"

  default_profiles:
    - "full"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Evaluates whether variational quantum algorithms converge to optimal or
    near-optimal solutions. Assesses convergence rates, solution quality,
    barren plateau detection, and robustness to noise. Verifies that
    optimization achieves meaningful results.

  why_it_matters: |
    Variational algorithms promise quantum advantage but can fail to converge
    due to barren plateaus, noise, or poor initialization. Without convergence
    analysis, resources are wasted on computations that produce no value.
    Understanding convergence is essential for practical applications.

  when_to_run:
    - "When evaluating variational algorithms"
    - "When results seem suboptimal"
    - "When scaling to larger problems"
    - "During algorithm benchmarking"

prerequisites:
  required_artifacts:
    - type: "optimization_code"
      description: "Optimization implementation"
    - type: "benchmark_problems"
      description: "Problems with known optima"
    - type: "convergence_data"
      description: "Optimization history"

  access_requirements:
    - "Access to algorithm code"
    - "Benchmark problems"
    - "Optimization traces"

discovery:
  file_patterns:
    - glob: "**/optimization/**/*.py"
      purpose: "Find optimization code"
    - glob: "**/benchmarks/**/*.py"
      purpose: "Find benchmark code"

  code_patterns:
    - pattern: "converge|optimize|minimize"
      type: "keyword"
      scope: "source"
      purpose: "Find optimization logic"
    - pattern: "gradient|barren|plateau"
      type: "keyword"
      scope: "source"
      purpose: "Find convergence handling"

knowledge_sources:
  papers:
    - id: "barren-plateaus"
      title: "Barren plateaus in quantum neural network training landscapes"
      url: "https://arxiv.org/abs/1803.11173"

    - id: "noise-vqa"
      title: "Effect of noise on variational quantum algorithms"
      url: "https://arxiv.org/abs/2007.01871"

  guides:
    - id: "vqa-best-practices"
      name: "VQA Best Practices"
      url: "https://arxiv.org/abs/2012.09265"
      offline_cache: true

tooling:
  analysis_tools:
    - tool: "optimization-analysis"
      purpose: "Convergence analysis tools"

    - tool: "landscape-visualization"
      purpose: "Optimization landscape visualization"

signals:
  critical:
    - id: "OC-CRIT-001"
      signal: "Algorithm not converging"
      evidence_indicators:
        - "Cost function not decreasing"
        - "Random walk behavior"
        - "No progress after many iterations"
      explanation: |
        Non-converging optimization wastes quantum resources without
        producing useful results. Fundamental issues with algorithm
        or implementation must be addressed.
      remediation: |
        Check for barren plateaus.
        Verify gradient estimation.
        Consider different ansatz.
        Use better initialization.

    - id: "OC-CRIT-002"
      signal: "Converged solution far from optimal"
      evidence_threshold: "solution_quality < 0.5 * optimal"
      explanation: |
        Converging to poor solutions defeats the purpose of quantum
        optimization. Local minima or noise may be trapping the optimizer.
      remediation: |
        Use multiple random starts.
        Implement escape from local minima.
        Check ansatz expressiveness.

  high:
    - id: "OC-HIGH-001"
      signal: "Barren plateau detected"
      evidence_indicators:
        - "Gradient variance exponentially small"
        - "Cost function nearly flat"
      remediation: "Use shallower ansatz or local cost functions"

    - id: "OC-HIGH-002"
      signal: "Noise preventing convergence"
      evidence_indicators:
        - "Convergence degrades with more qubits"
        - "Shot noise dominating gradients"
      remediation: "Increase shots or use error mitigation"

  medium:
    - id: "OC-MED-001"
      signal: "Slow convergence rate"
      remediation: "Optimize hyperparameters or change optimizer"

    - id: "OC-MED-002"
      signal: "Solution quality varies between runs"
      remediation: "Use ensemble methods or better initialization"

  low:
    - id: "OC-LOW-001"
      signal: "Convergence not characterized"
      remediation: "Benchmark against known problems"

  positive:
    - id: "OC-POS-001"
      signal: "Consistent convergence to good solutions"
    - id: "OC-POS-002"
      signal: "Barren plateaus avoided"
    - id: "OC-POS-003"
      signal: "Noise resilient optimization"

procedure:
  context:
    cognitive_mode: "evaluative"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Run Benchmark Problems"
      description: "Test on problems with known optima"
      duration_estimate: "1.5 hours"

    - id: "2"
      name: "Analyze Convergence Curves"
      description: "Examine optimization traces"
      duration_estimate: "1 hour"

    - id: "3"
      name: "Check for Barren Plateaus"
      description: "Analyze gradient variance scaling"
      duration_estimate: "1 hour"

    - id: "4"
      name: "Assess Solution Quality"
      description: "Compare to known optima"
      duration_estimate: "45 min"

    - id: "5"
      name: "Test Noise Robustness"
      description: "Evaluate convergence under noise"
      duration_estimate: "1 hour"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "convergence_report"
      format: "json"
      description: "Detailed convergence analysis"

closeout_checklist:
  - id: "oc-001"
    item: "Algorithm converges"
    level: "CRITICAL"
    verification: "automated"

  - id: "oc-002"
    item: "Solution quality acceptable"
    level: "CRITICAL"
    verification: "automated"

  - id: "oc-003"
    item: "Barren plateaus addressed"
    level: "BLOCKING"
    verification: "manual"

governance:
  applicable_to:
    archetypes: ["quantum-systems", "optimization-systems"]

relationships:
  commonly_combined:
    - "quantum-computing.hybrid-classical-quantum.iteration-loop-strategy"
    - "quantum-computing.error-handling.error-mitigation-strategy"
  depends_on:
    - "quantum-computing.quantum-algorithm.algorithm-correctness"
