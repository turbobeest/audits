# ============================================================
# AUDIT FILE - Property Based Testing v1.0
# ============================================================

# ============================================================
# SECTION 1: IDENTITY & METADATA
# ============================================================

audit:
  id: "code-quality.testing.property-based-testing"

  name: "Property Based Testing"

  version: "1.0.0"
  last_updated: "2026-01-18"
  status: "active"

  category: "code-quality"
  category_number: 6
  subcategory: "testing"

  tier: "phd"
  estimated_duration: "2-4 hours"  # median: 3h

  completeness: "requires_discovery"
  requires_runtime: true
  destructive: false

# ============================================================
# SECTION 2: EXECUTION CLASSIFICATION
# ============================================================

execution:
  automatable: "partial"

  severity: "medium"

  scope: "testing"

  default_profiles:
    - "full"

  blocks_phase: false
  parallelizable: true

# ============================================================
# SECTION 3: DESCRIPTION & RATIONALE
# ============================================================

description:
  what: |
    Evaluates usage of property-based testing (PBT) techniques that
    verify code properties hold across many randomly generated inputs.
    Assesses coverage of pure functions, invariants, and edge cases
    that example-based tests might miss.

  why_it_matters: |
    Example-based tests only cover cases the developer thinks of.
    Property-based testing generates thousands of inputs, finding
    edge cases humans miss. It's particularly valuable for parsing,
    serialization, mathematical functions, and business rules.

  when_to_run:
    - "When implementing pure functions or algorithms"
    - "After bugs found in edge cases"
    - "For serialization/deserialization code"
    - "Periodic test strategy review"

# ============================================================
# SECTION 4: PREREQUISITES
# ============================================================

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Complete source code repository"
    - type: "test_suite"
      description: "Existing test suite"

  access_requirements:
    - "Read access to source code"
    - "Property testing framework installed (optional)"

# ============================================================
# SECTION 5: DISCOVERY SPECIFICATION
# ============================================================

discovery:
  file_patterns:
    - glob: "**/*.property.test.*"
      purpose: "Property test files"
    - glob: "**/properties/**"
      purpose: "Property test directory"

  code_patterns:
    - pattern: "fc\\.property|@given|forAll|check\\("
      type: "regex"
      scope: "source"
      purpose: "Property testing framework usage"
    - pattern: "fast-check|hypothesis|QuickCheck|jqwik"
      type: "regex"
      scope: "source"
      purpose: "Property testing libraries"

# ============================================================
# SECTION 6: EXTERNAL KNOWLEDGE SOURCES
# ============================================================

knowledge_sources:
  guides:
    - id: "fast-check"
      name: "fast-check Documentation"
      url: "https://fast-check.dev/"
      offline_cache: true
    - id: "hypothesis"
      name: "Hypothesis Documentation"
      url: "https://hypothesis.readthedocs.io/"
      offline_cache: true

    - id: "xunit-patterns"
      name: "xUnit Test Patterns: Refactoring Test Code"
      url: "https://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054"
      offline_cache: false

    - id: "working-effectively-legacy"
      name: "Working Effectively with Legacy Code"
      url: "https://www.oreilly.com/library/view/working-effectively-with/0131177052/"
      offline_cache: false

  papers:
    - id: "quickcheck"
      title: "QuickCheck: A Lightweight Tool for Random Testing"
      url: "https://www.cs.tufts.edu/~nr/cs257/archive/john-hughes/quick.pdf"

# ============================================================
# SECTION 7: TOOLING & AUTOMATION
# ============================================================

tooling:
  static_analysis:
    - tool: "fast-check"
      purpose: "JavaScript/TypeScript property testing"
      offline_capable: true
    - tool: "hypothesis"
      purpose: "Python property testing"
      offline_capable: true
    - tool: "QuickCheck"
      purpose: "Haskell property testing"
      offline_capable: true
    - tool: "jqwik"
      purpose: "Java property testing"
      offline_capable: true
    - tool: "gopter"
      purpose: "Go property testing"
      offline_capable: true

  scripts:
    - id: "property-test-run"
      language: "bash"
      purpose: "Run property tests"
      source: "inline"
      code: |
        #!/bin/bash
        npm test -- --grep "property" 2>/dev/null || pytest -m property 2>/dev/null

# ============================================================
# SECTION 8: SIGNALS & FINDINGS TAXONOMY
# ============================================================

signals:
  critical:
    - id: "PBT-CRIT-001"
      signal: "Serialization code without property tests"
      evidence_pattern: "JSON/protobuf serialization without roundtrip tests"
      explanation: |
        Serialization bugs are subtle and hard to catch with
        example tests. Property tests verify encode/decode
        roundtrips for all inputs.
      remediation: "Add property tests for serialization invariants"

  high:
    - id: "PBT-HIGH-001"
      signal: "Mathematical functions without property tests"
      evidence_pattern: "Calculations without invariant verification"
      explanation: |
        Mathematical and financial code benefits greatly from
        property tests that verify associativity, commutativity,
        and other algebraic properties.
      remediation: "Implement property tests for mathematical invariants"

    - id: "PBT-HIGH-002"
      signal: "Parser without property tests"
      evidence_pattern: "Parsing code with only example tests"
      explanation: |
        Parsers have many edge cases that example tests miss.
        Property tests generate diverse inputs.
      remediation: "Add property tests for parser robustness"

  medium:
    - id: "PBT-MED-001"
      signal: "No property testing framework configured"
      remediation: "Configure fast-check, hypothesis, or similar"

    - id: "PBT-MED-002"
      signal: "Property tests have low iteration count"
      remediation: "Increase iterations for better coverage"

  low:
    - id: "PBT-LOW-001"
      signal: "Property tests could cover more properties"

  positive:
    - id: "PBT-POS-001"
      signal: "Property tests for critical algorithms"
    - id: "PBT-POS-002"
      signal: "Comprehensive invariant coverage"

# ============================================================
# SECTION 9: EXECUTION PROCEDURE
# ============================================================

procedure:
  context:
    cognitive_mode: "evaluative"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Identify property testing candidates"
      description: |
        Find functions that are good candidates for property
        testing: pure functions, serialization, validators.
      duration_estimate: "30 min"
      expected_findings:
        - "Pure functions list"
        - "Serialization code"
        - "Parsing/validation code"

    - id: "2"
      name: "Inventory existing property tests"
      description: |
        Find any existing property tests in the codebase.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find fast-check usage"
          command: "grep -rn 'fc\\.property\\|fc\\.assert' . --include='*.test.*' 2>/dev/null | head -20"
        - purpose: "Find hypothesis usage"
          command: "grep -rn '@given\\|hypothesis' . --include='test_*.py' 2>/dev/null | head -20"
      expected_findings:
        - "Property test locations"
        - "Current coverage"

    - id: "3"
      name: "Evaluate property test quality"
      description: |
        Review existing property tests for meaningful
        property definitions.
      duration_estimate: "25 min"
      expected_findings:
        - "Property definitions"
        - "Iteration counts"

    - id: "4"
      name: "Identify coverage gaps"
      description: |
        Cross-reference candidates with existing tests to
        find gaps.
      duration_estimate: "25 min"
      expected_findings:
        - "Untested candidates"
        - "Priority recommendations"

    - id: "5"
      name: "Run property tests"
      description: |
        Execute property tests and analyze results.
      duration_estimate: "20 min"
      commands:
        - purpose: "Run property tests"
          command: "npm test -- --grep 'property' 2>&1 | tail -30"
      expected_findings:
        - "Test results"
        - "Shrunk counterexamples"

# ============================================================
# SECTION 10: OUTPUT SPECIFICATION
# ============================================================

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Property Testing Candidates"
        - "Current Coverage"
        - "Recommendations"

    - type: "metrics"
      format: "table"
      fields:
        - "property_test_count"
        - "candidates_identified"
        - "candidates_covered"
        - "coverage_percentage"

  confidence_guidance:
    high: "Comprehensive candidate analysis with test verification"
    medium: "Candidates identified, partial test review"
    low: "Estimated from code patterns"

# ============================================================
# SECTION 11: OFFLINE SUPPORT
# ============================================================

offline:
  capability: "full"

  cache_manifest:
    knowledge:
      - source_id: "fast-check"
        priority: "recommended"
      - source_id: "hypothesis"
        priority: "recommended"

# ============================================================
# SECTION 12: PROFILES
# ============================================================

profiles:
  membership:
    quick:
      included: false
      reason: "Property testing analysis is detailed"
    full:
      included: true
      priority: 3

# ============================================================
# SECTION 13: DETERMINISTIC VERIFICATION
# ============================================================

closeout_checklist:
  - id: "property-based-001"
    item: "Property testing candidates identified"
    level: "BLOCKING"
    verification: "manual"
    verification_notes: "Document pure functions and serialization code"
    expected: "Confirmed by reviewer"

  - id: "property-based-002"
    item: "Critical candidates have property tests"
    level: "WARNING"
    verification: "manual"
    verification_notes: "Verify serialization and math code has property tests"
    expected: "Confirmed by reviewer"

  - id: "property-based-003"
    item: "Property tests pass"
    level: "BLOCKING"
    verification: "manual"
    verification_notes: "Run property tests successfully"
    expected: "Confirmed by reviewer"

# ============================================================
# SECTION 14: GOVERNANCE
# ============================================================

governance:
  applicable_to:
    archetypes: ["all"]

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Reliability", "Testability"]

# ============================================================
# SECTION 15: RELATIONSHIPS
# ============================================================

relationships:
  commonly_combined:
    - "code-quality.testing.mutation-testing"
    - "code-quality.testing.unit-test-coverage"
