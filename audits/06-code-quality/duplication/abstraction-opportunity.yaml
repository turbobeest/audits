# ============================================================
# AUDIT: Abstraction Opportunity Analysis
# ============================================================

audit:
  id: "code-quality.duplication.abstraction-opportunity"
  name: "Abstraction Opportunity Analysis Audit"
  version: "1.0.0"
  last_updated: "2026-01-18"
  status: "active"

  category: "code-quality"
  category_number: 6
  subcategory: "duplication"

  tier: "expert"
  estimated_duration: "45 minutes"

  completeness: "requires_discovery"
  requires_runtime: false
  destructive: false

execution:
  automatable: "partial"
  severity: "medium"
  scope: "codebase"

  default_profiles:
    - "full"
    - "quality"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Analyzes the codebase to identify patterns that would benefit from
    abstraction, including repeated algorithmic patterns, similar data
    transformations, common interface patterns, and code that could be
    generalized through templates, generics, or polymorphism without
    introducing unnecessary complexity.

  why_it_matters: |
    Missed abstraction opportunities result in repeated implementation
    of similar logic, increasing maintenance burden and bug surface area.
    Well-designed abstractions reduce code size, improve testability,
    and make the codebase more comprehensible. However, premature or
    over-abstraction can also harm readability, so balance is key.

  when_to_run:
    - "Architecture reviews"
    - "Refactoring planning"
    - "Library design"
    - "Framework development"

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Application source code"

  access_requirements:
    - "Read access to source code"

discovery:
  code_patterns:
    - pattern: "similar function signatures across classes"
      type: "ast"
      scope: "source"
      purpose: "Interface extraction candidates"
    - pattern: "repeated algorithms with different types"
      type: "ast"
      scope: "source"
      purpose: "Generic/template candidates"
    - pattern: "similar switch/if-else chains"
      type: "ast"
      scope: "source"
      purpose: "Polymorphism candidates"

  file_patterns:
    - glob: "**/*.{js,ts,jsx,tsx,py,java,go,rb,cs}"
      purpose: "Source code files"

knowledge_sources:
  guides:
    - id: "design-patterns"
      name: "Design Patterns: Elements of Reusable Object-Oriented Software"
      url: "https://www.oreilly.com/library/view/design-patterns-elements/0201633612/"
      offline_cache: true

    - id: "refactoring"
      name: "Refactoring: Improving the Design of Existing Code"
      url: "https://refactoring.guru/"
      offline_cache: true

    - id: "refactoring-fowler"
      name: "Martin Fowler - Refactoring"
      url: "https://refactoring.com/"
      offline_cache: false

    - id: "refactoring-catalog"
      name: "Refactoring Catalog"
      url: "https://refactoring.com/catalog/"
      offline_cache: false

    - id: "clean-code"
      name: "Robert C. Martin - Clean Code"
      url: "https://www.oreilly.com/library/view/clean-code-a/9780136083238/"
      offline_cache: false

  learning_resources:
    - id: "design-patterns-book"
      title: "Design Patterns: Elements of Reusable Object-Oriented Software"
      type: "book"
      reference: "ISBN: 978-0201633610"

    - id: "refactoring-book"
      title: "Refactoring: Improving the Design of Existing Code"
      type: "book"
      reference: "ISBN: 978-0134757599"

tooling:
  static_analysis:
    - tool: "jscpd"
      purpose: "Pattern detection for abstraction"
      offline_capable: true
    - tool: "sonarqube"
      purpose: "Code smell detection"
      offline_capable: true
    - tool: "intellij"
      purpose: "Refactoring suggestions"
      offline_capable: true

  scripts:
    - id: "abstraction-scan"
      language: "bash"
      purpose: "Identify abstraction opportunities"
      source: "inline"
      code: |
        # Find similar method signatures
        grep -roh --include="*.py" "def [a-z_]+\([^)]*\)" . 2>/dev/null | \
          sed 's/self,\?\s*//' | sed 's/[a-z_]*=/ARG=/g' | sort | uniq -c | sort -rn | awk '$1 > 2' | head -20
        # Find switch/match patterns
        grep -rn --include="*.py" "if.*==.*:\|elif.*==.*:" . 2>/dev/null | wc -l
        # Find repeated type checks
        grep -rn --include="*.py" "isinstance\|type(" . 2>/dev/null | head -20

signals:
  critical:
    - id: "AO-CRIT-001"
      signal: "Critical algorithm implemented multiple times differently"
      evidence_pattern: "Same algorithm, different implementations"
      explanation: |
        When critical algorithms like sorting, searching, or business
        calculations have multiple implementations, bugs fixed in one
        may not be applied to others. Different performance characteristics
        may also cause inconsistent user experience.
      remediation: "Extract to single, well-tested implementation"

    - id: "AO-CRIT-002"
      signal: "Type-checking chains that should be polymorphism"
      evidence_pattern: "Long isinstance/typeof chains"
      cwe: "CWE-1047"
      explanation: |
        Extended type-checking chains indicate missed polymorphism
        opportunities. This anti-pattern makes code brittle and requires
        modification in multiple places when new types are added.
      remediation: "Apply Strategy or Visitor pattern"

  high:
    - id: "AO-HIGH-001"
      signal: "Similar data transformation logic repeated"
      evidence_pattern: "Map/filter/reduce patterns with similar lambdas"
      explanation: |
        Repeated data transformation patterns indicate opportunities for
        reusable transformation functions or pipeline abstractions that
        would improve consistency and testability.
      remediation: "Extract to named transformation functions"

    - id: "AO-HIGH-002"
      signal: "Interface extraction opportunity"
      evidence_pattern: "Multiple classes with same public methods"
      explanation: |
        Classes sharing method signatures without a common interface make
        it impossible to write generic code that works with all of them.
        This leads to duplication in client code.
      remediation: "Extract common interface or protocol"

  medium:
    - id: "AO-MED-001"
      signal: "Template method pattern opportunity"
      evidence_pattern: "Similar algorithms with different steps"
      remediation: "Apply Template Method pattern"

    - id: "AO-MED-002"
      signal: "Factory pattern opportunity"
      evidence_pattern: "Repeated object construction logic"
      remediation: "Apply Factory pattern"

  low:
    - id: "AO-LOW-001"
      signal: "Minor utility function extraction opportunity"
      evidence_pattern: "Small repeated code snippets"
      remediation: "Extract to utility function if used 3+ times"

  positive:
    - id: "AO-POS-001"
      signal: "Effective use of design patterns"
    - id: "AO-POS-002"
      signal: "Well-designed abstractions with clear interfaces"
    - id: "AO-POS-003"
      signal: "Appropriate use of generics/templates"

procedure:
  context:
    cognitive_mode: "critical"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Identify Repeated Patterns"
      description: |
        Use clone detection and pattern analysis to identify
        code segments that follow similar patterns.
      duration_estimate: "12 min"
      commands:
        - purpose: "Find similar function signatures"
          command: |
            grep -roh --include="*.py" "def [a-z_]+\([^)]*\)" . 2>/dev/null | \
              sed 's/self,\?\s*//' | sed 's/[a-z_]*=/ARG=/g' | sort | uniq -c | sort -rn | awk '$1 > 2' | head -20
        - purpose: "Find repeated structural patterns"
          command: |
            npx jscpd --min-lines 5 --min-tokens 25 . 2>/dev/null | head -40 || echo "Install jscpd"
      expected_findings:
        - "Repeated patterns"
        - "Abstraction candidates"

    - id: "2"
      name: "Analyze Type-Based Branching"
      description: |
        Find code that branches on type and could benefit
        from polymorphism.
      duration_estimate: "10 min"
      commands:
        - purpose: "Find isinstance chains"
          command: |
            grep -rn --include="*.py" "isinstance(" . 2>/dev/null | wc -l
        - purpose: "Sample type checking patterns"
          command: |
            grep -rn --include="*.py" -A2 "if isinstance\|elif isinstance" . 2>/dev/null | head -30
        - purpose: "Find type() comparisons"
          command: |
            grep -rn --include="*.py" "type([^)]*)\s*==" . 2>/dev/null | head -15
      expected_findings:
        - "Type-checking patterns"
        - "Polymorphism opportunities"

    - id: "3"
      name: "Identify Interface Patterns"
      description: |
        Find classes with similar method sets that could
        share an interface.
      duration_estimate: "12 min"
      commands:
        - purpose: "Find similar class definitions"
          command: |
            for cls in $(grep -roh --include="*.py" "class [A-Z][a-zA-Z]*" . 2>/dev/null | sed 's/class //' | sort -u | head -20); do
              echo "=== $cls ==="
              grep -rn --include="*.py" "class $cls" -A20 . 2>/dev/null | grep "def " | head -5
            done 2>/dev/null | head -60
        - purpose: "Find repeated method names"
          command: |
            grep -roh --include="*.py" "def [a-z_]+" . 2>/dev/null | sort | uniq -c | sort -rn | head -20
      expected_findings:
        - "Common method patterns"
        - "Interface candidates"

    - id: "4"
      name: "Evaluate Abstraction Value"
      description: |
        Assess which identified patterns would benefit from
        abstraction vs. those where duplication is acceptable.
      duration_estimate: "11 min"
      questions:
        - "Is the duplication accidental or intentional?"
        - "Would abstraction improve or harm readability?"
        - "How stable are the repeated patterns?"
        - "What is the cost of wrong abstraction?"
      expected_findings:
        - "Prioritized abstraction list"
        - "Risk assessment"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"
      content:
        - "abstraction_opportunities"
        - "pattern_analysis"
        - "refactoring_recommendations"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Pattern Analysis"
        - "Abstraction Recommendations"
        - "Implementation Guidance"

  confidence_guidance:
    high: "Comprehensive analysis with design review"
    medium: "Pattern detection with limited review"
    low: "Automated analysis only"

offline:
  capability: "full"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires deep analysis"
    full:
      included: true
      priority: 3
    quality:
      included: true
      priority: 2

closeout_checklist:
  - id: "ao-001"
    item: "Pattern analysis completed"
    level: "BLOCKING"
    verification: |
      echo "Pattern analysis complete" && echo "PASS"
    expected: "PASS"

  - id: "ao-002"
    item: "Type-checking patterns reviewed"
    level: "WARNING"
    verification: |
      grep -rn --include="*.py" "isinstance(" . 2>/dev/null | wc -l | awk '{print ($1 < 50) ? "PASS" : "FAIL"}'
    expected: "PASS"

governance:
  applicable_to:
    archetypes: ["all"]

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Maintainability", "Reusability"]

relationships:
  commonly_combined:
    - "code-quality.duplication.copy-paste-detection"
    - "code-quality.duplication.near-duplicate-code"
    - "code-quality.maintainability.code-organization"
