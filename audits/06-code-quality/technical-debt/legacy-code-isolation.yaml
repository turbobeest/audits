audit:
  id: code-quality.technical-debt.legacy-code-isolation
  name: Legacy Code Isolation Audit
  version: 1.0.0
  last_updated: '2026-01-18'
  status: active
  category: code-quality
  category_number: 6
  subcategory: technical-debt
  tier: expert
  estimated_duration: 2 hours
  completeness: complete
  requires_runtime: false
  destructive: false
execution:
  automatable: partial
  severity: medium
  scope: codebase
  default_profiles:
  - full
  - maintenance
  blocks_phase: false
  parallelizable: true
description:
  what: |
    Evaluates how effectively legacy code is isolated from modern code through
    architectural boundaries, interfaces, and encapsulation. Reviews whether
    legacy dependencies are contained, whether clear interfaces exist between
    legacy and modern systems, and whether the strangler fig pattern or similar
    strategies are employed for gradual modernization.
  why_it_matters: |
    Uncontained legacy code spreads its constraints throughout the codebase,
    preventing modernization and reducing development velocity. The strangler
    fig pattern, documented by Martin Fowler, enables gradual replacement by
    isolating legacy behind well-defined interfaces. Without isolation, legacy
    patterns infect new code and technical debt compounds.
  when_to_run:
  - Before modernization efforts
  - During architecture reviews
  - After acquiring legacy systems
  - Quarterly codebase assessments
prerequisites:
  required_artifacts:
  - type: source_code
    description: Complete codebase access
  - type: architecture
    description: System architecture documentation
  - type: dependency_graph
    description: Module dependency analysis
  access_requirements:
  - Read access to all source code
  - Access to architecture documentation
  - Ability to analyze dependencies
discovery:
  code_patterns:
  - pattern: legacy|LEGACY|Legacy
    type: regex
    scope: source
    purpose: Find legacy code references
  - pattern: adapter|Adapter|facade|Facade
    type: regex
    scope: source
    purpose: Find isolation patterns
  - pattern: wrapper|Wrapper|bridge|Bridge
    type: regex
    scope: source
    purpose: Find wrapping patterns
  - pattern: anti.?corruption|acl
    type: regex
    scope: source
    purpose: Find anti-corruption layers
  file_patterns:
  - glob: '**/legacy/**'
    purpose: Legacy code directories
  - glob: '**/adapters/**'
    purpose: Adapter implementations
  - glob: '**/facades/**'
    purpose: Facade implementations
knowledge_sources:
  specifications:
  - id: strangler-fig
    name: Strangler Fig Application
    url: https://martinfowler.com/bliki/StranglerFigApplication.html
    offline_cache: true
    priority: required
  guides:
  - id: ddd-acl
    name: DDD Anti-Corruption Layer
    url: https://docs.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer
    offline_cache: true
  - id: refactoring-fowler
    name: Martin Fowler - Refactoring
    url: https://refactoring.com/
    offline_cache: false
  - id: refactoring-catalog
    name: Refactoring Catalog
    url: https://refactoring.com/catalog/
    offline_cache: false
  - id: clean-code
    name: Robert C. Martin - Clean Code
    url: https://www.oreilly.com/library/view/clean-code-a/9780136083238/
    offline_cache: false
tooling:
  static_analysis:
  - tool: dependency-cruiser
    purpose: Analyze module dependencies
    offline_capable: true
  - tool: madge
    purpose: Circular dependency detection
    offline_capable: true
  scripts:
  - id: legacy-scan
    language: bash
    purpose: Find legacy code patterns
    source: inline
    code: |
      # Find legacy code references
      grep -rn --include="*.{js,ts,py,java,go,rb,cs}" \
        -i "legacy" .
signals:
  critical:
  - id: LEG-CRIT-001
    signal: Legacy code directly imported in modern modules
    evidence_pattern: import.*legacy|from legacy
    explanation: |
      Modern code directly depends on legacy implementations without
      abstraction. This couples new code to legacy constraints.
    remediation: Introduce adapters or facades to isolate legacy dependencies
  - id: LEG-CRIT-002
    signal: Circular dependencies with legacy
    evidence_pattern: legacy depends on modern and vice versa
    explanation: |
      Circular dependencies between legacy and modern code prevent
      clean extraction and replacement of legacy systems.
    remediation: Break cycles with dependency inversion and interfaces
  high:
  - id: LEG-HIGH-001
    signal: No architectural boundary for legacy
    evidence_pattern: legacy code mixed throughout codebase
    explanation: |
      Legacy code is scattered without clear boundaries, making
      it impossible to identify scope of legacy dependencies.
    remediation: Consolidate legacy into dedicated modules with clear interfaces
  - id: LEG-HIGH-002
    signal: Legacy types leaked to public APIs
    evidence_pattern: legacy types in API signatures
    explanation: |
      Legacy data types or interfaces are exposed in public APIs,
      preventing internal modernization without breaking changes.
    remediation: Transform to modern types at API boundaries
  medium:
  - id: LEG-MED-001
    signal: Missing anti-corruption layer
    evidence_pattern: direct legacy calls without translation
    remediation: Implement anti-corruption layer for legacy integration
  - id: LEG-MED-002
    signal: Inconsistent isolation patterns
    evidence_pattern: some legacy isolated, some not
    remediation: Apply consistent isolation strategy across all legacy
  low:
  - id: LEG-LOW-001
    signal: Undocumented legacy boundaries
    evidence_pattern: legacy isolation without documentation
    remediation: Document legacy boundaries and integration points
  positive:
  - id: LEG-POS-001
    signal: Clear legacy module boundaries
    evidence_pattern: legacy in dedicated directories
  - id: LEG-POS-002
    signal: Adapter pattern implemented
    evidence_pattern: adapters for legacy integration
  - id: LEG-POS-003
    signal: Anti-corruption layer present
    evidence_pattern: ACL for legacy systems
procedure:
  context:
    cognitive_mode: architectural
    ensemble_role: isolation-auditor
  steps:
  - id: '1'
    name: Identify Legacy Code
    description: |
      Locate all legacy code through naming conventions,
      documentation, and code age analysis.
    duration_estimate: 25 min
    commands:
    - purpose: Find legacy directories
      command: |
        find . -type d -iname "*legacy*" 2>/dev/null
    - purpose: Find legacy markers
      command: |
        grep -rn --include="*.{js,ts,py,java,go,rb,cs}" \
          -i "legacy" . | head -50
    expected_findings:
    - Legacy code inventory
    - Legacy boundaries
  - id: '2'
    name: Analyze Dependency Directions
    description: |
      Examine how legacy and modern code depend
      on each other.
    duration_estimate: 30 min
    commands:
    - purpose: Find legacy imports in modern code
      command: |
        grep -rn --include="*.{js,ts,py,java,go,rb,cs}" \
          -E "import.*legacy|from.*legacy|require.*legacy" .
    - purpose: Find modern imports in legacy
      command: |
        grep -rn --include="**/legacy/**/*.{js,ts,py,java,go}" \
          "import\|require\|from" . 2>/dev/null | head -30
    expected_findings:
    - Dependency direction analysis
    - Coupling assessment
  - id: '3'
    name: Review Isolation Patterns
    description: |
      Identify adapters, facades, and anti-corruption
      layers used for isolation.
    duration_estimate: 25 min
    commands:
    - purpose: Find adapters
      command: |
        find . -type f \( -iname "*adapter*" -o -iname "*facade*" \) 2>/dev/null
    - purpose: Find anti-corruption patterns
      command: |
        grep -rn --include="*.{js,ts,py,java,go,rb,cs}" \
          -i "anti.?corruption\|acl\|translator" .
    expected_findings:
    - Isolation pattern inventory
    - Coverage assessment
  - id: '4'
    name: Check API Boundaries
    description: |
      Verify legacy types and patterns are not
      exposed in public interfaces.
    duration_estimate: 20 min
    commands:
    - purpose: Find public API definitions
      command: |
        find . -type f \( -name "*.d.ts" -o -name "*api*.{js,ts,py}" \) 2>/dev/null
    - purpose: Check for legacy in APIs
      command: |
        grep -rn --include="*api*" -i "legacy" . 2>/dev/null
    expected_findings:
    - API boundary analysis
    - Leakage assessment
  - id: '5'
    name: Evaluate Strangler Progress
    description: |
      Assess progress on gradual legacy replacement
      if strangler pattern is in use.
    duration_estimate: 20 min
    commands:
    - purpose: Find replacement implementations
      command: |
        grep -rn --include="*.{js,ts,py,java,go,rb,cs}" \
          -i "new.*impl\|modern\|v2" .
    - purpose: Check feature flags
      command: |
        grep -rn --include="*.{js,ts,py,java,go,rb,cs}" \
          -i "feature.*flag\|toggle" .
    expected_findings:
    - Replacement progress
    - Feature flag usage
output:
  deliverables:
  - type: finding_list
    format: structured
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Legacy Code Map
    - Isolation Assessment
    - Dependency Analysis
    - Recommendations
  confidence_guidance:
    high: Well-isolated legacy with clear boundaries
    medium: Partial isolation with gaps
    low: Legacy scattered without isolation
offline:
  capability: full
  cache_manifest:
    knowledge:
    - source_id: strangler-fig
      priority: required
profiles:
  membership:
    quick:
      included: false
      reason: Requires architectural analysis
    full:
      included: true
      priority: 2
    maintenance:
      included: true
      priority: 1
closeout_checklist:
- id: leg-001
  item: Legacy code identified and documented
  level: REQUIRED
  verification: |
    find . -type d -iname "*legacy*" 2>/dev/null | wc -l
  expected: Documented inventory
- id: leg-002
  item: Isolation patterns in place
  level: BLOCKING
  verification: |
    find . -type f -iname "*adapter*" -o -iname "*facade*" 2>/dev/null | wc -l
  expected: Greater than 0 if legacy exists
- id: leg-003
  item: No legacy types in public APIs
  level: WARNING
  verification: Manual review of API definitions
  agent_alternative: Use static analysis tools to generate metrics; check for existing code review comments
  expected: Clean API boundaries
governance:
  applicable_to:
    archetypes:
    - all
  compliance_frameworks:
  - framework: ISO 25010
    controls:
    - Maintainability
    - Modularity
relationships:
  commonly_combined:
  - code-quality.technical-debt.migration-completeness
  - code-quality.technical-debt.deprecation-management
  - architecture-design.modularity.module-coupling
