audit:
  id: code-quality.test-code-quality.arrange-act-assert-pattern
  name: Arrange-Act-Assert Pattern Audit
  version: 1.0.0
  last_updated: '2026-01-18'
  status: active
  category: code-quality
  category_number: 6
  subcategory: test-code-quality
  tier: expert
  estimated_duration: 30 minutes
  completeness: complete
  requires_runtime: false
  destructive: false
execution:
  automatable: partial
  severity: medium
  scope: testing
  default_profiles:
  - full
  - quality
  blocks_phase: false
  parallelizable: true
description:
  what: |
    Evaluates whether tests follow the Arrange-Act-Assert (AAA) pattern,
    also known as Given-When-Then. This structure separates test setup
    (Arrange), execution of the code under test (Act), and verification
    of results (Assert) into clear, distinct phases.
  why_it_matters: |
    The AAA pattern makes tests more readable, maintainable, and easier
    to debug. Clear separation helps identify what is being tested and
    what the expected outcome is. Tests without this structure often
    mix concerns, making failures harder to diagnose and tests harder
    to modify.
  when_to_run:
  - During code reviews
  - Test suite refactoring
  - Style guide enforcement
  - New team member onboarding
prerequisites:
  required_artifacts:
  - type: test_code
    description: Test files
  access_requirements:
  - Read access to test directories
discovery:
  code_patterns:
  - pattern: // Arrange|// Act|// Assert|# Arrange|# Act|# Assert
    type: regex
    scope: testing
    purpose: Detect explicit AAA comments
  - pattern: Given|When|Then
    type: regex
    scope: testing
    purpose: Detect BDD-style Given-When-Then
  - pattern: expect.*expect.*expect.*expect
    type: regex
    scope: testing
    purpose: Detect multiple assertions (potential violation)
  file_patterns:
  - glob: '**/*.test.{js,ts,jsx,tsx}'
    purpose: Jest/Vitest test files
  - glob: '**/*.spec.{js,ts,jsx,tsx}'
    purpose: Spec files
  - glob: '**/test_*.py'
    purpose: Python test files
knowledge_sources:
  guides:
  - id: microsoft-aaa
    name: Microsoft - Unit Test Basics
    url: https://docs.microsoft.com/en-us/visualstudio/test/unit-test-basics
    offline_cache: true
  - id: martin-fowler-given-when-then
    name: Martin Fowler - GivenWhenThen
    url: https://martinfowler.com/bliki/GivenWhenThen.html
    offline_cache: true
  - id: xunit-patterns
    name: 'xUnit Test Patterns: Refactoring Test Code'
    url: https://www.amazon.com/xUnit-Test-Patterns-Refactoring-Code/dp/0131495054
    offline_cache: false
  - id: working-effectively-legacy
    name: Working Effectively with Legacy Code
    url: https://www.oreilly.com/library/view/working-effectively-with/0131177052/
    offline_cache: false
  learning_resources:
  - id: clean-code
    title: 'Clean Code: A Handbook of Agile Software Craftsmanship'
    type: book
    reference: 'Robert C. Martin, Chapter 9: Unit Tests'
tooling:
  static_analysis:
  - tool: eslint-plugin-jest
    purpose: Jest test structure linting
    offline_capable: true
  scripts:
  - id: aaa-pattern-scan
    language: bash
    purpose: Analyze test structure
    source: inline
    code: |
      echo "=== AAA Pattern Analysis ==="
      echo "--- Tests with explicit AAA comments ---"
      grep -rn "// Arrange\|// Act\|// Assert\|# Arrange\|# Act\|# Assert" \
        --include="*.test.js" --include="*.spec.ts" --include="test_*.py" . 2>/dev/null | wc -l

      echo "--- Tests with Given-When-Then ---"
      grep -rn "// Given\|// When\|// Then\|# Given\|# When\|# Then" \
        --include="*.test.js" --include="*.spec.ts" --include="test_*.py" . 2>/dev/null | wc -l

      echo "--- Tests with multiple assertions (may need review) ---"
      grep -rn "expect.*expect.*expect" --include="*.test.js" --include="*.spec.ts" . 2>/dev/null | wc -l
signals:
  critical:
  - id: AAA-CRIT-001
    signal: Tests with no clear structure (mixed arrange/act/assert)
    evidence_pattern: expect.*=.*expect.*=.*expect
    explanation: |
      Tests that interleave setup, execution, and assertion are hard to
      read and debug. It's unclear what is being tested or why.
    remediation: Refactor to separate Arrange, Act, and Assert phases
  - id: AAA-CRIT-002
    signal: Multiple actions in single test
    evidence_pattern: await.*await.*expect.*await.*expect
    explanation: |
      Tests that perform multiple actions and assertions are testing
      multiple behaviors, making failures ambiguous.
    remediation: Split into separate tests, one action per test
  high:
  - id: AAA-HIGH-001
    signal: Assertions scattered throughout test
    evidence_pattern: expect.*code.*expect.*code.*expect
    explanation: |
      Assertions mixed with code execution make it unclear what the
      test is verifying and what the expected state is.
    remediation: Collect all assertions at the end of the test
  - id: AAA-HIGH-002
    signal: Complex setup mixed with execution
    evidence_pattern: const.*=.*await.*await.*expect
    explanation: |
      When setup and execution are interleaved, it's hard to identify
      where the code under test begins.
    remediation: Use clear separation or helper functions for setup
  medium:
  - id: AAA-MED-001
    signal: Missing explicit AAA markers for complex tests
    evidence_pattern: Long tests without // Arrange comments
    remediation: Add section comments for tests >10 lines
  - id: AAA-MED-002
    signal: Assert-first pattern (assertions before action)
    evidence_pattern: expect.*function_call
    remediation: Move assertions after the action being tested
  - id: AAA-MED-003
    signal: Arrange phase too complex
    evidence_pattern: Setup > 50% of test
    remediation: Extract setup to fixtures or helper functions
  low:
  - id: AAA-LOW-001
    signal: Inconsistent commenting style for AAA
    evidence_pattern: Mixed // Arrange and // Setup comments
    remediation: Standardize on consistent terminology
  - id: AAA-LOW-002
    signal: Empty phases (e.g., no explicit arrange)
    evidence_pattern: Test starts directly with act
    remediation: Add comment indicating no setup needed or use beforeEach
  positive:
  - id: AAA-POS-001
    signal: Consistent AAA structure with comments
    evidence_pattern: // Arrange.*// Act.*// Assert pattern
  - id: AAA-POS-002
    signal: Single assertion per test
    evidence_pattern: One expect() per it()/test()
  - id: AAA-POS-003
    signal: Clear Given-When-Then naming
    evidence_pattern: Test names follow GWT pattern
procedure:
  context:
    cognitive_mode: evaluative
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Check for Explicit AAA Markers
    description: |
      Search for tests that explicitly mark AAA sections.
    duration_estimate: 5 min
    commands:
    - purpose: Find AAA comments
      command: |
        grep -rn "// Arrange\|// Act\|// Assert" \
          --include="*.test.js" --include="*.spec.ts" . 2>/dev/null | head -30
    - purpose: Find Given-When-Then comments
      command: |
        grep -rn "// Given\|// When\|// Then" \
          --include="*.test.js" --include="*.spec.ts" . 2>/dev/null | head -30
    expected_findings:
    - Tests with explicit structure
    - Marker usage statistics
  - id: '2'
    name: Analyze Test Structure
    description: |
      Examine test bodies for proper AAA separation.
    duration_estimate: 15 min
    commands:
    - purpose: Find tests with scattered assertions
      command: |
        grep -rn "expect.*=.*expect\|assert.*=.*assert" \
          --include="*.test.js" --include="*.spec.ts" --include="test_*.py" . 2>/dev/null | head -20
    - purpose: Count assertions per test (sample)
      command: |
        for f in $(find . \( find . -name "*.test.js" -o -name "*.spec.ts" \) | head -10); do
          echo "=== $f ===" && grep -c "expect\|assert" "$f" 2>/dev/null || echo "0"
        done
    expected_findings:
    - Tests with structural issues
    - Assertion density
  - id: '3'
    name: Identify Complex Tests
    description: |
      Find tests that are too long or complex for clear AAA structure.
    duration_estimate: 5 min
    commands:
    - purpose: Find long tests
      command: |
        awk '/it\(|test\(/{start=NR} /^\s*\}\);?$/{if(start && NR-start>30) print FILENAME":"start": long test ("NR-start" lines)"; start=0}' \
          $(find . \( find . -name "*.test.js" -o -name "*.spec.ts" \) | head -20) 2>/dev/null
    expected_findings:
    - Oversized tests
    - Refactoring candidates
  - id: '4'
    name: Generate Compliance Report
    description: |
      Summarize AAA pattern compliance across the test suite.
    duration_estimate: 5 min
    expected_findings:
    - AAA compliance score
    - Priority fix list
output:
  deliverables:
  - type: finding_list
    format: structured
    content:
    - structural_violations
    - complex_tests
    - improvement_candidates
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Structure Analysis
    - Refactoring Recommendations
  confidence_guidance:
    high: Clear structural violation detected
    medium: Pattern suggests potential issue
    low: Requires manual structure review
offline:
  capability: full
  cache_manifest:
    knowledge:
    - source_id: clean-code
      priority: recommended
profiles:
  membership:
    quick:
      included: false
      reason: Requires detailed analysis
    full:
      included: true
      priority: 2
    quality:
      included: true
      priority: 1
closeout_checklist:
- id: aaa-001
  item: No tests with interleaved structure
  level: CRITICAL
  verification: Pattern analysis completed
  expected: Zero structural violations
- id: aaa-002
  item: Long tests have explicit markers
  level: WARNING
  verification: Tests >20 lines have // Arrange comments
  expected: All long tests marked
- id: aaa-003
  item: Team convention documented
  level: BLOCKING
  verification: AAA or GWT pattern chosen
  expected: Documented in style guide
governance:
  applicable_to:
    archetypes:
    - all
  compliance_frameworks:
  - framework: ISO 25010
    controls:
    - Maintainability
    - Testability
relationships:
  commonly_combined:
  - code-quality.test-code-quality.test-readability
  - code-quality.test-code-quality.assertion-quality
