# ============================================================
# AUDIT: Self-Documenting Code
# ============================================================

audit:
  id: "code-quality.readability.self-documenting-code"
  name: "Self-Documenting Code Audit"
  version: "1.0.0"
  last_updated: "2026-01-18"
  status: "active"

  category: "code-quality"
  category_number: 6
  subcategory: "readability"

  tier: "expert"
  estimated_duration: "45 minutes"

  completeness: "requires_discovery"
  requires_runtime: false
  destructive: false

execution:
  automatable: "partial"
  severity: "medium"
  scope: "codebase"

  default_profiles:
    - "full"
    - "quality"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Evaluates whether code is written in a self-documenting style where
    the code itself clearly communicates intent without requiring excessive
    comments. Assesses use of meaningful names, clear structure, small
    focused functions, and appropriate abstraction levels that make code
    readable without separate documentation.

  why_it_matters: |
    Self-documenting code reduces the maintenance burden of keeping comments
    and documentation in sync with code. Comments lie over time as code
    changes but comments don't. Code that explains itself through structure
    and naming is more maintainable, less prone to documentation drift, and
    easier for new developers to understand.

  when_to_run:
    - "Code review processes"
    - "Refactoring initiatives"
    - "Technical debt assessments"
    - "New team member feedback"

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Application source code"

  access_requirements:
    - "Read access to source code"

discovery:
  code_patterns:
    - pattern: "#\\s*TODO|#\\s*FIXME|#\\s*HACK|#\\s*XXX"
      type: "regex"
      scope: "source"
      purpose: "Find code requiring explanation"
    - pattern: "#.*what|#.*how|#.*why"
      type: "regex"
      scope: "source"
      purpose: "Find explanatory comments"
    - pattern: "\\bdef\\s+[a-z_]+\\([^)]{100,}\\)"
      type: "regex"
      scope: "source"
      purpose: "Functions with many parameters"

  file_patterns:
    - glob: "**/*.{js,ts,jsx,tsx,py,java,go,rb,cs}"
      purpose: "Source code files"

knowledge_sources:
  guides:
    - id: "clean-code"
      name: "Clean Code Principles"
      url: "https://www.oreilly.com/library/view/clean-code/9780136083238/"
      offline_cache: true

    - id: "self-doc-code"
      name: "The Art of Readable Code"
      url: "https://www.oreilly.com/library/view/the-art-of/9781449318482/"
      offline_cache: true

    - id: "pragmatic-programmer"
      name: "The Pragmatic Programmer"
      url: "https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/"
      offline_cache: false

  learning_resources:
    - id: "clean-code-book"
      title: "Clean Code: A Handbook of Agile Software Craftsmanship"
      type: "book"
      reference: "ISBN: 978-0132350884"

    - id: "readable-code-book"
      title: "The Art of Readable Code"
      type: "book"
      reference: "ISBN: 978-0596802295"

tooling:
  static_analysis:
    - tool: "pylint"
      purpose: "Function complexity and length analysis"
      offline_capable: true
    - tool: "eslint"
      purpose: "Code complexity rules"
      offline_capable: true
    - tool: "lizard"
      purpose: "Cyclomatic complexity analysis"
      offline_capable: true

  scripts:
    - id: "self-doc-scan"
      language: "bash"
      purpose: "Analyze code self-documentation"
      source: "inline"
      code: |
        # Find functions over 50 lines
        awk '/^def /{name=$0; lines=0} /^def /,/^def |^class /{lines++} lines>50{print name": "lines" lines"}' *.py 2>/dev/null
        # Find deeply nested code
        grep -rn --include="*.py" "^        if\|^            if" . 2>/dev/null | head -20

signals:
  critical:
    - id: "SDC-CRIT-001"
      signal: "Critical business logic requires extensive comments to understand"
      evidence_pattern: "Comment-heavy sections with complex logic"
      explanation: |
        When code requires paragraph-length comments to explain what it does,
        the code structure itself is failing to communicate. This indicates
        the logic should be refactored into clearly named functions.
      remediation: "Refactor into well-named functions and helper methods"

    - id: "SDC-CRIT-002"
      signal: "Comments contradict code behavior"
      evidence_pattern: "Comments that don't match what code does"
      explanation: |
        Stale comments that describe different behavior than the code actually
        performs are worse than no comments at all. They actively mislead
        developers and cause bugs.
      remediation: "Delete misleading comments, refactor code to be self-explanatory"

  high:
    - id: "SDC-HIGH-001"
      signal: "Functions exceeding 50 lines requiring scroll to understand"
      evidence_pattern: "Long function bodies"
      cwe: "CWE-1075"
      explanation: |
        Functions longer than one screen cannot be understood at a glance.
        They typically do multiple things and should be broken into smaller,
        well-named functions that each do one thing.
      remediation: "Extract logical sections into named helper functions"

    - id: "SDC-HIGH-002"
      signal: "Deep nesting requiring comments to explain levels"
      evidence_pattern: "More than 4 levels of indentation"
      explanation: |
        Deeply nested code (more than 3-4 levels) is hard to follow and
        indicates complex conditional logic that should be simplified
        through early returns, guard clauses, or extraction.
      remediation: "Use early returns and extract nested logic"

  medium:
    - id: "SDC-MED-001"
      signal: "Boolean expressions that need comments"
      evidence_pattern: "Complex boolean with explaining comment"
      remediation: "Extract to well-named boolean variable or function"

    - id: "SDC-MED-002"
      signal: "Inline calculations without clear meaning"
      evidence_pattern: "Arithmetic operations without context"
      remediation: "Extract to named constants or explaining variables"

  low:
    - id: "SDC-LOW-001"
      signal: "Comments explaining what instead of why"
      evidence_pattern: "# increment counter style comments"
      remediation: "Remove obvious comments, add why comments where needed"

  positive:
    - id: "SDC-POS-001"
      signal: "Small, focused functions with descriptive names"
    - id: "SDC-POS-002"
      signal: "Explaining variables for complex expressions"
    - id: "SDC-POS-003"
      signal: "Guard clauses reduce nesting"

procedure:
  context:
    cognitive_mode: "critical"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Analyze Function Sizes"
      description: |
        Identify functions that are too long to be easily understood
        without scrolling or extensive analysis.
      duration_estimate: "10 min"
      commands:
        - purpose: "Find long functions"
          command: |
            lizard -l python -l javascript . 2>/dev/null | awk '$2 > 50 {print}' | head -20 || echo "Install lizard: pip install lizard"
        - purpose: "Count functions by size"
          command: |
            lizard . 2>/dev/null | awk 'NR>2 {if($2<=10)s++; else if($2<=30)m++; else l++} END{print "Small:", s, "Medium:", m, "Large:", l}' || echo "Lizard not installed"
      expected_findings:
        - "Function size distribution"
        - "Largest functions"

    - id: "2"
      name: "Check Nesting Depth"
      description: |
        Find deeply nested code that is hard to follow and
        understand.
      duration_estimate: "10 min"
      commands:
        - purpose: "Find deep nesting in Python"
          command: |
            grep -rn --include="*.py" "^                    " . 2>/dev/null | wc -l
        - purpose: "Sample deeply nested code"
          command: |
            grep -rn --include="*.py" "^                if\|^                for\|^                while" . 2>/dev/null | head -10
      expected_findings:
        - "Deeply nested code locations"
        - "Nesting patterns"

    - id: "3"
      name: "Evaluate Comment Quality"
      description: |
        Analyze comments to determine if they explain why rather
        than what, and identify areas needing refactoring.
      duration_estimate: "15 min"
      commands:
        - purpose: "Find TODO/FIXME comments"
          command: |
            grep -rn --include="*.{py,js,ts}" -E "#\s*(TODO|FIXME|HACK|XXX)" . 2>/dev/null | wc -l
        - purpose: "Sample explanatory comments"
          command: |
            grep -rn --include="*.py" -E "^\s*#\s*[A-Z]" . 2>/dev/null | head -20
      expected_findings:
        - "Comment patterns"
        - "Areas needing clarification"

    - id: "4"
      name: "Check for Explaining Variables"
      description: |
        Look for complex expressions that would benefit from
        being assigned to explaining variables.
      duration_estimate: "10 min"
      commands:
        - purpose: "Find complex conditionals"
          command: |
            grep -rn --include="*.py" "if.*and.*and\|if.*or.*or" . 2>/dev/null | head -15
        - purpose: "Find inline calculations"
          command: |
            grep -rn --include="*.py" "return.*[+\-\*/].*[+\-\*/]" . 2>/dev/null | head -15
      expected_findings:
        - "Complex expressions"
        - "Refactoring opportunities"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"
      content:
        - "long_functions"
        - "deep_nesting"
        - "complex_expressions"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Code Clarity Analysis"
        - "Refactoring Opportunities"
        - "Recommendations"

  confidence_guidance:
    high: "Comprehensive analysis with tooling support"
    medium: "Representative sampling with clear patterns"
    low: "Limited scope or subjective assessment"

offline:
  capability: "full"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires in-depth analysis"
    full:
      included: true
      priority: 2
    quality:
      included: true
      priority: 1

closeout_checklist:
  - id: "sdc-001"
    item: "No functions exceeding 100 lines"
    level: "WARNING"
    verification: |
      lizard . 2>/dev/null | awk '$2 > 100 {count++} END{print (count+0 == 0) ? "PASS" : "FAIL"}' || echo "SKIP"
    expected: "PASS"

  - id: "sdc-002"
    item: "Limited deep nesting (>5 levels)"
    level: "WARNING"
    verification: |
      grep -rn --include="*.py" "^                        " . 2>/dev/null | wc -l | awk '{print ($1 < 10) ? "PASS" : "FAIL"}'
    expected: "PASS"

governance:
  applicable_to:
    archetypes: ["all"]

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Maintainability", "Readability"]

relationships:
  commonly_combined:
    - "code-quality.readability.naming-convention"
    - "code-quality.readability.variable-name-clarity"
    - "code-quality.maintainability.cyclomatic-complexity"
