audit:
  id: code-quality.readability.boolean-expression-clarity
  name: Boolean Expression Clarity Audit
  version: 1.0.0
  last_updated: '2026-01-18'
  status: active
  category: code-quality
  category_number: 6
  subcategory: readability
  tier: expert
  estimated_duration: 25 minutes
  completeness: complete
  requires_runtime: false
  destructive: false
execution:
  automatable: partial
  severity: medium
  scope: codebase
  default_profiles:
  - full
  - quality
  blocks_phase: false
  parallelizable: true
description:
  what: |
    Evaluates boolean expressions throughout the codebase for clarity and
    readability. Identifies overly complex conditions, double negatives,
    confusing operator precedence, deeply nested boolean logic, and
    expressions that would benefit from extraction into named variables
    or functions.
  why_it_matters: |
    Complex boolean expressions are a major source of logic bugs. Research
    shows that expressions with more than 3 conditions have a 40% higher
    defect rate. Double negatives and confusing precedence lead to incorrect
    assumptions and inverted logic. Clear boolean expressions are essential
    for correct code and effective code review.
  when_to_run:
  - Code review processes
  - Bug investigation
  - Refactoring complex conditions
  - Security-sensitive code review
prerequisites:
  required_artifacts:
  - type: source_code
    description: Application source code
  access_requirements:
  - Read access to source code
discovery:
  code_patterns:
  - pattern: not\s+.*not\s+|!.*!
    type: regex
    scope: source
    purpose: Detect double negatives
  - pattern: \band\b.*\band\b.*\band\b|&&.*&&.*&&
    type: regex
    scope: source
    purpose: Detect complex AND chains
  - pattern: \bor\b.*\bor\b.*\bor\b|\|\|.*\|\|.*\|\|
    type: regex
    scope: source
    purpose: Detect complex OR chains
  - pattern: \band\b.*\bor\b|\bor\b.*\band\b
    type: regex
    scope: source
    purpose: Detect mixed AND/OR without parentheses
  - pattern: 'if\s+not\s+[a-z_]+\s*:'
    type: regex
    scope: source
    purpose: Detect negated conditions
  file_patterns:
  - glob: '**/*.{js,ts,jsx,tsx,py,java,go,rb,cs}'
    purpose: Source code files
knowledge_sources:
  guides:
  - id: clean-code
    name: Clean Code - Meaningful Names
    url: https://www.oreilly.com/library/view/clean-code/9780136083238/
    offline_cache: true
  - id: readable-code
    name: The Art of Readable Code
    url: https://www.oreilly.com/library/view/the-art-of/9781449318482/
    offline_cache: true
  - id: pragmatic-programmer
    name: The Pragmatic Programmer
    url: https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/
    offline_cache: false
  learning_resources:
  - id: readable-code-book
    title: The Art of Readable Code
    type: book
    reference: 'ISBN: 978-0596802295, Chapter 7'
tooling:
  static_analysis:
  - tool: eslint
    purpose: Complexity rules for conditions
    offline_capable: true
  - tool: pylint
    purpose: Boolean expression analysis
    offline_capable: true
  - tool: sonarqube
    purpose: Cognitive complexity analysis
    offline_capable: true
  scripts:
  - id: boolean-scan
    language: bash
    purpose: Detect unclear boolean expressions
    source: inline
    code: |
      # Find double negatives
      grep -rn --include="*.py" "not.*not\|!.*!" . 2>/dev/null | head -10
      # Find complex boolean chains
      grep -rn --include="*.py" -E "\band\b.*\band\b.*\band\b" . 2>/dev/null | head -10
      # Find mixed and/or without clear grouping
      grep -rn --include="*.py" -E "if.*\band\b.*\bor\b|if.*\bor\b.*\band\b" . 2>/dev/null | head -15
signals:
  critical:
  - id: BEC-CRIT-001
    signal: Double negatives in security-critical conditions
    evidence_pattern: not.*not in auth/permission checks
    cwe: CWE-480
    explanation: |
      Double negatives in security conditions (e.g., "not user.is_not_authorized")
      are extremely error-prone and have caused major security vulnerabilities.
      The mental gymnastics required lead to incorrect assumptions.
    remediation: Rewrite with positive conditions and extract to named function
  - id: BEC-CRIT-002
    signal: Complex boolean in access control without extraction
    evidence_pattern: Long boolean chain in permission check
    cwe: CWE-480
    explanation: |
      Complex boolean expressions for access control are security risks.
      Each additional condition increases the chance of logic errors that
      could grant or deny access incorrectly.
    remediation: Extract to clearly named permission-checking function
  high:
  - id: BEC-HIGH-001
    signal: Boolean expression with more than 4 conditions
    evidence_pattern: 4+ conditions combined with and/or
    explanation: |
      Expressions with many conditions exceed human working memory capacity.
      Studies show comprehension drops sharply after 3-4 conditions, leading
      to misunderstanding and bugs.
    remediation: Break into multiple named variables or helper functions
  - id: BEC-HIGH-002
    signal: Mixed AND/OR without explicit parentheses
    evidence_pattern: and.*or without grouping parentheses
    explanation: |
      Mixed logical operators without parentheses rely on operator precedence
      rules that many developers don't remember correctly. This leads to
      unexpected behavior.
    remediation: Add explicit parentheses to clarify grouping
  medium:
  - id: BEC-MED-001
    signal: Negated conditions that could be positive
    evidence_pattern: if not condition style
    remediation: Consider inverting to positive condition
  - id: BEC-MED-002
    signal: Nested ternary/conditional expressions
    evidence_pattern: 'condition ? (nested ? a : b) : c'
    remediation: Extract to if-else or separate variables
  low:
  - id: BEC-LOW-001
    signal: Redundant boolean comparisons
    evidence_pattern: if x == True or if x == False
    remediation: Use if x or if not x
  positive:
  - id: BEC-POS-001
    signal: Complex conditions extracted to explaining variables
  - id: BEC-POS-002
    signal: Boolean functions with clear names for conditions
  - id: BEC-POS-003
    signal: Parentheses used to clarify operator precedence
procedure:
  context:
    cognitive_mode: critical
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Find Complex Boolean Expressions
    description: |
      Search for boolean expressions with multiple conditions
      that may be difficult to understand.
    duration_estimate: 8 min
    commands:
    - purpose: Find long AND chains
      command: |
        grep -rn --include="*.py" -E "\band\b.*\band\b.*\band\b" . 2>/dev/null | wc -l
    - purpose: Find long OR chains
      command: |
        grep -rn --include="*.py" -E "\bor\b.*\bor\b.*\bor\b" . 2>/dev/null | wc -l
    - purpose: Sample complex expressions
      command: |
        grep -rn --include="*.py" -E "if.*\b(and|or)\b.*\b(and|or)\b.*\b(and|or)\b" . 2>/dev/null | head -15
    expected_findings:
    - Count of complex expressions
    - Example problematic conditions
  - id: '2'
    name: Detect Double Negatives
    description: |
      Find expressions using double negation which are
      confusing and error-prone.
    duration_estimate: 5 min
    commands:
    - purpose: Find double negatives
      command: |
        grep -rn --include="*.py" -E "not\s+.*not\s+|!\s*.*!\s*" . 2>/dev/null | head -15
    - purpose: Find negated function calls
      command: |
        grep -rn --include="*.py" "not\s+[a-z_]+\.(is_not|has_no|cannot)" . 2>/dev/null | head -10
    expected_findings:
    - Double negative locations
    - Confusing negation patterns
  - id: '3'
    name: Check Operator Precedence Clarity
    description: |
      Identify mixed AND/OR expressions without explicit
      parentheses for grouping.
    duration_estimate: 7 min
    commands:
    - purpose: Find mixed operators
      command: |
        grep -rn --include="*.py" -E "if\s+[^(]*\band\b[^)]*\bor\b" . 2>/dev/null | head -15
    - purpose: Check for missing parentheses
      command: |
        grep -rn --include="*.py" -E "\bor\b\s+[a-z_]+\s+\band\b" . 2>/dev/null | head -10
    expected_findings:
    - Unclear precedence locations
    - Parentheses needed
  - id: '4'
    name: Review Security-Critical Conditions
    description: |
      Examine boolean expressions in authentication, authorization,
      and security-related code.
    duration_estimate: 5 min
    commands:
    - purpose: Find auth-related conditions
      command: |
        grep -rn --include="*.py" -E "if.*(auth|permission|allowed|denied|access)" . 2>/dev/null | head -15
    - purpose: Check complexity of auth conditions
      command: |
        grep -rn --include="*.py" -E "if.*auth.*\b(and|or)\b.*\b(and|or)\b" . 2>/dev/null | head -10
    expected_findings:
    - Security condition complexity
    - High-risk expressions
output:
  deliverables:
  - type: finding_list
    format: structured
    content:
    - complex_expressions
    - double_negatives
    - unclear_precedence
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Boolean Expression Analysis
    - Security-Critical Findings
    - Recommendations
  confidence_guidance:
    high: Comprehensive analysis with security review
    medium: Pattern matching without context analysis
    low: Limited sample or grep-only analysis
offline:
  capability: full
profiles:
  membership:
    quick:
      included: false
      reason: Requires careful analysis
    full:
      included: true
      priority: 2
    quality:
      included: true
      priority: 1
closeout_checklist:
- id: bec-001
  item: No double negatives in security code
  level: CRITICAL
  verification: |
    grep -rn --include="*.py" -E "not.*not.*(auth|permission|access)" . 2>/dev/null | wc -l | awk '{print ($1 == 0) ? "PASS" : "FAIL"}'
  expected: PASS
- id: bec-002
  item: Limited complex boolean expressions
  level: WARNING
  verification: |
    grep -rn --include="*.py" -E "\b(and|or)\b.*\b(and|or)\b.*\b(and|or)\b.*\b(and|or)\b" . 2>/dev/null | wc -l | awk '{print ($1 < 5) ? "PASS" : "FAIL"}'
  expected: PASS
governance:
  applicable_to:
    archetypes:
    - all
  compliance_frameworks:
  - framework: CWE
    controls:
    - CWE-480
    - CWE-697
  - framework: ISO 25010
    controls:
    - Maintainability
relationships:
  commonly_combined:
  - code-quality.readability.self-documenting-code
  - code-quality.readability.control-flow-clarity
  - code-quality.maintainability.cyclomatic-complexity
