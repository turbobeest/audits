audit:
  id: code-quality.maintainability.function-length
  name: Function Length Audit
  version: 1.0.0
  last_updated: '2026-01-18'
  status: active
  category: code-quality
  category_number: 6
  subcategory: maintainability
  tier: expert
  estimated_duration: 30 minutes
  completeness: complete
  requires_runtime: false
  destructive: false
execution:
  automatable: full
  severity: medium
  scope: codebase
  default_profiles:
  - full
  - quality
  blocks_phase: false
  parallelizable: true
description:
  what: |
    Measures the length of functions and methods in lines of code (LOC).
    Identifies functions that exceed recommended size thresholds, indicating
    potential violations of single responsibility principle and opportunities
    for decomposition.
  why_it_matters: |
    Long functions are harder to understand, test, and maintain. Research
    shows functions exceeding 30 lines have 3x higher defect density.
    Robert C. Martin recommends functions be "small" (under 20 lines).
    Long functions often violate single responsibility principle and
    indicate opportunities for extraction and reuse.
  when_to_run:
  - During code reviews
  - Refactoring planning
  - Technical debt assessments
  - Codebase health checks
prerequisites:
  required_artifacts:
  - type: source_code
    description: Application source code
  access_requirements:
  - Read access to source code
discovery:
  file_patterns:
  - glob: '**/*.{js,ts,py,java,go,rb,cs,cpp,c}'
    purpose: Source code files
knowledge_sources:
  guides:
  - id: clean-code
    name: Clean Code - Functions Chapter
    url: https://www.oreilly.com/library/view/clean-code-a/9780136083238/
    offline_cache: true
    priority: required
  - id: pragmatic-programmer
    name: The Pragmatic Programmer
    url: https://pragprog.com/titles/tpp20/the-pragmatic-programmer-20th-anniversary-edition/
    offline_cache: false
tooling:
  static_analysis:
  - tool: eslint
    purpose: JavaScript/TypeScript function length
    offline_capable: true
  - tool: lizard
    purpose: Multi-language function analysis
    offline_capable: true
  scripts:
  - id: function-length-check
    language: bash
    purpose: Find long functions
    source: inline
    code: |
      lizard -T nloc=50 . 2>/dev/null
signals:
  critical:
  - id: FL-CRIT-001
    signal: Functions exceeding 200 lines
    evidence_pattern: function_lines > 200
    cwe: CWE-1080
    explanation: |
      Extremely long functions are effectively unmaintainable, violate
      all principles of good design, and are prime sources of defects.
    remediation: Decompose into smaller focused functions immediately
  high:
  - id: FL-HIGH-001
    signal: Functions between 100-200 lines
    evidence_pattern: 100 < function_lines <= 200
    cwe: CWE-1080
    explanation: |
      Functions of this length are difficult to understand fully,
      likely contain multiple responsibilities, and are hard to test.
    remediation: Extract logical sections into separate functions
  - id: FL-HIGH-002
    signal: More than 20% of functions exceed 50 lines
    evidence_pattern: long_function_ratio > 20%
    explanation: |
      Systematic issue with function size indicates codebase-wide
      maintainability problems.
    remediation: Establish function length limits and refactor gradually
  medium:
  - id: FL-MED-001
    signal: Functions between 50-100 lines
    evidence_pattern: 50 < function_lines <= 100
    remediation: Consider splitting when making modifications
  low:
  - id: FL-LOW-001
    signal: No function length limits configured
    evidence_pattern: no_length_rules
    remediation: Add max-lines-per-function to linting rules
  positive:
  - id: FL-POS-001
    signal: Average function length under 20 lines
    evidence_pattern: avg_length < 20
  - id: FL-POS-002
    signal: No functions exceed 50 lines
    evidence_pattern: max_length <= 50
procedure:
  context:
    cognitive_mode: analytical
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Measure Function Lengths
    description: |
      Scan all source files to measure the length of every
      function and method.
    duration_estimate: 10 min
    commands:
    - purpose: Run lizard length analysis
      command: |
        lizard -L 50 . 2>/dev/null | head -100
    - purpose: ESLint function length check
      command: |
        npx eslint --rule 'max-lines-per-function: [warn, 50]' . 2>/dev/null
    expected_findings:
    - Per-function line counts
    - Functions exceeding thresholds
  - id: '2'
    name: Identify Longest Functions
    description: |
      Sort functions by length and create a prioritized list
      of refactoring candidates.
    duration_estimate: 10 min
    expected_findings:
    - Top 20 longest functions
    - Distribution by length category
  - id: '3'
    name: Analyze by Module
    description: |
      Calculate average function length per module to identify
      areas with systemic issues.
    duration_estimate: 10 min
    expected_findings:
    - Average length per module
    - Modules with worst metrics
output:
  deliverables:
  - type: metrics
    format: structured
    content:
    - function_length_list
    - avg_function_length
    - max_function_length
    - length_distribution
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Length Distribution
    - Hotspot Analysis
    - Recommendations
  confidence_guidance:
    high: Full codebase analysis with tooling
    medium: Partial analysis or sampling
    low: Manual spot checks
offline:
  capability: full
  cache_manifest:
    knowledge:
    - source_id: clean-code
      priority: required
profiles:
  membership:
    quick:
      included: true
      priority: 2
    full:
      included: true
      priority: 1
    quality:
      included: true
      priority: 1
closeout_checklist:
- id: fl-001
  item: Function length analysis complete
  level: BLOCKING
  verification: All functions measured
  expected: Complete length inventory
- id: fl-002
  item: Long functions documented
  level: WARNING
  verification: List of functions > 50 lines
  expected: Refactoring candidates identified
governance:
  applicable_to:
    archetypes:
    - all
  compliance_frameworks:
  - framework: ISO 25010
    controls:
    - Maintainability
  - framework: CWE
    controls:
    - CWE-1080
relationships:
  commonly_combined:
  - code-quality.maintainability.cyclomatic-complexity
  - code-quality.maintainability.file-length
  - code-quality.maintainability.cohesion
