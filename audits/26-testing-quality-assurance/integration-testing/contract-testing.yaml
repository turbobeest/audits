# ============================================================
# AUDIT: Contract Testing
# ============================================================
# Evaluates contract testing practices to verify service
# interfaces remain compatible.
# ============================================================

audit:
  id: "testing-quality-assurance.integration-testing.contract-testing"
  name: "Contract Testing"
  version: "1.0.0"
  last_updated: "2026-01-22"
  status: "active"

  category: "testing-quality-assurance"
  category_number: 26
  subcategory: "integration-testing"

  tier: "expert"
  estimated_duration: "2-3 hours"  # median: 2h

  completeness: "complete"
  requires_runtime: true
  destructive: false

execution:
  automatable: "yes"
  severity: "high"
  scope: "testing"

  default_profiles:
    - "full"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Evaluates contract testing implementation including consumer-driven
    contracts, provider verification, API schema validation, and breaking
    change detection. Verifies that service interfaces are tested
    independently and changes are validated before deployment.

  why_it_matters: |
    Contract testing prevents integration failures in microservices
    architectures. Traditional integration tests require all services
    running together, which is slow and flaky. Contract tests verify
    compatibility independently, catching breaking changes before they
    reach production and enabling confident independent deployments.

  when_to_run:
    - "API schema changes"
    - "Service interface modifications"
    - "New consumer onboarding"
    - "CI/CD pipeline validation"

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Service code with API definitions"
    - type: "api_contracts"
      description: "Contract files (Pact, OpenAPI, etc.)"

  access_requirements:
    - "Source code repository access"
    - "Contract broker access (if using Pact)"
    - "Schema registry access (if applicable)"

discovery:
  file_patterns:
    - glob: "**/pacts/**"
      purpose: "Pact contract files"
    - glob: "**/*.pact.json"
      purpose: "Pact JSON contracts"
    - glob: "**/contracts/**"
      purpose: "Contract test directory"
    - glob: "**/openapi*.yaml"
      purpose: "OpenAPI specifications"

  code_patterns:
    - pattern: "@Pact|PactVerifier|pact-jvm"
      type: "regex"
      scope: "test"
      purpose: "Pact testing framework"
    - pattern: "openapi|swagger|schema-validator"
      type: "regex"
      scope: "config"
      purpose: "Schema validation"
    - pattern: "consumer|provider|contract"
      type: "regex"
      scope: "test"
      purpose: "Contract test patterns"

knowledge_sources:
  specifications:
    - id: "pact-spec"
      name: "Pact Specification"
      url: "https://pact.io/"
      offline_cache: true
      priority: "required"

  guides:
    - id: "contract-testing-guide"
      name: "Contract Testing Guide"
      url: "https://martinfowler.com/articles/consumerDrivenContracts.html"
      offline_cache: true
    - id: "pact-best-practices"
      name: "Pact Best Practices"
      url: "https://docs.pact.io/best_practices"
      offline_cache: true

  learning_resources:
    - id: "contract-testing-book"
      title: "Contract Testing in Action"
      type: "article"
      reference: "https://pactflow.io/how-pact-works/"

tooling:
  static_analysis:
    - tool: "Pact"
      purpose: "Consumer-driven contract testing"
      offline_capable: true
    - tool: "Spring Cloud Contract"
      purpose: "Java contract testing"
      offline_capable: true
    - tool: "openapi-diff"
      purpose: "OpenAPI schema comparison"
      offline_capable: true
    - tool: "Prism"
      purpose: "OpenAPI mock server"
      offline_capable: true

  scripts:
    - id: "contract-test-check"
      language: "bash"
      purpose: "Analyze contract testing setup"
      source: "inline"
      code: |
        #!/bin/bash
        echo "=== Contract Testing Analysis ==="

        echo "Pact files:"
        find . -name '*.pact.json' -o -name '*-pact.json' 2>/dev/null | wc -l

        echo ""
        echo "OpenAPI specifications:"
        find . -name 'openapi*.yaml' -o -name 'swagger*.yaml' 2>/dev/null | wc -l

        echo ""
        echo "Contract test code:"
        grep -r -l 'Pact\\|contract\\|Contract' --include='*.test.*' . 2>/dev/null | wc -l

        echo ""
        echo "Consumer tests:"
        grep -r -c '@Pact\\|createPact\\|consumer' --include='*.test.*' . 2>/dev/null | awk -F: '{sum+=$2} END {print sum}'

        echo ""
        echo "Provider verification:"
        grep -r -c 'verifyPacts\\|@PactVerify\\|provider' --include='*.test.*' . 2>/dev/null | awk -F: '{sum+=$2} END {print sum}'

signals:
  critical:
    - id: "CONTRACT-CRIT-001"
      signal: "No contract testing for service interfaces"
      evidence_pattern: "Microservices without contract tests"
      explanation: |
        Without contract tests, service interface changes can break
        consumers silently. Integration bugs are discovered in production
        when services are deployed independently. This forces expensive
        coordinated releases or runtime failures.
      remediation: |
        Implement contract testing:
        1. Choose framework (Pact recommended)
        2. Write consumer expectations
        3. Verify providers against contracts
        4. Integrate into CI/CD pipeline
        5. Set up contract broker for sharing

    - id: "CONTRACT-CRIT-002"
      signal: "Provider verification not automated"
      evidence_pattern: "Consumer contracts exist but no provider CI verification"
      explanation: |
        Consumer contracts without provider verification are useless.
        Providers can make breaking changes without knowing. The
        verification step is what makes contracts valuable.
      remediation: |
        Add provider verification to CI:
        1. Fetch contracts from broker
        2. Verify provider against all consumer contracts
        3. Block deployment on verification failure
        4. Publish verification results

  high:
    - id: "CONTRACT-HIGH-001"
      signal: "Breaking changes not detected before merge"
      evidence_pattern: "No can-i-deploy check in pipeline"
      explanation: |
        Without breaking change detection, incompatible versions can
        be deployed. can-i-deploy (Pact) or similar checks prevent
        deploying providers that would break consumers.
      remediation: |
        Add deployment safety checks:
        - Pact: can-i-deploy command in deployment pipeline
        - OpenAPI: schema diff in PR checks
        - Block deployment on breaking changes

    - id: "CONTRACT-HIGH-002"
      signal: "Contracts not version controlled"
      evidence_pattern: "Contracts generated but not stored in repo or broker"
      explanation: |
        Contracts must be shared between teams. Without version control
        or a broker, contracts become stale and coordination breaks down.
      remediation: |
        Set up contract sharing:
        - Use Pact Broker (cloud or self-hosted)
        - Or commit contracts to shared repository
        - Establish contract update workflow

  medium:
    - id: "CONTRACT-MED-001"
      signal: "Incomplete consumer expectations"
      evidence_pattern: "Contracts only test happy path"
      remediation: "Add contracts for error scenarios and edge cases"

    - id: "CONTRACT-MED-002"
      signal: "Contracts don't cover all endpoints"
      evidence_pattern: "Some API endpoints without consumer contracts"
      remediation: "Add consumer tests for all used endpoints"

  low:
    - id: "CONTRACT-LOW-001"
      signal: "Contract test naming inconsistent"
      evidence_pattern: "Unclear contract names"

  positive:
    - id: "CONTRACT-POS-001"
      signal: "Full contract testing coverage"
      evidence_pattern: "All service interfaces have contracts"

    - id: "CONTRACT-POS-002"
      signal: "can-i-deploy in deployment pipeline"
      evidence_pattern: "Breaking change check blocks deployment"

procedure:
  context:
    cognitive_mode: "evaluative"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Identify service interfaces"
      description: |
        Map all service-to-service communication interfaces.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find API definitions"
          command: "find . -name 'openapi*.yaml' -o -name '*.proto' 2>/dev/null"
        - purpose: "Find HTTP client usage"
          command: "grep -r -l 'fetch\\|HttpClient\\|RestTemplate' --include='*.{js,ts,java}' . 2>/dev/null | head -20"
      expected_findings:
        - "Service interface inventory"
        - "Communication patterns"

    - id: "2"
      name: "Inventory contracts"
      description: |
        Count and categorize existing contracts.
      duration_estimate: "15 min"
      commands:
        - purpose: "Find Pact contracts"
          command: "find . -name '*.pact.json' 2>/dev/null | wc -l"
        - purpose: "Find contract tests"
          command: "grep -r -l '@Pact\\|pact' --include='*.test.*' . 2>/dev/null | wc -l"
      expected_findings:
        - "Contract count"
        - "Coverage assessment"

    - id: "3"
      name: "Verify provider testing"
      description: |
        Check that providers verify against contracts.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find provider verification"
          command: "grep -r 'verifyPacts\\|PactVerify\\|verifier' --include='*.{js,ts,java}' . 2>/dev/null | head -10"
        - purpose: "Check CI for verification"
          command: "grep -r 'pact.*verify\\|can-i-deploy' .github/workflows/ .gitlab-ci.yml 2>/dev/null"
      expected_findings:
        - "Provider verification setup"
        - "CI integration status"

    - id: "4"
      name: "Assess deployment safety"
      description: |
        Verify breaking changes are caught before deployment.
      duration_estimate: "15 min"
      commands:
        - purpose: "Find can-i-deploy checks"
          command: "grep -r 'can-i-deploy\\|pact.*broker' .github/workflows/ Jenkinsfile 2>/dev/null"
      expected_findings:
        - "Deployment safety mechanism"
        - "Breaking change prevention"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "contract_matrix"
      format: "table"
      sections:
        - "Service Interfaces"
        - "Contract Coverage"
        - "Verification Status"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Contract Testing Analysis"
        - "Recommendations"

  confidence_guidance:
    high: "Full analysis with CI verification"
    medium: "Static analysis of contracts"
    low: "Pattern matching only"

offline:
  capability: "partial"

  cache_manifest:
    knowledge:
      - source_id: "pact-spec"
        priority: "required"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires detailed analysis"
    full:
      included: true
      priority: 8

closeout_checklist:
  - id: "contract-001"
    item: "Service interfaces mapped"
    level: "CRITICAL"
    verification: "manual"
    verification_notes: "Document all service communication points"
    expected: "Confirmed by reviewer"

  - id: "contract-002"
    item: "Contract coverage assessed"
    level: "BLOCKING"
    verification: "manual"
    verification_notes: "Match contracts to interfaces"
    expected: "Confirmed by reviewer"

  - id: "contract-003"
    item: "Provider verification verified"
    level: "WARNING"
    verification: "grep -r 'verifyPacts\\|PactVerify' . 2>/dev/null | wc -l"
    expected: "Count > 0 (if applicable)"

governance:
  applicable_to:
    archetypes:
      - "microservices"
      - "api-first"

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Interoperability", "Compatibility"]

relationships:
  commonly_combined:
    - "testing-quality-assurance.integration-testing.api-integration-test"
    - "testing-quality-assurance.integration-testing.third-party-integration-test"
    - "api-design.versioning.api-versioning-strategy"
