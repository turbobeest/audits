audit:
  id: testing-quality-assurance.test-data-management.test-data-generation
  name: Test Data Generation
  version: 1.0.0
  last_updated: '2026-01-22'
  status: active
  category: testing-quality-assurance
  category_number: 26
  subcategory: test-data-management
  tier: expert
  estimated_duration: 30-45 min
  completeness: complete
  requires_runtime: false
  destructive: false
execution:
  automatable: 'yes'
  severity: medium
  scope: quality
  default_profiles:
  - full
  - quality
  blocks_phase: false
  parallelizable: true
description:
  what: |
    Evaluates automated test data generation practices including factory
    patterns, builder patterns, faker libraries, and synthetic data tools.
    Assesses consistency, reusability, and quality of generated data.
  why_it_matters: |
    Manual test data creation is slow, error-prone, and inconsistent.
    Automated generation ensures data consistency, speeds up test writing,
    and makes tests more maintainable. Good factories produce realistic
    data that catches edge cases.
  when_to_run:
  - Testing process improvement
  - Test maintenance review
  - New project setup
  - Quality assessment
prerequisites:
  required_artifacts:
  - type: test_files
    description: Test files and supporting code
  access_requirements:
  - Test source code access
discovery:
  file_patterns:
  - glob: '**/factories/**'
    purpose: Factory definitions
  - glob: '**/builders/**'
    purpose: Builder patterns
  - glob: '**/*.factory.{js,ts}'
    purpose: Factory files
  code_patterns:
  - pattern: Factory\.define|factory\.build|faker\.
    type: regex
    scope: test
    purpose: Factory/faker usage
knowledge_sources:
  guides:
  - id: factory-pattern
    name: Factory Pattern for Tests
    url: https://www.martinfowler.com/eaaCatalog/factory.html
    offline_cache: true
  - id: faker-docs
    name: Faker.js Documentation
    url: https://fakerjs.dev/guide/
    offline_cache: true
  learning_resources:
  - id: test-factories
    title: Building Test Factories
    type: guide
    reference: Test Patterns Best Practices
tooling:
  static_analysis:
  - tool: ESLint
    purpose: Factory pattern linting
    offline_capable: true
  - tool: Custom analysis
    purpose: Factory coverage detection
    offline_capable: true
  scripts:
  - id: factory-check
    language: bash
    purpose: Analyze factory usage
    source: inline
    code: |
      #!/bin/bash
      echo "=== Test Data Generation Analysis ==="

      echo "Factory files:"
      find . -name '*.factory.*' -o -name '*Factory*' 2>/dev/null | grep -E '\.(js|ts|py)$' | head -15

      echo ""
      echo "Factory library usage:"
      grep -r -c 'factory\|Factory' --include='*.js' --include='*.ts' . 2>/dev/null | grep -v ':0$' | head -10

      echo ""
      echo "Faker usage:"
      grep -r -c 'faker\.' --include='*.js' --include='*.ts' . 2>/dev/null | grep -v ':0$' | head -10

      echo ""
      echo "Factory libraries in dependencies:"
      grep -E '(fishery|factory-girl|factory_boy|rosie|faker)' package.json requirements.txt 2>/dev/null
signals:
  critical:
  - id: DATAGEN-CRIT-001
    signal: No automated data generation
    evidence_pattern: All test data manually created inline
    explanation: |
      Without automated generation, every test manually creates data.
      This leads to inconsistency, duplication, and maintenance burden.
      Changes to data models require updating many test files.
    remediation: |
      Implement automated data generation:
      1. Choose factory library (Fishery, Factory-Bot, etc.)
      2. Create factories for main entities
      3. Define traits for common variations
      4. Use faker for realistic values
      5. Refactor tests to use factories
  high:
  - id: DATAGEN-HIGH-001
    signal: Factories not used consistently
    evidence_pattern: Mix of factory and manual data creation
    explanation: |
      Inconsistent usage means some tests use factories while others
      don't. This reduces the benefits of automation and makes the
      codebase harder to maintain.
    remediation: |
      Standardize on factories:
      - Establish team guidelines
      - Add linting rules for inline data
      - Migrate legacy tests to factories
      - Review PR for factory usage
  - id: DATAGEN-HIGH-002
    signal: Factories generate invalid data
    evidence_pattern: Factory data fails validation
    explanation: |
      Factories should produce valid objects by default. Invalid data
      causes tests to fail for wrong reasons and masks real issues.
      Default factory output should always be valid.
    remediation: |
      Fix factory defaults:
      - Ensure required fields are populated
      - Use valid value ranges
      - Test factory output validates
      - Add factory unit tests
  medium:
  - id: DATAGEN-MED-001
    signal: No factory traits or variations
    evidence_pattern: Factories only produce default objects
    remediation: Add traits for common variations (admin, inactive, etc.)
  - id: DATAGEN-MED-002
    signal: Hardcoded values in factories
    evidence_pattern: Same values generated every time
    remediation: Use faker for dynamic, realistic values
  low:
  - id: DATAGEN-LOW-001
    signal: Factory structure not documented
    evidence_pattern: Unclear how to use factories
  positive:
  - id: DATAGEN-POS-001
    signal: Comprehensive factory coverage
    evidence_pattern: Factories for all main entities
  - id: DATAGEN-POS-002
    signal: Well-organized factory library
    evidence_pattern: Traits, sequences, and relationships
procedure:
  context:
    cognitive_mode: evaluative
    ensemble_role: auditor
  steps:
  - id: '1'
    name: Find factory definitions
    description: |
      Locate factory and builder patterns in codebase.
    duration_estimate: 10 min
    commands:
    - purpose: Find factory files
      command: find . -name '*factory*' -o -name '*Factory*' 2>/dev/null | grep -E '\.(js|ts|py)$' | head
        -15
    - purpose: Check factory libraries
      command: grep -E '(fishery|factory-girl|rosie|faker)' package.json 2>/dev/null
    expected_findings:
    - Factory approach
    - Library usage
  - id: '2'
    name: Assess factory coverage
    description: |
      Determine which entities have factories.
    duration_estimate: 10 min
    commands:
    - purpose: Count factory definitions
      command: grep -r -l 'Factory\.define\|defineFactory' --include='*.js' --include='*.ts' . 2>/dev/null
        | wc -l
    expected_findings:
    - Entity coverage
    - Gaps identified
  - id: '3'
    name: Review factory quality
    description: |
      Examine factory implementations for quality.
    duration_estimate: 15 min
    commands:
    - purpose: Check faker usage
      command: grep -r -c 'faker\.' --include='*.js' --include='*.ts' . 2>/dev/null | grep -v ':0$' |
        head -10
    expected_findings:
    - Faker usage
    - Trait usage
  - id: '4'
    name: Verify consistency
    description: |
      Check if factories are used consistently.
    duration_estimate: 10 min
    commands:
    - purpose: Find manual data creation
      command: grep -r 'new User\|new Order' --include='*.test.*' --include='*.spec.*' . 2>/dev/null |
        head -10
    expected_findings:
    - Consistency level
    - Manual data usage
output:
  deliverables:
  - type: finding_list
    format: structured
  - type: factory_report
    format: table
    sections:
    - Factory Coverage
    - Library Usage
    - Quality Assessment
  - type: summary
    format: prose
    sections:
    - Executive Summary
    - Generation Analysis
    - Recommendations
  confidence_guidance:
    high: Full factory review with usage analysis
    medium: Pattern detection
    low: Dependency check only
offline:
  capability: full
  cache_manifest:
    knowledge:
    - source_id: factory-pattern
      priority: recommended
profiles:
  membership:
    quick:
      included: false
      reason: Requires code analysis
    quality:
      included: true
      priority: 5
    full:
      included: true
      priority: 6
closeout_checklist:
- id: datagen-001
  item: Factory library identified
  level: CRITICAL
  verification: grep -E '(fishery|factory|faker)' package.json requirements.txt 2>/dev/null | wc -l
  expected: Count > 0
- id: datagen-002
  item: Factory coverage assessed
  level: WARNING
  verification: find . -name '*factory*' 2>/dev/null | wc -l
  expected: Count documented
- id: datagen-003
  item: Faker usage verified
  level: RECOMMENDED
  verification: grep -r -c 'faker\.' . 2>/dev/null | grep -v ':0$' | wc -l
  expected: Count documented
governance:
  applicable_to:
    archetypes:
    - all
  compliance_frameworks:
  - framework: ISO 25010
    controls:
    - Maintainability
relationships:
  commonly_combined:
  - testing-quality-assurance.test-data-management.test-data-strategy
  - testing-quality-assurance.unit-testing.unit-test-maintainability
  - testing-quality-assurance.test-data-management.test-data-isolation
