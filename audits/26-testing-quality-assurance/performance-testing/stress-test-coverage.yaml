# ============================================================
# AUDIT: Stress Test Coverage
# ============================================================
# Evaluates stress testing to verify system behavior at and
# beyond capacity limits.
# ============================================================

audit:
  id: "testing-quality-assurance.performance-testing.stress-test-coverage"
  name: "Stress Test Coverage"
  version: "1.0.0"
  last_updated: "2026-01-22"
  status: "active"

  category: "testing-quality-assurance"
  category_number: 26
  subcategory: "performance-testing"

  tier: "expert"
  estimated_duration: "2-3 hours"  # median: 2h

  completeness: "complete"
  requires_runtime: true
  destructive: false

execution:
  automatable: "yes"
  severity: "high"
  scope: "testing"

  default_profiles:
    - "full"
    - "production"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Evaluates stress testing which pushes the system beyond normal
    capacity to identify breaking points, verify graceful degradation,
    and understand failure modes. Assesses coverage of extreme load
    scenarios, resource exhaustion testing, and recovery behavior.

  why_it_matters: |
    Systems must degrade gracefully under extreme load, not crash
    catastrophically. Stress testing reveals breaking points,
    memory leaks, and cascading failure patterns before they occur
    in production. Understanding failure modes enables better
    architecture and incident response planning.

  when_to_run:
    - "Pre-production validation"
    - "Capacity planning"
    - "After architecture changes"
    - "Incident prevention review"

prerequisites:
  required_artifacts:
    - type: "stress_tests"
      description: "Stress test scripts"
    - type: "capacity_limits"
      description: "Known or expected capacity limits"

  access_requirements:
    - "Source code repository access"
    - "Isolated performance test environment"
    - "System monitoring access"

discovery:
  file_patterns:
    - glob: "**/stress/**"
      purpose: "Stress test directory"
    - glob: "**/*stress*.{js,scala,py}"
      purpose: "Stress test files"

  code_patterns:
    - pattern: "stress|breakpoint|limit|max"
      type: "regex"
      scope: "test"
      purpose: "Stress test scenarios"
    - pattern: "rampUp.*high|stages.*peak"
      type: "regex"
      scope: "test"
      purpose: "High load configurations"

knowledge_sources:
  guides:
    - id: "stress-testing"
      name: "Stress Testing Guide"
      url: "https://www.guru99.com/stress-testing-tutorial.html"
      offline_cache: true
    - id: "breaking-point"
      name: "Finding Breaking Points"
      url: "https://k6.io/docs/test-types/stress-testing/"
      offline_cache: true

  learning_resources:
    - id: "chaos-engineering"
      title: "Chaos Engineering"
      type: "book"
      reference: "ISBN 978-1492043867"

tooling:
  infrastructure_tools:
    - tool: "k6"
      purpose: "Stress test execution"
      offline_capable: true
    - tool: "JMeter"
      purpose: "High-load stress testing"
      offline_capable: true
    - tool: "Gatling"
      purpose: "Stress scenario simulation"
      offline_capable: true

  scripts:
    - id: "stress-test-check"
      language: "bash"
      purpose: "Check stress test coverage"
      source: "inline"
      code: |
        #!/bin/bash
        echo "=== Stress Test Coverage Analysis ==="

        echo "Stress test files:"
        find . -name '*stress*' -name '*.{js,scala,py}' 2>/dev/null | wc -l

        echo ""
        echo "High load configurations:"
        grep -r -c 'stress\|breakpoint\|max.*load' --include='*.js' . 2>/dev/null | awk -F: '{sum+=$2} END {print sum}'

        echo ""
        echo "Ramp-up to peak scenarios:"
        grep -r 'stages\|rampUp' --include='*.js' . 2>/dev/null | head -10

signals:
  critical:
    - id: "STRESS-CRIT-001"
      signal: "No stress testing performed"
      evidence_pattern: "Only load tests at normal levels, no extreme scenarios"
      explanation: |
        Without stress testing, the breaking point is unknown. The
        system may crash, corrupt data, or lose transactions when
        overwhelmed. Understanding failure modes is essential for
        production readiness.
      remediation: |
        Implement stress testing:
        1. Define expected peak load
        2. Create scenarios exceeding peak by 2-3x
        3. Identify breaking points
        4. Document failure behaviors
        5. Test recovery procedures

    - id: "STRESS-CRIT-002"
      signal: "Graceful degradation not verified"
      evidence_pattern: "No tests for system behavior at capacity"
      explanation: |
        Systems should shed load gracefully, not crash. Rate limiting,
        queue backpressure, and timeout handling must be tested to
        ensure predictable behavior under stress.
      remediation: |
        Test degradation behaviors:
        - Rate limiter activation
        - Queue overflow handling
        - Timeout and retry behavior
        - Circuit breaker activation
        - Error response under load

  high:
    - id: "STRESS-HIGH-001"
      signal: "Breaking point not documented"
      evidence_pattern: "Stress tests run but limits not recorded"
      explanation: |
        Without documented breaking points, capacity planning is
        guesswork. Teams don't know when to scale or what metrics
        indicate impending failure.
      remediation: |
        Document breaking points:
        - Maximum concurrent users
        - Maximum requests per second
        - Memory exhaustion threshold
        - Database connection limit
        - Response time degradation curve

    - id: "STRESS-HIGH-002"
      signal: "Recovery testing missing"
      evidence_pattern: "No tests for recovery after overload"
      explanation: |
        Systems must recover after stress. Without recovery testing,
        an overload event may leave the system in a broken state
        requiring manual intervention.
      remediation: |
        Test recovery scenarios:
        - System recovery after load drops
        - Database connection pool recovery
        - Cache repopulation behavior
        - Message queue drain time

  medium:
    - id: "STRESS-MED-001"
      signal: "Resource exhaustion not tested"
      evidence_pattern: "No memory, CPU, or connection limit tests"
      remediation: "Test behavior when specific resources are exhausted"

    - id: "STRESS-MED-002"
      signal: "Cascading failure not tested"
      evidence_pattern: "No multi-service stress scenarios"
      remediation: "Test downstream service failure impact"

  low:
    - id: "STRESS-LOW-001"
      signal: "Stress test results not tracked over time"
      evidence_pattern: "No historical stress test data"

  positive:
    - id: "STRESS-POS-001"
      signal: "Breaking points documented"
      evidence_pattern: "Clear capacity limits defined"

    - id: "STRESS-POS-002"
      signal: "Recovery procedures verified"
      evidence_pattern: "System recovers gracefully from stress"

procedure:
  context:
    cognitive_mode: "critical"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Inventory stress tests"
      description: |
        Find existing stress test scenarios.
      duration_estimate: "15 min"
      commands:
        - purpose: "Find stress tests"
          command: "find . -name '*stress*' 2>/dev/null"
        - purpose: "Find high-load configs"
          command: "grep -r -l 'stress\\|breakpoint' --include='*.js' . 2>/dev/null"
      expected_findings:
        - "Stress test inventory"
        - "Scenario coverage"

    - id: "2"
      name: "Review stress scenarios"
      description: |
        Analyze stress test configurations and load levels.
      duration_estimate: "20 min"
      commands:
        - purpose: "Check load levels"
          command: "grep -r 'vus\\|target' --include='*stress*' . 2>/dev/null | head -15"
      expected_findings:
        - "Load levels tested"
        - "Scenario types"

    - id: "3"
      name: "Check degradation testing"
      description: |
        Verify graceful degradation is tested.
      duration_estimate: "20 min"
      questions:
        - "Are rate limiters tested?"
        - "Is circuit breaker behavior verified?"
        - "Are timeout scenarios covered?"
      expected_findings:
        - "Degradation coverage"
        - "Missing scenarios"

    - id: "4"
      name: "Review documented limits"
      description: |
        Check for documented breaking points and capacity limits.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find capacity documentation"
          command: "find . -name '*capacity*' -o -name '*limits*' 2>/dev/null | head -10"
      expected_findings:
        - "Documented limits"
        - "Documentation gaps"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "stress_report"
      format: "table"
      sections:
        - "Stress Test Coverage"
        - "Breaking Points"
        - "Degradation Testing"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Stress Test Analysis"
        - "Recommendations"

  confidence_guidance:
    high: "Stress tests executed with results"
    medium: "Static analysis of scenarios"
    low: "Documentation review only"

offline:
  capability: "partial"

  cache_manifest:
    knowledge:
      - source_id: "stress-testing"
        priority: "required"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires detailed analysis"
    production:
      included: true
      priority: 3
    full:
      included: true
      priority: 5

closeout_checklist:
  - id: "stress-001"
    item: "Stress tests inventoried"
    level: "CRITICAL"
    verification: "find . -name '*stress*' 2>/dev/null | wc -l"
    expected: "Count documented"

  - id: "stress-002"
    item: "Breaking points documented"
    level: "BLOCKING"
    verification: "manual"
    verification_notes: "Document known capacity limits"
    expected: "Confirmed by reviewer"

  - id: "stress-003"
    item: "Degradation testing verified"
    level: "WARNING"
    verification: "manual"
    verification_notes: "Confirm graceful degradation is tested"
    expected: "Confirmed by reviewer"

governance:
  applicable_to:
    archetypes: ["all"]

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Performance Efficiency", "Reliability"]

relationships:
  commonly_combined:
    - "testing-quality-assurance.performance-testing.load-test-coverage"
    - "testing-quality-assurance.performance-testing.soak-test-coverage"
    - "error-handling-resilience.circuit-breakers.circuit-breaker-implementation"
