# ============================================================
# AUDIT: Edge Case Coverage
# ============================================================
# Evaluates test coverage for boundary conditions, edge cases,
# and corner cases that often harbor bugs.
# ============================================================

audit:
  id: "testing-quality-assurance.test-coverage.edge-case-coverage"
  name: "Edge Case Coverage"
  version: "1.0.0"
  last_updated: "2026-01-22"
  status: "active"

  category: "testing-quality-assurance"
  category_number: 26
  subcategory: "test-coverage"

  tier: "expert"
  estimated_duration: "2-3 hours"  # median: 2h

  completeness: "complete"
  requires_runtime: false
  destructive: false

execution:
  automatable: "partial"
  severity: "high"
  scope: "testing"

  default_profiles:
    - "full"
    - "quality"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Evaluates whether tests adequately cover edge cases, boundary conditions,
    and corner cases. Analyzes test suites for coverage of: null/empty inputs,
    maximum/minimum values, off-by-one boundaries, empty collections, unicode
    and special characters, concurrent access, and exceptional conditions.

  why_it_matters: |
    Edge cases are where bugs hide. Most production incidents stem from
    untested boundary conditions - null pointer exceptions, buffer overflows,
    off-by-one errors, and unexpected input handling. Tests that only cover
    happy paths miss the scenarios that cause production failures.

  when_to_run:
    - "Code review for new features"
    - "After bug fixes (verify edge case was tested)"
    - "Pre-release validation"
    - "Test suite quality assessment"

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Source code with test suite"
    - type: "test_cases"
      description: "Existing test cases to analyze"

  access_requirements:
    - "Source code repository access"
    - "Test suite documentation"

discovery:
  file_patterns:
    - glob: "**/*.test.{js,ts}"
      purpose: "JavaScript test files"
    - glob: "**/test_*.py"
      purpose: "Python test files"
    - glob: "**/*Test.java"
      purpose: "Java test files"

  code_patterns:
    - pattern: "null|undefined|None|nil"
      type: "regex"
      scope: "test"
      purpose: "Null value test cases"
    - pattern: "empty|\\[\\]|\\{\\}|''"
      type: "regex"
      scope: "test"
      purpose: "Empty value test cases"
    - pattern: "boundary|edge|corner|limit|max|min"
      type: "regex"
      scope: "test"
      purpose: "Boundary test cases"
    - pattern: "negative|overflow|underflow"
      type: "regex"
      scope: "test"
      purpose: "Numeric edge cases"

knowledge_sources:
  specifications:
    - id: "boundary-analysis"
      name: "ISTQB Boundary Value Analysis"
      url: "https://glossary.istqb.org/en/term/boundary-value-analysis"
      offline_cache: true
      priority: "required"

  guides:
    - id: "edge-case-testing"
      name: "Testing Edge Cases Best Practices"
      url: "https://www.browserstack.com/guide/edge-case-testing"
      offline_cache: true
    - id: "equivalence-partitioning"
      name: "Equivalence Partitioning Technique"
      url: "https://www.guru99.com/equivalence-partitioning-boundary-value-analysis.html"
      offline_cache: true

  learning_resources:
    - id: "software-testing-book"
      title: "Lessons Learned in Software Testing"
      type: "book"
      reference: "ISBN 978-0471081128"

tooling:
  static_analysis:
    - tool: "Test case analyzers"
      purpose: "Identify test case coverage patterns"
      offline_capable: true
    - tool: "Property-based testing tools"
      purpose: "Generate edge case inputs automatically"
      offline_capable: true

  scripts:
    - id: "edge-case-analyzer"
      language: "bash"
      purpose: "Analyze edge case coverage in tests"
      source: "inline"
      code: |
        #!/bin/bash
        echo "=== Edge Case Coverage Analysis ==="

        echo "Null/undefined tests:"
        grep -r -E "(null|undefined|None|nil)" --include="*.test.*" --include="test_*" . 2>/dev/null | wc -l

        echo "Empty value tests:"
        grep -r -E "(\[\]|\{\}|''|\"\")" --include="*.test.*" --include="test_*" . 2>/dev/null | wc -l

        echo "Boundary tests:"
        grep -r -E "(boundary|edge|limit|MAX|MIN|max|min)" --include="*.test.*" --include="test_*" . 2>/dev/null | wc -l

        echo "Negative/overflow tests:"
        grep -r -E "(negative|overflow|underflow)" --include="*.test.*" --include="test_*" . 2>/dev/null | wc -l

signals:
  critical:
    - id: "EDGECASE-CRIT-001"
      signal: "No null/undefined input tests found"
      evidence_pattern: "Zero tests for null or undefined inputs"
      explanation: |
        Null pointer exceptions are among the most common runtime errors.
        Without explicit null handling tests, the code likely has
        uncaught null dereference bugs waiting to cause production issues.
      remediation: |
        Add null input tests for all public interfaces:
        - Test null as parameter values
        - Test null in collections
        - Test null in nested objects
        - Verify proper error handling or graceful defaults

    - id: "EDGECASE-CRIT-002"
      signal: "Numeric boundary conditions not tested"
      evidence_pattern: "No tests for MAX_VALUE, MIN_VALUE, or zero"
      explanation: |
        Numeric boundary bugs cause security vulnerabilities (integer
        overflow attacks), financial errors, and system crashes. Common
        issue in loop bounds, array indexing, and calculations.
      remediation: |
        Test numeric boundaries:
        - Zero values
        - Maximum/minimum integer values
        - Negative numbers where positive expected
        - Floating point precision edges
        - Division by zero scenarios

  high:
    - id: "EDGECASE-HIGH-001"
      signal: "Empty collection handling not tested"
      evidence_pattern: "No tests with empty arrays, lists, or maps"
      explanation: |
        Empty collection handling often differs from single or multiple
        element cases. Untested empty cases may cause index errors,
        null returns, or incorrect aggregation results.
      remediation: |
        Add tests for empty collections:
        - Empty array/list operations
        - Empty object/map access
        - Empty string handling
        - Empty file processing

    - id: "EDGECASE-HIGH-002"
      signal: "String edge cases not tested"
      evidence_pattern: "No tests for empty strings, unicode, or special characters"
      explanation: |
        String handling bugs cause security issues (injection), display
        problems (encoding), and data corruption. Special characters
        and unicode expose parsing and storage bugs.
      remediation: |
        Test string edge cases:
        - Empty strings
        - Whitespace-only strings
        - Unicode characters
        - Very long strings
        - Special characters (quotes, backslashes)

  medium:
    - id: "EDGECASE-MED-001"
      signal: "Concurrent access scenarios not tested"
      evidence_pattern: "No tests for race conditions or concurrent modification"
      remediation: "Add concurrency tests for shared state modifications"

    - id: "EDGECASE-MED-002"
      signal: "Date/time edge cases not tested"
      evidence_pattern: "No tests for leap years, timezone, DST transitions"
      remediation: "Add date/time boundary tests especially around DST and leap years"

  low:
    - id: "EDGECASE-LOW-001"
      signal: "Environment-specific edge cases not tested"
      evidence_pattern: "No tests for different OS or locale behaviors"

  positive:
    - id: "EDGECASE-POS-001"
      signal: "Property-based testing implemented"
      evidence_pattern: "Using QuickCheck, Hypothesis, or fast-check"

    - id: "EDGECASE-POS-002"
      signal: "Comprehensive boundary value tests exist"
      evidence_pattern: "Tests at min, max, and adjacent values"

procedure:
  context:
    cognitive_mode: "critical"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Analyze existing edge case tests"
      description: |
        Search test suite for evidence of edge case testing patterns.
      duration_estimate: "30 min"
      commands:
        - purpose: "Count null handling tests"
          command: "grep -r -c 'null\\|undefined\\|None' --include='*.test.*' . 2>/dev/null | awk -F: '{sum+=$2} END {print sum}'"
        - purpose: "Count boundary tests"
          command: "grep -r -c 'boundary\\|MAX\\|MIN\\|limit' --include='*.test.*' . 2>/dev/null | awk -F: '{sum+=$2} END {print sum}'"
      expected_findings:
        - "Current edge case test count"
        - "Edge case test distribution"

    - id: "2"
      name: "Identify untested edge cases"
      description: |
        Map source code boundary conditions to test coverage.
      duration_estimate: "45 min"
      commands:
        - purpose: "Find functions with boundary checks"
          command: "grep -r -E 'if.*(<|>|<=|>=|==).*[0-9]' --include='*.{js,ts,py}' . 2>/dev/null | head -30"
      expected_findings:
        - "Boundary conditions in code"
        - "Missing boundary tests"

    - id: "3"
      name: "Assess null handling coverage"
      description: |
        Verify that null/undefined inputs are tested for key functions.
      duration_estimate: "30 min"
      questions:
        - "Are public API null inputs tested?"
        - "Are optional parameters tested as undefined?"
        - "Are null returns handled by callers?"
      expected_findings:
        - "Null handling test gaps"
        - "High-risk null scenarios"

    - id: "4"
      name: "Evaluate string handling tests"
      description: |
        Check for string edge case coverage including unicode and special chars.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find string edge case tests"
          command: "grep -r -E \"(empty.*string|unicode|special.*char|whitespace)\" --include='*.test.*' . 2>/dev/null | wc -l"
      expected_findings:
        - "String edge case test count"
        - "Missing string scenarios"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "edge_case_matrix"
      format: "table"
      sections:
        - "Null/Undefined Coverage"
        - "Boundary Value Coverage"
        - "Empty Collection Coverage"
        - "String Edge Cases"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Edge Case Coverage Analysis"
        - "High-Risk Gaps"
        - "Recommendations"

  confidence_guidance:
    high: "Automated analysis of test patterns"
    medium: "Manual review of test cases"
    low: "Estimated from naming conventions"

offline:
  capability: "full"

  cache_manifest:
    knowledge:
      - source_id: "boundary-analysis"
        priority: "required"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires detailed test analysis"
    full:
      included: true
      priority: 8

closeout_checklist:
  - id: "edgecase-001"
    item: "Null handling tests present"
    level: "CRITICAL"
    verification: "grep -r 'null\\|undefined' --include='*.test.*' . 2>/dev/null | wc -l | xargs test 0 -lt && echo PASS || echo FAIL"
    expected: "PASS"

  - id: "edgecase-002"
    item: "Boundary value tests present"
    level: "BLOCKING"
    verification: "grep -r -E 'MAX|MIN|boundary|limit' --include='*.test.*' . 2>/dev/null | wc -l | xargs test 0 -lt && echo PASS || echo FAIL"
    expected: "PASS"

  - id: "edgecase-003"
    item: "Empty collection tests present"
    level: "WARNING"
    verification: "grep -r -E '\\[\\]|empty' --include='*.test.*' . 2>/dev/null | wc -l | xargs test 0 -lt && echo PASS || echo FAIL"
    expected: "PASS"

governance:
  applicable_to:
    archetypes: ["all"]

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Reliability", "Robustness"]

relationships:
  commonly_combined:
    - "testing-quality-assurance.test-coverage.branch-coverage"
    - "testing-quality-assurance.unit-testing.unit-test-presence"
    - "testing-quality-assurance.test-effectiveness.defect-detection-rate"
