# ============================================================
# AUDIT: Path Coverage
# ============================================================
# Evaluates path coverage to ensure all execution paths through
# the code are tested.
# ============================================================

audit:
  id: "testing-quality-assurance.test-coverage.path-coverage"
  name: "Path Coverage"
  version: "1.0.0"
  last_updated: "2026-01-22"
  status: "active"

  category: "testing-quality-assurance"
  category_number: 26
  subcategory: "test-coverage"

  tier: "phd"
  estimated_duration: "2-4 hours"  # median: 3h

  completeness: "complete"
  requires_runtime: false
  destructive: false

execution:
  automatable: "partial"
  severity: "medium"
  scope: "testing"

  default_profiles:
    - "full"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Evaluates path coverage which measures whether all possible execution
    paths through code have been tested. Unlike branch coverage which only
    requires each branch to be taken once, path coverage requires testing
    all combinations of branches. Analyzes cyclomatic complexity to identify
    code requiring comprehensive path testing.

  why_it_matters: |
    Path coverage reveals bugs that only manifest under specific combinations
    of conditions. Sequential conditional statements can interact in unexpected
    ways that branch coverage misses. For safety-critical or high-reliability
    systems, path coverage provides the highest confidence in test completeness.

  when_to_run:
    - "Safety-critical code review"
    - "Complex algorithm validation"
    - "Security audit of authentication flows"
    - "Financial calculation verification"

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Source code with control flow complexity"
    - type: "complexity_analysis"
      description: "Cyclomatic complexity metrics"

  access_requirements:
    - "Source code repository access"
    - "Coverage instrumentation capability"

discovery:
  file_patterns:
    - glob: "**/*.{js,ts,py,java,go,c,cpp}"
      purpose: "Source files for path analysis"

  code_patterns:
    - pattern: "if.*if.*if"
      type: "regex"
      scope: "source"
      purpose: "Identify nested conditionals"
    - pattern: "while.*if|for.*if"
      type: "regex"
      scope: "source"
      purpose: "Identify loop/conditional combinations"

  metrics_queries:
    - system: "SonarQube"
      query: "component_measures?metricKeys=complexity"
      purpose: "Cyclomatic complexity for path estimation"
      threshold: "< 10 per function"

knowledge_sources:
  specifications:
    - id: "mccabe-complexity"
      name: "McCabe Cyclomatic Complexity"
      url: "https://www.mccabe.com/pdf/mccabe-nist235r.pdf"
      offline_cache: true
      priority: "required"

  guides:
    - id: "path-coverage-guide"
      name: "Basis Path Testing"
      url: "https://www.guru99.com/basis-path-testing.html"
      offline_cache: true

  learning_resources:
    - id: "software-testing-myers"
      title: "The Art of Software Testing"
      type: "book"
      reference: "ISBN 978-1118031964"

tooling:
  static_analysis:
    - tool: "eslint-plugin-complexity"
      purpose: "JavaScript complexity analysis"
      offline_capable: true
    - tool: "radon"
      purpose: "Python cyclomatic complexity"
      offline_capable: true
    - tool: "SonarQube"
      purpose: "Multi-language path complexity"
      offline_capable: false
    - tool: "Understand"
      purpose: "Control flow graph analysis"
      offline_capable: true

  scripts:
    - id: "path-analysis"
      language: "bash"
      purpose: "Estimate path coverage requirements"
      source: "inline"
      code: |
        #!/bin/bash
        echo "=== Path Complexity Analysis ==="

        # Python complexity
        if command -v radon &> /dev/null; then
          echo "Python cyclomatic complexity:"
          radon cc . -a -s 2>/dev/null | tail -20
        fi

        # JavaScript complexity
        if [ -f "package.json" ]; then
          echo "Consider running: npx complexity-report"
        fi

signals:
  critical:
    - id: "PATHCOV-CRIT-001"
      signal: "High-complexity code has minimal path coverage"
      evidence_threshold: "Cyclomatic complexity > 15 with < 50% path coverage"
      explanation: |
        Complex code with many paths but low coverage has exponentially
        more untested scenarios. Bugs hide in path combinations that
        individual branch tests miss.
      remediation: |
        For high-complexity code:
        1. Consider refactoring to reduce complexity
        2. Use basis path testing to identify minimum test set
        3. Add tests for each linearly independent path
        4. Consider property-based testing for combinatorial coverage

    - id: "PATHCOV-CRIT-002"
      signal: "Safety-critical code lacks path coverage"
      evidence_pattern: "Financial/safety logic without path testing"
      explanation: |
        Safety-critical systems require highest assurance levels. Path
        coverage provides the strongest confidence that all execution
        scenarios have been validated.
      remediation: |
        Implement full path coverage for safety-critical modules.
        Consider formal verification for highest assurance.

  high:
    - id: "PATHCOV-HIGH-001"
      signal: "Nested conditionals without combinatorial tests"
      evidence_pattern: "3+ levels of nested if statements with < 50% paths tested"
      explanation: |
        Nested conditionals create exponential path combinations. Testing
        only happy paths misses interactions between conditions.
      remediation: |
        Create test matrix covering all practical path combinations
        through nested conditionals. Prioritize error path combinations.

    - id: "PATHCOV-HIGH-002"
      signal: "Loop and conditional interactions untested"
      evidence_pattern: "Loops containing conditionals with partial path coverage"
      explanation: |
        Conditional behavior inside loops may vary across iterations.
        Tests must cover condition variations within loop contexts.
      remediation: |
        Test loop conditions with multiple iterations and varying
        conditional outcomes across iterations.

  medium:
    - id: "PATHCOV-MED-001"
      signal: "Cyclomatic complexity exceeds practical testing threshold"
      evidence_threshold: "Complexity > 20 per function"
      remediation: "Refactor to reduce complexity before attempting path coverage"

    - id: "PATHCOV-MED-002"
      signal: "Path coverage not tracked separately from branch coverage"
      evidence_pattern: "No path coverage metrics in reporting"
      remediation: "Implement path coverage tooling for critical modules"

  low:
    - id: "PATHCOV-LOW-001"
      signal: "Minor utility functions have incomplete path coverage"
      evidence_pattern: "Low-risk helpers with partial path testing"

  positive:
    - id: "PATHCOV-POS-001"
      signal: "Critical functions have basis path coverage"
      evidence_threshold: "All linearly independent paths tested"

    - id: "PATHCOV-POS-002"
      signal: "Complexity managed to enable full path coverage"
      evidence_threshold: "No functions exceed complexity 10"

procedure:
  context:
    cognitive_mode: "critical"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Analyze code complexity"
      description: |
        Calculate cyclomatic complexity to understand path coverage
        requirements.
      duration_estimate: "30 min"
      commands:
        - purpose: "Python complexity analysis"
          command: "radon cc . -a -s 2>/dev/null || pip install radon && radon cc . -a -s"
        - purpose: "Find high-complexity functions"
          command: "radon cc . -a 2>/dev/null | grep -E '^[A-F] [0-9]+' | sort -t' ' -k2 -nr | head -20"
      expected_findings:
        - "Complexity distribution"
        - "High-complexity functions list"

    - id: "2"
      name: "Identify critical paths"
      description: |
        Determine which code paths are most critical and require
        comprehensive testing.
      duration_estimate: "30 min"
      questions:
        - "Which functions handle security decisions?"
        - "Which code processes financial data?"
        - "Which paths affect data integrity?"
      expected_findings:
        - "Critical path inventory"
        - "Priority ranking for path testing"

    - id: "3"
      name: "Calculate basis paths"
      description: |
        For critical functions, identify the minimum set of linearly
        independent paths that must be tested.
      duration_estimate: "45 min"
      commands:
        - purpose: "Create control flow graph"
          command: "echo 'Use tools like pycfg or manual CFG analysis'"
      expected_findings:
        - "Basis path count per function"
        - "Test case requirements"

    - id: "4"
      name: "Assess path test coverage"
      description: |
        Compare existing tests against basis path requirements.
      duration_estimate: "30 min"
      questions:
        - "Do tests cover all basis paths?"
        - "Are path combinations for nested conditions tested?"
        - "Are loop iteration variations tested?"
      expected_findings:
        - "Path coverage gaps"
        - "Missing test scenarios"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "complexity_report"
      format: "table"
      sections:
        - "Cyclomatic Complexity by Module"
        - "High-Complexity Functions"
        - "Basis Path Requirements"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Path Coverage Analysis"
        - "Refactoring Recommendations"

  confidence_guidance:
    high: "Full path coverage verified through instrumentation"
    medium: "Basis paths identified and tested"
    low: "Path coverage estimated from complexity"

offline:
  capability: "full"

  cache_manifest:
    knowledge:
      - source_id: "mccabe-complexity"
        priority: "required"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires extensive analysis"
    full:
      included: true
      priority: 10

closeout_checklist:
  - id: "pathcov-001"
    item: "Cyclomatic complexity analyzed"
    level: "CRITICAL"
    verification: "radon cc . -a 2>/dev/null | head -5 && echo PASS || echo FAIL"
    expected: "PASS"

  - id: "pathcov-002"
    item: "High-complexity functions identified"
    level: "BLOCKING"
    verification: "manual"
    verification_notes: "List functions with complexity > 10"
    expected: "Confirmed by reviewer"

  - id: "pathcov-003"
    item: "Critical paths prioritized"
    level: "WARNING"
    verification: "manual"
    verification_notes: "Document critical paths requiring full coverage"
    expected: "Confirmed by reviewer"

governance:
  applicable_to:
    archetypes:
      - "safety-critical"
      - "financial"
      - "security"

  compliance_frameworks:
    - framework: "DO-178C"
      controls: ["MC/DC", "Modified Condition/Decision Coverage"]
    - framework: "IEC 61508"
      controls: ["SIL requirements"]

relationships:
  commonly_combined:
    - "testing-quality-assurance.test-coverage.branch-coverage"
    - "testing-quality-assurance.test-coverage.mutation-testing-coverage"
    - "code-quality-maintainability.code-complexity.cyclomatic-complexity"
