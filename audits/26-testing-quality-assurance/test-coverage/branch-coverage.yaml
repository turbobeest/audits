# ============================================================
# AUDIT: Branch Coverage
# ============================================================
# Evaluates branch/decision coverage to ensure conditional
# logic is thoroughly tested.
# ============================================================

audit:
  id: "testing-quality-assurance.test-coverage.branch-coverage"
  name: "Branch Coverage"
  version: "1.0.0"
  last_updated: "2026-01-22"
  status: "active"

  category: "testing-quality-assurance"
  category_number: 26
  subcategory: "test-coverage"

  tier: "expert"
  estimated_duration: "1-2 hours"  # median: 1h

  completeness: "complete"
  requires_runtime: false
  destructive: false

execution:
  automatable: "yes"
  severity: "high"
  scope: "testing"

  default_profiles:
    - "full"
    - "quality"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    Evaluates branch coverage (decision coverage) which measures whether
    both true and false outcomes of conditional statements have been
    exercised. Analyzes if-else branches, switch cases, ternary operators,
    and logical operators to ensure all decision points are tested.

  why_it_matters: |
    High line coverage can mask untested conditional logic. Code may be
    executed without testing all branches, leaving edge cases and error
    handling untested. Branch coverage reveals gaps in conditional testing
    that line coverage misses, identifying where bugs are most likely to
    hide in untested decision paths.

  when_to_run:
    - "Code review for complex conditional logic"
    - "Pre-release quality validation"
    - "After adding error handling code"
    - "Security-sensitive code changes"

prerequisites:
  required_artifacts:
    - type: "source_code"
      description: "Source code with conditional logic"
    - type: "coverage_tooling"
      description: "Coverage tool with branch coverage support"

  access_requirements:
    - "Source code repository access"
    - "Coverage report with branch metrics"

discovery:
  file_patterns:
    - glob: "**/coverage/**"
      purpose: "Coverage report directories"
    - glob: "**/*.lcov"
      purpose: "LCOV reports with branch data"

  code_patterns:
    - pattern: "if\\s*\\(|else\\s*\\{|switch\\s*\\(|\\?.*:"
      type: "regex"
      scope: "source"
      purpose: "Identify conditional statements"
    - pattern: "&&|\\|\\|"
      type: "regex"
      scope: "source"
      purpose: "Identify logical operators requiring branch testing"

  metrics_queries:
    - system: "SonarQube"
      query: "component_measures?metricKeys=branch_coverage"
      purpose: "Branch coverage metrics"
      threshold: ">= 70%"

knowledge_sources:
  specifications:
    - id: "istqb-branch"
      name: "ISTQB Decision/Branch Coverage"
      url: "https://glossary.istqb.org/en/term/branch-coverage"
      offline_cache: true
      priority: "required"

  guides:
    - id: "code-coverage-types"
      name: "Understanding Code Coverage Types"
      url: "https://www.atlassian.com/continuous-delivery/software-testing/code-coverage"
      offline_cache: true

  learning_resources:
    - id: "software-testing"
      title: "Software Testing: A Craftsman's Approach"
      type: "book"
      reference: "ISBN 978-1466560680"

tooling:
  static_analysis:
    - tool: "istanbul/nyc"
      purpose: "JavaScript branch coverage"
      offline_capable: true
    - tool: "coverage.py"
      purpose: "Python branch coverage (--branch flag)"
      offline_capable: true
    - tool: "JaCoCo"
      purpose: "Java branch coverage"
      offline_capable: true
    - tool: "gcov"
      purpose: "C/C++ branch coverage"
      offline_capable: true

  scripts:
    - id: "branch-coverage-check"
      language: "bash"
      purpose: "Analyze branch coverage metrics"
      source: "inline"
      code: |
        #!/bin/bash
        echo "=== Branch Coverage Analysis ==="

        if [ -f "coverage/coverage-summary.json" ]; then
          echo "Branch coverage from JSON:"
          cat coverage/coverage-summary.json | jq '.total.branches'
        elif [ -f "coverage/lcov.info" ]; then
          echo "Branch coverage from LCOV:"
          grep -E "^BRF:|^BRH:" coverage/lcov.info | tail -2
        else
          echo "No coverage reports found"
        fi

signals:
  critical:
    - id: "BRANCHCOV-CRIT-001"
      signal: "Branch coverage below 40%"
      evidence_threshold: "Branch coverage < 40%"
      explanation: |
        Most conditional logic is untested. Error handlers, edge cases,
        and alternate code paths likely have no test coverage, creating
        high risk of bugs in production scenarios.
      remediation: |
        Focus branch coverage improvement on:
        1. Error handling and exception paths
        2. Validation and boundary conditions
        3. Security-sensitive decision points
        4. Complex business logic branches

    - id: "BRANCHCOV-CRIT-002"
      signal: "Security-critical code has low branch coverage"
      evidence_pattern: "Auth/validation modules with branch coverage < 60%"
      explanation: |
        Security code with untested branches may have exploitable flaws
        in error handling or edge cases that attackers could leverage.
      remediation: |
        Achieve 100% branch coverage for authentication, authorization,
        and input validation code paths.

  high:
    - id: "BRANCHCOV-HIGH-001"
      signal: "Significant gap between line and branch coverage"
      evidence_threshold: "Line coverage - branch coverage > 25%"
      explanation: |
        Large gaps indicate tests execute code but skip conditional
        branches. Tests may only exercise happy paths while error
        handling remains untested.
      remediation: |
        Review tests for files with largest line/branch coverage gap.
        Add tests for else branches, error conditions, and edge cases.

    - id: "BRANCHCOV-HIGH-002"
      signal: "Error handling branches not covered"
      evidence_pattern: "catch/except/else blocks with 0% coverage"
      explanation: |
        Untested error handlers may fail in production when exceptions
        occur, potentially causing cascading failures or data corruption.
      remediation: |
        Add unit tests that trigger exception conditions and verify
        error handling behavior.

  medium:
    - id: "BRANCHCOV-MED-001"
      signal: "Default switch/case branches not covered"
      evidence_pattern: "Default cases in switch statements untested"
      remediation: "Add tests for unexpected input values hitting defaults"

    - id: "BRANCHCOV-MED-002"
      signal: "Short-circuit evaluation branches not tested"
      evidence_pattern: "Complex && or || conditions only partially tested"
      remediation: "Test both short-circuit and full evaluation paths"

  low:
    - id: "BRANCHCOV-LOW-001"
      signal: "Debug/logging branches not covered"
      evidence_pattern: "Debug-only code paths untested"

  positive:
    - id: "BRANCHCOV-POS-001"
      signal: "Branch coverage above 70%"
      evidence_threshold: "Branch coverage >= 70%"

    - id: "BRANCHCOV-POS-002"
      signal: "Critical modules have higher branch than line coverage"
      evidence_threshold: "Thorough branch testing in core modules"

procedure:
  context:
    cognitive_mode: "evaluative"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "Collect branch coverage metrics"
      description: |
        Run tests with branch coverage enabled and collect metrics.
      duration_estimate: "15 min"
      commands:
        - purpose: "Run with branch coverage (Python)"
          command: "pytest --cov --cov-branch 2>/dev/null || echo 'Run manually'"
        - purpose: "Check existing coverage"
          command: "cat coverage/coverage-summary.json 2>/dev/null | jq '.total.branches'"
      expected_findings:
        - "Overall branch coverage percentage"
        - "Comparison to line coverage"

    - id: "2"
      name: "Identify low branch coverage files"
      description: |
        Find modules with significant branch coverage gaps.
      duration_estimate: "20 min"
      commands:
        - purpose: "Find files with low branch coverage"
          command: "cat coverage/coverage-summary.json 2>/dev/null | jq 'to_entries | map(select(.value.branches.pct < 50)) | .[].key'"
      expected_findings:
        - "List of files with poor branch coverage"
        - "Pattern of uncovered branches"

    - id: "3"
      name: "Analyze uncovered branches"
      description: |
        Examine specific uncovered branches to understand testing gaps.
      duration_estimate: "25 min"
      commands:
        - purpose: "View detailed branch info"
          command: "grep -E 'BRDA:.*,-' coverage/lcov.info 2>/dev/null | head -30"
      expected_findings:
        - "Specific uncovered decision points"
        - "Pattern of missing test cases"

    - id: "4"
      name: "Assess critical path coverage"
      description: |
        Verify that security and business-critical branches are covered.
      duration_estimate: "20 min"
      questions:
        - "Are authentication decision branches tested?"
        - "Are validation failure paths tested?"
        - "Are error handling branches exercised?"
      expected_findings:
        - "Critical path coverage assessment"
        - "High-risk untested branches"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "coverage_report"
      format: "table"
      sections:
        - "Branch Coverage Metrics"
        - "Line vs Branch Comparison"
        - "Uncovered Branches"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "Branch Coverage Analysis"
        - "Priority Improvements"

  confidence_guidance:
    high: "Branch coverage from instrumented test run"
    medium: "Coverage from existing reports"
    low: "Estimated from code inspection"

offline:
  capability: "partial"

  cache_manifest:
    knowledge:
      - source_id: "istqb-branch"
        priority: "required"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires detailed analysis"
    full:
      included: true
      priority: 3

closeout_checklist:
  - id: "branchcov-001"
    item: "Branch coverage metrics collected"
    level: "CRITICAL"
    verification: "cat coverage/coverage-summary.json 2>/dev/null | jq '.total.branches.pct' && echo PASS || echo FAIL"
    expected: "PASS"

  - id: "branchcov-002"
    item: "Line vs branch gap analyzed"
    level: "BLOCKING"
    verification: "manual"
    verification_notes: "Document difference between line and branch coverage"
    expected: "Confirmed by reviewer"

  - id: "branchcov-003"
    item: "Critical path branches verified"
    level: "WARNING"
    verification: "manual"
    verification_notes: "Confirm security-critical branches are tested"
    expected: "Confirmed by reviewer"

governance:
  applicable_to:
    archetypes: ["all"]

  compliance_frameworks:
    - framework: "ISO 25010"
      controls: ["Testability"]
    - framework: "DO-178C"
      controls: ["Decision Coverage"]

relationships:
  commonly_combined:
    - "testing-quality-assurance.test-coverage.code-coverage"
    - "testing-quality-assurance.test-coverage.path-coverage"
    - "testing-quality-assurance.test-coverage.edge-case-coverage"
