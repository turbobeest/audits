# ============================================================
# AUDIT: Client-Side State Management
# ============================================================
# Evaluates how application state is managed on the client side
# including state architecture, persistence, and synchronization.
# ============================================================

audit:
  id: "data-state-management.application-state.client-side-state-management"

  name: "Client-Side State Management"

  version: "1.0.0"
  last_updated: "2026-01-18"
  status: "active"

  category: "data-state-management"
  category_number: 8
  subcategory: "application-state"

  tier: "expert"
  estimated_duration: "2 hours"

  completeness: "complete"
  requires_runtime: false
  destructive: false

execution:
  automatable: "partial"
  severity: "high"
  scope: "codebase"

  default_profiles:
    - "full"

  blocks_phase: false
  parallelizable: true

description:
  what: |
    This audit evaluates client-side state management approaches including
    state architecture patterns, local vs global state decisions, state
    persistence strategies, and state synchronization with the server.
    It examines React, Vue, Angular, or framework-agnostic state patterns.

  why_it_matters: |
    Poor client-side state management leads to bugs that are difficult
    to reproduce and debug. Inconsistent state causes UI glitches, stale
    data display, and user frustration. Over-complicated state architecture
    increases development time and bug rates. Well-designed state management
    improves reliability and developer productivity.

  when_to_run:
    - "During frontend architecture review"
    - "When state-related bugs increase"
    - "Before major frontend refactoring"
    - "When scaling frontend complexity"

prerequisites:
  required_artifacts:
    - type: "frontend-codebase"
      description: "Frontend application code"
    - type: "state-architecture"
      description: "State management library or pattern documentation"

  access_requirements:
    - "Read access to frontend code"
    - "Access to state management configuration"

discovery:
  code_patterns:
    - pattern: "useState|useReducer|createStore|Redux|Zustand|MobX|Vuex|Pinia"
      type: "regex"
      scope: "source"
      purpose: "Identify state management patterns"
    - pattern: "localStorage|sessionStorage|IndexedDB|persist"
      type: "regex"
      scope: "source"
      purpose: "Identify state persistence"
    - pattern: "useContext|createContext|Provider"
      type: "regex"
      scope: "source"
      purpose: "Identify context-based state sharing"

  file_patterns:
    - glob: "**/store/**/*"
      purpose: "State store definitions"
    - glob: "**/state/**/*"
      purpose: "State management code"
    - glob: "**/redux/**/*"
      purpose: "Redux-specific code"
    - glob: "**/hooks/**/*"
      purpose: "Custom hooks including state hooks"

knowledge_sources:
  guides:
    - id: "react-state-patterns"
      name: "React State Management Patterns"
      url: "https://react.dev/learn/managing-state"
      offline_cache: true

    - id: "redux-best-practices"
      name: "Redux Style Guide"
      url: "https://redux.js.org/style-guide/"
      offline_cache: true

tooling:
  static_analysis:
    - tool: "eslint-plugin-react-hooks"
      purpose: "Detect hook usage issues"
      offline_capable: true

signals:
  critical:
    - id: "CLSTATE-CRIT-001"
      signal: "Sensitive data stored in client-side state unencrypted"
      evidence_pattern: "localStorage.setItem with tokens, passwords, PII"
      explanation: |
        Sensitive data in unencrypted client storage is vulnerable to XSS
        attacks and malicious browser extensions. Tokens can be stolen,
        passwords exposed, and PII leaked.
      remediation: "Never store sensitive data in localStorage; use httpOnly cookies for tokens; encrypt if persistence required"

    - id: "CLSTATE-CRIT-002"
      signal: "State mutations outside controlled update patterns"
      evidence_pattern: "Direct object mutation instead of immutable updates"
      explanation: |
        Direct state mutations bypass React's reconciliation, causing
        components to not re-render when state changes. This creates
        subtle bugs where UI doesn't reflect current state.
      remediation: "Use immutable update patterns; enable strict mode; use immer for complex updates"

  high:
    - id: "CLSTATE-HIGH-001"
      signal: "Global state used for local component concerns"
      evidence_pattern: "Redux/Zustand for form state, modal visibility, etc."
      explanation: |
        Putting local concerns in global state increases complexity and
        couples unrelated components. Form state doesn't need to be global.
        This creates unnecessary re-renders and coupling.
      remediation: "Use local state (useState) for component-specific concerns; global state only for shared data"

    - id: "CLSTATE-HIGH-002"
      signal: "No state normalization for relational data"
      evidence_pattern: "Nested/duplicated entities in state instead of normalized form"
      explanation: |
        Denormalized state with nested entities creates update anomalies.
        Updating an entity requires finding all copies. Inconsistencies
        arise when copies get out of sync.
      remediation: "Normalize state for relational data; use entity adapters; reference by ID"

  medium:
    - id: "CLSTATE-MED-001"
      signal: "State persistence without versioning"
      evidence_pattern: "localStorage persistence without schema version"
      remediation: "Version persisted state; handle migrations for schema changes"

    - id: "CLSTATE-MED-002"
      signal: "Derived state stored instead of computed"
      evidence_pattern: "Storing computed values that should derive from other state"
      remediation: "Use selectors or computed properties for derived state"

  low:
    - id: "CLSTATE-LOW-001"
      signal: "Inconsistent state update patterns across codebase"

  positive:
    - id: "CLSTATE-POS-001"
      signal: "Clear separation of local and global state"
    - id: "CLSTATE-POS-002"
      signal: "Proper state normalization with selectors"

procedure:
  context:
    cognitive_mode: "critical"
    ensemble_role: "auditor"

  steps:
    - id: "1"
      name: "State Management Pattern Discovery"
      description: |
        Identify state management libraries and patterns
        used in the frontend application.
      duration_estimate: "25 min"

      commands:
        - purpose: "Find state management libraries"
          command: "grep -riE 'redux|zustand|mobx|vuex|pinia|recoil|jotai' --include='*.json' --include='*.ts' --include='*.tsx' --include='*.js' . 2>/dev/null | head -40"
        - purpose: "Find React state hooks"
          command: "grep -riE 'useState|useReducer|useContext' --include='*.tsx' --include='*.jsx' --include='*.ts' . 2>/dev/null | head -50"
        - purpose: "Find store definitions"
          command: "find . -type f \\( -name '*store*' -o -name '*State*' \\) \\( -name '*.ts' -o -name '*.tsx' -o -name '*.js' \\) 2>/dev/null | head -30"

      expected_findings:
        - "State management approach"
        - "Store organization"

    - id: "2"
      name: "State Persistence Analysis"
      description: |
        Analyze how state is persisted and what data is stored
        client-side.
      duration_estimate: "25 min"

      commands:
        - purpose: "Find localStorage usage"
          command: "grep -riE 'localStorage|sessionStorage' --include='*.ts' --include='*.tsx' --include='*.js' . 2>/dev/null | head -40"
        - purpose: "Find IndexedDB usage"
          command: "grep -riE 'indexedDB|IDBDatabase|Dexie|localForage' --include='*.ts' --include='*.tsx' --include='*.js' . 2>/dev/null | head -20"
        - purpose: "Find persist configuration"
          command: "grep -riE 'persist|rehydrate|PERSIST|REHYDRATE' --include='*.ts' --include='*.tsx' . 2>/dev/null | head -30"

      expected_findings:
        - "Persistence mechanisms"
        - "Data stored client-side"

    - id: "3"
      name: "State Update Pattern Analysis"
      description: |
        Evaluate state update patterns for immutability
        and correctness.
      duration_estimate: "25 min"

      commands:
        - purpose: "Find potential direct mutations"
          command: "grep -riE '\\.push\\(|\\.splice\\(|Object\\.assign\\(state|state\\.\\w+\\s*=' --include='*.ts' --include='*.tsx' --include='*.js' . 2>/dev/null | head -40"
        - purpose: "Find immutable update patterns"
          command: "grep -riE 'produce|immer|\\.\\.\\.|spread' --include='*.ts' --include='*.tsx' . 2>/dev/null | head -30"
        - purpose: "Find reducer patterns"
          command: "grep -riE 'reducer|createSlice|createReducer' --include='*.ts' --include='*.tsx' . 2>/dev/null | head -30"

      expected_findings:
        - "Update patterns"
        - "Immutability compliance"

    - id: "4"
      name: "State Scope Analysis"
      description: |
        Evaluate whether state is appropriately scoped
        (local vs global).
      duration_estimate: "25 min"

      commands:
        - purpose: "Find global state access"
          command: "grep -riE 'useSelector|useStore|useDispatch|connect\\(' --include='*.tsx' --include='*.ts' . 2>/dev/null | head -40"
        - purpose: "Find context providers"
          command: "grep -riE 'createContext|Provider|useContext' --include='*.tsx' --include='*.ts' . 2>/dev/null | head -30"

      expected_findings:
        - "Global state usage"
        - "State scope appropriateness"

output:
  deliverables:
    - type: "finding_list"
      format: "structured"

    - type: "summary"
      format: "prose"
      sections:
        - "Executive Summary"
        - "State Architecture"
        - "Persistence Analysis"
        - "Update Patterns"
        - "Recommendations"

  confidence_guidance:
    high: "Clear evidence of unsafe persistence or mutation patterns"
    medium: "Patterns suggest issues, component-level review needed"
    low: "Architecture appears sound but edge cases uncertain"

offline:
  capability: "full"

  cache_manifest:
    knowledge:
      - source_id: "react-state-patterns"
        priority: "required"

profiles:
  membership:
    quick:
      included: false
      reason: "Requires comprehensive frontend analysis"
    full:
      included: true
      priority: 1

closeout_checklist:
  - id: "clstate-001"
    item: "State management approach identified"
    level: "CRITICAL"
    verification: "grep -riE 'useState|redux|zustand|mobx' --include='*.ts' --include='*.tsx' . 2>/dev/null | wc -l | xargs -I{} test {} -gt 0 && echo PASS || echo FAIL"
    expected: "PASS"

  - id: "clstate-002"
    item: "No sensitive data in localStorage unencrypted"
    level: "BLOCKING"
    verification: "manual"
    verification_notes: "Reviewer should verify no tokens/PII stored in plain localStorage"
    expected: "Confirmed by reviewer"

  - id: "clstate-003"
    item: "Immutable update patterns used"
    level: "WARNING"
    verification: "manual"
    verification_notes: "Reviewer should verify state updates use immutable patterns"
    expected: "Confirmed by reviewer"

governance:
  applicable_to:
    archetypes: ["web-application", "spa"]

  compliance_frameworks:
    - framework: "Security Best Practices"
      controls: ["SEC-001", "SEC-002"]

relationships:
  commonly_combined:
    - "data-state-management.application-state.state-synchronization"
    - "data-state-management.application-state.state-persistence"
