audit:
  id: signal-processing-data-acquisition.algorithm-verification.edge-case-handling
  name: Edge Case Handling Audit
  version: 1.0.0
  last_updated: '2026-01-22'
  status: active
  category: signal-processing-data-acquisition
  category_number: 40
  subcategory: algorithm-verification
  tier: expert
  estimated_duration: 1-2 hours  # median: 1h
  completeness: complete
  requires_runtime: true
  destructive: false
execution:
  automatable: partial
  severity: high
  scope: software
  default_profiles:
  - full
  - signal-processing
  blocks_phase: false
  parallelizable: true
description:
  what: |
    This audit evaluates handling of edge cases and boundary conditions
    in signal processing algorithms. It examines:
    - Zero-length input handling
    - Single sample processing
    - First/last sample boundary effects
    - DC input (zero frequency) behavior
    - Nyquist frequency handling
    - NaN and infinity handling
  why_it_matters: |
    Edge cases reveal algorithm robustness:
    - Many algorithms fail on zero-length input
    - Boundary effects affect first/last samples
    - DC and Nyquist are special frequencies
    - NaN propagates through calculations
    - Edge case failures cause crashes or corruption

    Robust algorithms handle all valid inputs correctly,
    including edge cases that may be rare in practice.
  when_to_run:
  - Algorithm implementation
  - Code review
  - Robustness testing
  - Bug investigation
prerequisites:
  required_artifacts:
  - type: source_code
    description: Algorithm implementation
  - type: specification
    description: Expected edge case behavior
  access_requirements:
  - Access to algorithm source
  - Test capability
discovery:
  code_patterns:
  - pattern: (length|size|count)\s*[=<>]=?\s*[01]
    type: regex
    scope: source
    purpose: Detect length checks
  - pattern: (nan|NaN|inf|Inf|isnan|isinf)
    type: regex
    scope: source
    purpose: Detect NaN/Inf handling
  - pattern: if.*==\s*0|if.*<\s*1
    type: regex
    scope: source
    purpose: Detect edge case checks
  file_patterns:
  - glob: '**/algorithm*.{c,h,cpp,py}'
    purpose: Algorithm files
  - glob: '**/test*.{c,cpp,py}'
    purpose: Test files
signals:
  critical:
  - id: EDGE-CRIT-001
    signal: Zero-length input causes crash or corruption
    evidence_indicators:
    - No length validation
    - Divide by zero with zero length
    - Array access with zero elements
    explanation: |
      Zero-length input is a common edge case that causes
      crashes if not handled. Division by length or array
      access fails without explicit handling.
    remediation: |
      - Check for zero length at entry
      - Return appropriate result for empty input
      - Avoid division without length check
      - Document zero-length behavior
    cwe: CWE-369
  - id: EDGE-CRIT-002
    signal: NaN or infinity not handled
    evidence_indicators:
    - NaN propagates to output
    - No NaN detection or handling
    - Infinity causes incorrect results
    explanation: |
      NaN and infinity can appear from overflow, divide by
      zero, or invalid operations. Without handling, they
      corrupt all subsequent calculations.
    remediation: |
      - Check for NaN/Inf in inputs
      - Handle or reject invalid values
      - Prevent operations that produce NaN/Inf
      - Document NaN handling policy
    cwe: CWE-682
  high:
  - id: EDGE-HIGH-001
    signal: Boundary samples incorrectly processed
    evidence_indicators:
    - First/last samples differ from middle
    - Filter startup transient not handled
    - Edge effects corrupt results
    explanation: |
      Many algorithms have boundary effects where first and
      last samples are processed differently. This must be
      handled consistently and documented.
    remediation: |
      - Document boundary behavior
      - Implement consistent edge handling
      - Use zero-padding or reflection as appropriate
      - Mark affected samples if needed
  - id: EDGE-HIGH-002
    signal: DC or Nyquist frequency mishandled
    evidence_indicators:
    - DC component (bin 0) handled incorrectly
    - Nyquist frequency special case missed
    - Real FFT DC/Nyquist not separate
    explanation: |
      DC (zero frequency) and Nyquist are special cases in
      many spectral algorithms. They may need different
      handling than other frequencies.
    remediation: |
      - Handle DC component explicitly
      - Treat Nyquist frequency appropriately
      - Verify real FFT DC/Nyquist handling
      - Document special case behavior
  medium:
  - id: EDGE-MED-001
    signal: Single sample input not handled
    evidence_indicators:
    - Algorithm requires minimum length > 1
    - Single sample causes incorrect result
    - No minimum length documentation
    explanation: |
      Some algorithms have minimum input length requirements.
      Single sample inputs may cause errors or require
      special handling.
    remediation: |
      - Document minimum input requirements
      - Handle short inputs explicitly
      - Return appropriate result for single sample
      - Validate input length
  low:
  - id: EDGE-LOW-001
    signal: Edge case behavior not documented
    evidence_indicators:
    - Handling not specified
    - Edge case tests missing
    - Behavior undefined at boundaries
    explanation: |
      Undocumented edge case behavior makes the algorithm
      unpredictable. Users need to know how edge cases
      are handled.
    remediation: |
      - Document all edge case behaviors
      - Add edge case tests
      - Specify boundary handling
      - Include in API documentation
  positive:
  - id: EDGE-POS-001
    signal: Comprehensive edge case handling
    evidence_indicators:
    - All edge cases handled
    - Behavior documented
    - Tests cover boundaries
procedure:
  context:
    cognitive_mode: analytical
    ensemble_role: test-engineer
  steps:
  - id: '1'
    name: Edge Case Review
    description: |
      Review edge case handling.
    duration_estimate: 30 min
    commands:
    - purpose: Find edge case checks
      command: |
        grep -rniE "(length|size|count).*[<>=]|nan|inf" \
          --include="*.c" --include="*.h" --include="*.py" . 2>/dev/null | head -30
    expected_findings:
    - Length validation
    - NaN/Inf handling
    - Boundary checks
output:
  deliverables:
  - type: finding_list
    format: structured
  - type: summary
    format: prose
    sections:
    - Edge Case Analysis
    - Robustness Assessment
    - Recommendations
profiles:
  membership:
    quick:
      included: false
    full:
      included: true
      priority: 3
    signal-processing:
      included: true
      priority: 2
closeout_checklist:
- id: edge-001
  item: Zero-length input handled
  level: CRITICAL
  verification: manual
  verification_notes: Test with zero-length input
  expected: Confirmed by reviewer
- id: edge-002
  item: NaN/Inf handled appropriately
  level: BLOCKING
  verification: manual
  verification_notes: Test with NaN and Inf inputs
  expected: Confirmed by reviewer
governance:
  applicable_to:
    archetypes:
    - signal-processing
    - scientific-computing
    - safety-critical
relationships:
  commonly_combined:
  - signal-processing.algorithm-verification.algorithm-correctness
  - signal-processing.algorithm-verification.overflow-underflow-handling
  - code-quality.testing.boundary-testing

# Glossary of domain-specific terms:
glossary:
  "mu (step size)": "Learning rate parameter in adaptive filters, controls convergence speed vs stability"
  "LMS": "Least Mean Squares - adaptive filter algorithm that minimizes mean squared error"
  "FFT": "Fast Fourier Transform - efficient algorithm to compute discrete Fourier transform"
